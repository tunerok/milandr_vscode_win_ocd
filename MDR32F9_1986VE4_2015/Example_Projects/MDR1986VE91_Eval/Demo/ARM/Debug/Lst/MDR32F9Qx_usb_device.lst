L 1 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\USB_Library\MDR32F9Qx_usb_device.c"
N/**
N  ******************************************************************************
N  * @file    USB_Library\MDR32F9Qx_usb_device.c
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    21/02/2011
N  * @brief   This file contains implementation of the EndPoint and Device basic
N  *          functionality as of USB Specification Rev.2 Chapter 9.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32F9Qx_usb_device.c
N  */
N
N/* Includes ------------------------------------------------------------------*/
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_config.h"
L 1 "..\..\Config\MDR32F9Qx_config.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32F9Qx_Demo\Project\Demo\MDR32F9Qx_config.h
N  * @author  Milandr Application Team
N  * @version V1.2.0
N  * @date    10/07/2010
N  * @brief   Library configuration file.
N  ******************************************************************************
N  * <br><br>
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, MILANDR SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Milandr</center></h2>
N  */
N
N/**
N * @mainpage MDR32F9Qx Standard Peripherals Library.
N * MDR32F9Qx Standard Peripherals Library is a package consisting of
N * all standard peripheral device drivers for 1986BE9x, K1986BE9x, MDR32F9Qx
N * and 1986VE1T microcontrollers.
N * This library is a firmware package which contains a collection of routines,
N * data structures and macros covering the features of Milandr MDR32F9Qx
N * peripherals. It includes a description of the device drivers plus a set of
N * examples for each peripheral. The firmware library allows any device to be
N * used in the user application without the need for in-depth study of each
N * peripherals specifications. Using the Standard Peripherals Library has two
N * advantages: it saves significant time that would otherwise be spent in
N * coding, while simultaneously reducing application development and
N * integration costs.
N *
N * The MDR32F9Qx Standard Peripherals Library is compatible with Milandr
N * 1986BE9x evaluation boards and Milandr evaluation board for MC 1986VE1T
N * (EVAL 22.0 B).
N *
N * The MDR32F9Qx Standard Peripherals Library is full CMSIS compliant.
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_CONFIG_H
N#define __MDR32F9Qx_CONFIG_H
N
N#include "MDR32F9Qx_board.h"
L 1 "..\..\Config\MDR32F9Qx_board.h" 1
N/**
N  ******************************************************************************
N  * @file    Demo\MDR32F9Qx_board.h
N  * @author  Phyton Application Team
N  * @version V1.2.0
N  * @date    10.07.2010
N  * @brief   Evaluation board configuration file.
N  ******************************************************************************
N  * <br><br>
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_BOARD_H
N#define __MDR32F9Qx_BOARD_H
N
N/* Uncomment the line corresponding to the Milandr evaluation board
N   used to run the example */
N#if !defined (USE_MDR32F9Q1_Rev0)  && !defined (USE_MDR32F9Q1_Rev1)  && \
N    !defined (USE_MDR32F9Q2_Rev0) && !defined (USE_MDR32F9Q2_Rev1) && \
N    !defined (USE_MDR32F9Q3_Rev0) && !defined (USE_MDR32F9Q3_Rev1)
X#if !0L  && !0L  &&     !0L && !0L &&     !0L && !0L
N
N/* #define USE_MDR32F9Q1_Rev0 */
N
N #define USE_MDR32F9Q1_Rev1  
N
N/* #define USE_MDR32F9Q2_Rev0 */
N
N/* #define USE_MDR32F9Q2_Rev1 */
N
N/* #define USE_MDR32F9Q3_Rev0 */
N
N/* #define USE_MDR32F9Q3_Rev1 */
N
N/* #define USE_MDR1986VE1T  */
N
N/* #define USE_MDR1986VE3  */
N
N/* #define USE_MDR1986VE9x  */
N
N/* #define USE_MDR1986VE94 */
N
N#endif
N
N#endif /* __MDR32F9Qx_BOARD_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE MDR32F9Qx_board.h */
N
L 47 "..\..\Config\MDR32F9Qx_config.h" 2
N#include "MDR32F9Qx_lib.h"
L 1 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_lib.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32F9Qx_lib.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    23/03/2011
N  * @brief   This file contains all file IDs of the Milandr MDR32F9Qx
N  *          firmware library source files.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32F9Qx_lib.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9QX_LIB_H
N#define __MDR32F9QX_LIB_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define FILEID__MDR32F9X_CAN_C					1
N#define FILEID__MDR32F9X_USB_C					2
N#define FILEID__MDR32F9X_EEPROM_C				3
N#define FILEID__MDR32F9X_RST_CLK_C				4
N#define FILEID__MDR32F9X_DMA_C					5
N#define FILEID__MDR32F9X_UART_C					6
N#define FILEID__MDR32F9X_SSP_C					7
N#define FILEID__MDR32F9X_I2C_C					8
N#define FILEID__MDR32F9X_POWER_C				9
N#define FILEID__MDR32F9X_WWDG_C					10
N#define FILEID__MDR32F9X_IWDG_C					11
N#define FILEID__MDR32F9X_TIMER_C				12
N#define FILEID__MDR32F9X_ADC_C					13
N#define FILEID__MDR32F9X_DAC_C					14
N#define FILEID__MDR32F9X_COMP_C					15
N#define FILEID__MDR32F9X_PORT_C					16
N#define FILEID__MDR32F9X_BKP_C					17
N#define FILEID__MDR32F9X_EBC_C					18
N#define FILEID__MDR32F9X_USB_DEVICE_C			19
N#define FILEID__MDR32F9X_USB_CDC_C				20
N#define FILEID__MDR32F9X_MIL_STD1553_C			21
N#define FILEID__MDR32F9X_ARINC429R_C			22
N#define FILEID__MDR32F9X_ARINC429T_C			23
N#define FILEID__MDR32F9X_ETH_C					24
N#define FILEID__MDR32F9Qx_AUDIO_C				25
N#define FILEID__MDR32F9Qx_KEYPAD_C				26
N#define FILEID__MDR32F9Qx_LED_C					27
N
N#define  FILEID__USER_LO                    	100
N
N/* Supported USB Device Classes */
N#define USB_DEVICE_CLASS_CDC 2
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9QX_LIB_H */
N
N/******************* (C) COPYRIGHT 2013 Milandr ********************************
N*
N* END OF FILE MDR32F9Qx_lib.h */
L 48 "..\..\Config\MDR32F9Qx_config.h" 2
N#include "stdint.h"
L 1 "C:\Keil5\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 180721 $
N * Checkin $Date: 2013-06-24 09:41:57 +0100 (Mon, 24 Jun 2013) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 49 "..\..\Config\MDR32F9Qx_config.h" 2
N
N#if defined (USE_MDR32F9Q1_Rev0) || defined (USE_MDR32F9Q1_Rev1) ||\
N    defined (USE_MDR32F9Q2_Rev0) || defined (USE_MDR32F9Q2_Rev1) ||\
N    defined (USE_MDR32F9Q3_Rev0) || defined (USE_MDR32F9Q3_Rev1) ||\
N    defined (USE_MDR1986VE94)
X#if 0L || 1L ||    0L || 0L ||    0L || 0L ||    0L
N	#define USE_MDR1986VE9x
N#endif
N
N
N/* Selet the header file for target microcontroller */
N#if defined ( USE_MDR1986VE9x )
X#if 1L
N	#include "MDR32Fx.h"
L 1 "..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32Fx.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    22/06/2011
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the Milandr MDR32Fx microcontroller.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32Fx.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32FX_H
N#define __MDR32FX_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @defgroup MDR1986VE9x MDR1986VE9x
N *  @{
N */
N
N/** @defgroup __MDR32Fx_Peripheral MDR32F9Qx Peripheral
N  * @{
N  */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #pragma anon_unions
N#endif
N
N/* MDR32Fx Interrupt Number Definition */
Ntypedef enum IRQn
N{
N/*---- Cortex-M3 Processor Exceptions Numbers --------------------------------*/
N  NonMaskableInt_IRQn     = -14,  /*!<  2 Non Maskable Interrupt              *///!< NonMaskableInt_IRQn
N  HardFault_IRQn          = -13,  /*!<  3 Hard Fault Interrupt                *///!< HardFault_IRQn
N  MemoryManagement_IRQn   = -12,  /*!<  4 Memory Management Interrupt         *///!< MemoryManagement_IRQn
N  BusFault_IRQn           = -11,  /*!<  5 Bus Fault Interrupt                 *///!< BusFault_IRQn
N  UsageFault_IRQn         = -10,  /*!<  6 Usage Fault Interrupt               *///!< UsageFault_IRQn
N  SVCall_IRQn             = -5,   /*!< 11 SV Call Interrupt                   *///!< SVCall_IRQn
N  PendSV_IRQn             = -2,   /*!< 14 Pend SV Interrupt                   *///!< PendSV_IRQn
N  SysTick_IRQn            = -1,   /*!< 15 System Tick Timer Interrupt         *///!< SysTick_IRQn
N
N/*---- MDR32Fx specific Interrupt Numbers ------------------------------------*/
N  CAN1_IRQn               =  0,   /*!< CAN1 Interrupt                         *///!< CAN1_IRQn
N  CAN2_IRQn               =  1,   /*!< CAN1 Interrupt                         *///!< CAN2_IRQn
N  USB_IRQn                =  2,   /*!< USB Host Interrupt                     *///!< USB_IRQn
N  DMA_IRQn                =  5,   /*!< DMA Interrupt                          *///!< DMA_IRQn
N  UART1_IRQn              =  6,   /*!< UART1 Interrupt                        *///!< UART1_IRQn
N  UART2_IRQn              =  7,   /*!< UART2 Interrupt                        *///!< UART2_IRQn
N  SSP1_IRQn               =  8,   /*!< SSP1 Interrupt                         *///!< SSP1_IRQn
N  I2C_IRQn                =  10,  /*!< I2C Interrupt                          *///!< I2C_IRQn
N  POWER_IRQn              =  11,  /*!< POWER Detecor Interrupt                *///!< POWER_IRQn
N  WWDG_IRQn               =  12,  /*!< Window Watchdog Interrupt              *///!< WWDG_IRQn
N  Timer1_IRQn             =  14,  /*!< Timer1 Interrupt                       *///!< Timer1_IRQn
N  Timer2_IRQn             =  15,  /*!< Timer2 Interrupt                       *///!< Timer2_IRQn
N  Timer3_IRQn             =  16,  /*!< Timer3 Interrupt                       *///!< Timer3_IRQn
N  ADC_IRQn                =  17,  /*!< ADC Interrupt                          *///!< ADC_IRQn
N  COMPARATOR_IRQn         =  19,  /*!< COMPARATOR Interrupt                   *///!< COMPARATOR_IRQn
N  SSP2_IRQn               =  20,  /*!< SSP2 Interrupt                         *///!< SSP2_IRQn
N  BACKUP_IRQn             =  27,  /*!< BACKUP Interrupt                       *///!< BACKUP_IRQn
N  EXT_INT1_IRQn           =  28,  /*!< EXT_INT1 Interrupt                     *///!< EXT_INT1_IRQn
N  EXT_INT2_IRQn           =  29,  /*!< EXT_INT2 Interrupt                     *///!< EXT_INT2_IRQn
N  EXT_INT3_IRQn           =  30,  /*!< EXT_INT3 Interrupt                     *///!< EXT_INT3_IRQn
N  EXT_INT4_IRQn           =  31   /*!< EXT_INT4 Interrupt                     *///!< EXT_INT4_IRQn
N}IRQn_Type;
N
N/** @addtogroup __Configuration_of_CMSIS Configuration of CMSIS
N  * @{
N  */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __CM3_REV              0x0102   /*!< Cortex-M3 Core Revision                      */
N#define __MPU_PRESENT             1     /*!< MPU present or not                           */
N#define __NVIC_PRIO_BITS          3     /*!< Number of Bits used for Priority Levels      */
N#define __Vendor_SysTickConfig    0     /*!< Set to 1 if different SysTick Config is used */
N
N/** @} */ /* End of group __Configuration_of_CMSIS */
N
N/* Includes ------------------------------------------------------------------*/
N#include "core_cm3.h"
L 1 "..\..\..\..\Libraries\CMSIS\CM3\CoreSupport\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V3.20
N * @date     25. February 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M3
N  @{
N */
N
N/*  CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM3_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM3_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) |                                     __CM3_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x03)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CMCARM__ )
S  #define __ASM            #pragma asm                                /*!< #pragma asm for Phyton CMC-ARM Compiler      */
S  #define __INLINE         __inline                                   /*!< inline keyword for Phyton CMC-ARM Compiler */
S  #define __STATIC_INLINE  static __inline
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI__VFP_SUPPORT____
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "..\..\..\..\Libraries\CMSIS\CM3\CoreSupport\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.22
N * @date     10. June 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5040049 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x03) >= 0x03)
N
N/** \brief  Reverse bit order of value
N
N    This function reverses the bit order of the given value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __RBIT                            __rbit
N
N
N/** \brief  LDR Exclusive (8 bit)
N
N    This function performs a exclusive LDR command for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (16 bit)
N
N    This function performs a exclusive LDR command for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (32 bit)
N
N    This function performs a exclusive LDR command for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
N
N
N/** \brief  STR Exclusive (8 bit)
N
N    This function performs a exclusive STR command for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXB(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (16 bit)
N
N    This function performs a exclusive STR command for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXH(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (32 bit)
N
N    This function performs a exclusive STR command for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  Remove the exclusive lock
N
N    This function removes the exclusive lock which is created by LDREX.
N
N */
N#define __CLREX                           __clrex
N
N
N/** \brief  Signed Saturate
N
N    This function saturates a signed value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (1..32)
N    \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/** \brief  Unsigned Saturate
N
N    This function saturates an unsigned value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (0..31)
N    \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/** \brief  Count leading zeros
N
N    This function counts the number of leading zeros of a data value.
N
N    \param [in]  value  Value to count the leading zeros
N    \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2)); 
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 141 "..\..\..\..\Libraries\CMSIS\CM3\CoreSupport\core_cm3.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "..\..\..\..\Libraries\CMSIS\CM3\CoreSupport\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.20
N * @date     25. February 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5040049 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x03) >= 0x03)
N
N/** \brief  Enable FIQ
N
N    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/** \brief  Disable FIQ
N
N    This function disables FIQ interrupts by setting the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/** \brief  Get Base Priority
N
N    This function returns the current value of the Base Priority register.
N
N    \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/** \brief  Set Base Priority
N
N    This function assigns the given value to the Base Priority register.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N
N/** \brief  Get Fault Mask
N
N    This function returns the current value of the Fault Mask register.
N
N    \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/** \brief  Set Fault Mask
N
N    This function assigns the given value to the Fault Mask register.
N
N    \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x03) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H */
L 142 "..\..\..\..\Libraries\CMSIS\CM3\CoreSupport\core_cm3.h" 2
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x03) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x03) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                  
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                  
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                  
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                  
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                  
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                  
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                     
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                     
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                  
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                     
N  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
X  volatile uint32_t HFSR;                     
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
X  volatile uint32_t MMFAR;                    
N  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
X  volatile uint32_t BFAR;                     
N  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                     
N  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                   
N  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                      
N  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                      
N  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                  
N  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
X  volatile const  uint32_t ISAR[5];                  
N       uint32_t RESERVED0[5];
N  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
X  volatile uint32_t CPACR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if (__CM3_REV < 0x0201)                   /* core r2p1 */
X#if (0x0102 < 0x0201)                    
N#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
S#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N    \brief      Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/** \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
X  volatile const  uint32_t ICTR;                     
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((1L) && (0x0102 >= 0x200))
S  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register      */
N#else
N       uint32_t RESERVED1[1];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                   
N    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                  
N    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                  
N  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
X  volatile uint32_t TER;                      
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                      
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
X  volatile uint32_t TCR;                      
N       uint32_t RESERVED3[29];
N  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
X  volatile  uint32_t IWR;                      
N  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
X  volatile const  uint32_t IRR;                      
N  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                     
N       uint32_t RESERVED4[43];
N  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
X  volatile  uint32_t LAR;                      
N  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
X  volatile const  uint32_t LSR;                      
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                     
N  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                     
N  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                     
N  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                     
N  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                     
N  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                     
N  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                     
N  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                     
N  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                     
N  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                     
N  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                     
N  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                     
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
X  volatile uint32_t CYCCNT;                   
N  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
X  volatile uint32_t CPICNT;                   
N  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
X  volatile uint32_t EXCCNT;                   
N  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
X  volatile uint32_t SLEEPCNT;                 
N  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
X  volatile uint32_t LSUCNT;                   
N  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
X  volatile uint32_t FOLDCNT;                  
N  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
X  volatile const  uint32_t PCSR;                     
N  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
X  volatile uint32_t COMP0;                    
N  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
X  volatile uint32_t MASK0;                    
N  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
X  volatile uint32_t FUNCTION0;                
N       uint32_t RESERVED0[1];
N  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
X  volatile uint32_t COMP1;                    
N  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
X  volatile uint32_t MASK1;                    
N  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
X  volatile uint32_t FUNCTION1;                
N       uint32_t RESERVED1[1];
N  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
X  volatile uint32_t COMP2;                    
N  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
X  volatile uint32_t MASK2;                    
N  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
X  volatile uint32_t FUNCTION2;                
N       uint32_t RESERVED2[1];
N  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
X  volatile uint32_t COMP3;                    
N  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
X  volatile uint32_t MASK3;                    
N  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
X  volatile uint32_t FUNCTION3;                
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N    \brief      Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/** \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
X  volatile uint32_t SSPSR;                    
N  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                    
N       uint32_t RESERVED0[2];
N  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                     
N       uint32_t RESERVED1[55];
N  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                     
N       uint32_t RESERVED2[131];
N  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                     
N  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                     
N  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                     
N       uint32_t RESERVED3[759];
N  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                  
N  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                    
N  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;                
N       uint32_t RESERVED4[1];
N  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;                
N  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                    
N  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                   
N       uint32_t RESERVED5[39];
N  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                 
N  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                 
N       uint32_t RESERVED7[8];
N  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                    
N  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                  
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
N
N#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N    \brief      Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/** \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                     
N  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                      
N  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                     
N  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                     
N  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                  
N  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                  
N  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                  
N  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                  
N  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                  
N  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                  
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Type definitions for the Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/** \brief  Set Priority Grouping
N
N  The function sets the priority grouping field using the required unlock sequence.
N  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N  Only values from 0..7 are used.
N  In case of a conflict between priority grouping and available
N  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]      PriorityGroup  Priority grouping field.
N */
N
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFUL << 16) | (7UL << 8));              
N  reg_value  =  (reg_value                                 |
N                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FA << 16) |
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/** \brief  Get Priority Grouping
N
N  The function reads the priority grouping field from the NVIC Interrupt Controller.
N
N    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8);    
N}
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Active Interrupt
N
N    The function reads the active register in NVIC and returns the active bit.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not active.
N    \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 3)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)] = ((priority << (8 - 3)) & 0xff);    }         
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 3)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)]           >> (8 - 3)));  }  
N}
N
N
N/** \brief  Encode Priority
N
N    The function encodes the priority for an interrupt with the given priority group,
N    preemptive priority value, and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS), the samllest possible priority group is set.
N
N    \param [in]     PriorityGroup  Used priority group.
N    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N    \param [in]       SubPriority  Subpriority value (starting from 0).
N    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 3) ? 3 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 3) < 7) ? 0 : PriorityGroupTmp - 7 + 3;
N
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/** \brief  Decode Priority
N
N    The function decodes an interrupt priority value with a given priority group to
N    preemptive priority value and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N
N    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N    \param [in]     PriorityGroup  Used priority group.
N    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N    \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 3) ? 3 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 3) < 7) ? 0 : PriorityGroupTmp - 7 + 3;
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                 (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1UL << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<3) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_core_DebugFunctions ITM Functions
N    \brief   Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
N#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/** \brief  ITM Send Character
N
N    The function transmits a character via the ITM channel 0, and
N    \li Just returns when no debugger is connected that has booked the output.
N    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N
N    \param [in]     ch  Character to transmit.
N
N    \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X  if ((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL << 0))                  &&       
N      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000UL) )->TER & (1UL << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t) ch;
N  }
N  return (ch);
N}
N
N
N/** \brief  ITM Receive Character
N
N    The function inputs a character via the external variable \ref ITM_RxBuffer.
N
N    \return             Received character.
N    \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
Xstatic __inline int32_t ITM_ReceiveChar (void) {
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/** \brief  ITM Check Character
N
N    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N
N    \return          0  No character available.
N    \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void) {
Xstatic __inline int32_t ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N#endif
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
N
L 99 "..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 2
N#include "system_MDR32F9Qx.h"
L 1 "..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm\system_MDR32F9Qx.h" 1
N/**
N  ******************************************************************************
N  * @file    system_MDR32F9Qx.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    11/06/2010
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Header File.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE system_MDR32F9Qx.h
N  */
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @defgroup MDR1986VE9x
N *  @{
N */
N
N/** @defgroup __MDR32F9QX MDR32F9QX System
N  * @{
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __SYSTEM_MDR32F9Qx_H
N#define __SYSTEM_MDR32F9Qx_H
N
N/** @addtogroup __MDR32F9QX_System_Exported_Variables MDR32F9QX System Exported Variables
N  * @{
N  */
N
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock)
N                                           *   default value */
N
N/** @} */ /* End of group __MDR32F9QX_System_Exported_Variables */
N
N/** @addtogroup __MDR32F9QX_System_Exported_Functions MDR32F9QX System Exported Functions
N  * @{
N  */
N
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N
N/** @} */ /* End of group __MDR32F9QX_System_Exported_Functions */
N
N#endif /*__SYSTEM_MDR32F9Qx_H */
N
N/** @} */ /* End of group __MDR32F9QX */
N
N/** @} */ /* End of group MDR1986VE9x */
N
N/** @} */ /* End of group __CMSIS */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE system_MDR32F9Qx.h */
L 100 "..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 2
N
N/** @defgroup __Exported_types Exported types
N  * @{
N  */
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus, BitStatus;
N
N#define IS_BIT_STATUS(STATUS)	(((STATUS) == RESET) || ((STATE) == SET))
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N/** @} */ /* End of group __Exported_types */
N
N/** @addtogroup __MDR32Fx_Peripheral_Units MDR32F9Qx Peripheral Units
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_CAN CAN
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_CAN_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_CAN_BUF_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t ID;
X  volatile uint32_t ID;
N  __IO uint32_t DLC;
X  volatile uint32_t DLC;
N  __IO uint32_t DATAL;
X  volatile uint32_t DATAL;
N  __IO uint32_t DATAH;
X  volatile uint32_t DATAH;
N}MDR_CAN_BUF_TypeDef;
N
N/* MDR_CAN_BUF_FILTER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t MASK;
X  volatile uint32_t MASK;
N  __IO uint32_t FILTER;
X  volatile uint32_t FILTER;
N}MDR_CAN_BUF_FILTER_TypeDef;
N
N/* MDR_CAN_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CONTROL;
X  volatile uint32_t CONTROL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t BITTMNG;
X  volatile uint32_t BITTMNG;
N       uint32_t RESERVED0;
N  __IO uint32_t INT_EN;
X  volatile uint32_t INT_EN;
N       uint32_t RESERVED1[2];
N  __IO uint32_t OVER;
X  volatile uint32_t OVER;
N  __IO uint32_t RXID;
X  volatile uint32_t RXID;
N  __IO uint32_t RXDLC;
X  volatile uint32_t RXDLC;
N  __IO uint32_t RXDATAL;
X  volatile uint32_t RXDATAL;
N  __IO uint32_t RXDATAH;
X  volatile uint32_t RXDATAH;
N  __IO uint32_t TXID;
X  volatile uint32_t TXID;
N  __IO uint32_t TXDLC;
X  volatile uint32_t TXDLC;
N  __IO uint32_t DATAL;
X  volatile uint32_t DATAL;
N  __IO uint32_t DATAH;
X  volatile uint32_t DATAH;
N  __IO uint32_t BUF_CON[32];
X  volatile uint32_t BUF_CON[32];
N  __IO uint32_t INT_RX;
X  volatile uint32_t INT_RX;
N  __IO uint32_t RX;
X  volatile uint32_t RX;
N  __IO uint32_t INT_TX;
X  volatile uint32_t INT_TX;
N  __IO uint32_t TX;
X  volatile uint32_t TX;
N       uint32_t RESERVED2[76];
N    MDR_CAN_BUF_TypeDef CAN_BUF[32];
N       uint32_t RESERVED3[64];
N    MDR_CAN_BUF_FILTER_TypeDef CAN_BUF_FILTER[32];
N}MDR_CAN_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CONTROL	CAN CONTROL
N  * @{
N  */ 
N
N/*-- CAN_CONTROL: CAN Control Register -----------------------------*/
N/* Bit field positions: */
N#define CAN_CONTROL_CAN_EN_Pos                  0
N#define CAN_CONTROL_ROM_Pos                     1
N#define CAN_CONTROL_STM_Pos                     2
N#define CAN_CONTROL_SAP_Pos                     3
N#define CAN_CONTROL_ROP_Pos                     4
N
N/* Bit field masks: */
N#define CAN_CONTROL_CAN_EN                      ((uint32_t)0x00000001)
N#define CAN_CONTROL_ROM                         ((uint32_t)0x00000002)
N#define CAN_CONTROL_STM                         ((uint32_t)0x00000004)
N#define CAN_CONTROL_SAP                         ((uint32_t)0x00000008)
N#define CAN_CONTROL_ROP                         ((uint32_t)0x00000010)
N
N/** @} */ /* End of group CAN_CONTROL */
N
N/** @defgroup Periph_CAN_STATUS	CAN STATUS
N  * @{
N  */ 
N
N/*-- CAN_STATUS: CAN Status Register -------------------------------*/
N/* Bit field positions: */
N#define CAN_STATUS_RX_READY_Pos                 0
N#define CAN_STATUS_TX_READY_Pos                 1
N#define CAN_STATUS_ERROR_OVER_Pos               2
N#define CAN_STATUS_BIT_ERR_Pos                  3
N#define CAN_STATUS_BIT_STUFF_ERR_Pos            4
N#define CAN_STATUS_CRC_ERR_Pos                  5
N#define CAN_STATUS_FRAME_ERR_Pos                6
N#define CAN_STATUS_ACK_ERR_Pos                  7
N#define CAN_STATUS_IDLOWER_Pos                  8
N#define CAN_STATUS_ERR_STATUS_Pos               9
N#define CAN_STATUS_RX_ERR_CNT8_Pos              11
N#define CAN_STATUS_TX_ERR_CNT8_Pos              12
N#define CAN_STATUS_RX_ERR_CNT_Pos               16
N#define CAN_STATUS_TX_ERR_CNT_Pos               24
N
N/* Bit field masks: */
N#define CAN_STATUS_RX_READY                     ((uint32_t)0x00000001)
N#define CAN_STATUS_TX_READY                     ((uint32_t)0x00000002)
N#define CAN_STATUS_ERROR_OVER                   ((uint32_t)0x00000004)
N#define CAN_STATUS_BIT_ERR                      ((uint32_t)0x00000008)
N#define CAN_STATUS_BIT_STUFF_ERR                ((uint32_t)0x00000010)
N#define CAN_STATUS_CRC_ERR                      ((uint32_t)0x00000020)
N#define CAN_STATUS_FRAME_ERR                    ((uint32_t)0x00000040)
N#define CAN_STATUS_ACK_ERR                      ((uint32_t)0x00000080)
N#define CAN_STATUS_IDLOWER                      ((uint32_t)0x00000100)
N#define CAN_STATUS_ERR_STATUS_Msk               ((uint32_t)0x00000600)
N#define CAN_STATUS_RX_ERR_CNT8                  ((uint32_t)0x00000800)
N#define CAN_STATUS_TX_ERR_CNT8                  ((uint32_t)0x00001000)
N#define CAN_STATUS_RX_ERR_CNT_Msk               ((uint32_t)0x00FF0000)
N#define CAN_STATUS_TX_ERR_CNT_Msk               ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_STATUS */
N
N/** @defgroup Periph_CAN_BITTMNG	CAN BITTMNG
N  * @{
N  */ 
N
N/*-- CAN_BITTMNG: CAN Bittiming Register ---------------------------*/
N/* Bit field positions: */
N#define CAN_BITTMNG_BRP_Pos                     0
N#define CAN_BITTMNG_PSEG_Pos                    16
N#define CAN_BITTMNG_SEG1_Pos                    19
N#define CAN_BITTMNG_SEG2_Pos                    22
N#define CAN_BITTMNG_SJW_Pos                     25
N#define CAN_BITTMNG_SB_Pos                      27
N
N/* Bit field masks: */
N#define CAN_BITTMNG_BRP_Msk                     ((uint32_t)0x0000FFFF)
N#define CAN_BITTMNG_PSEG_Msk                    ((uint32_t)0x00070000)
N#define CAN_BITTMNG_SEG1_Msk                    ((uint32_t)0x00380000)
N#define CAN_BITTMNG_SEG2_Msk                    ((uint32_t)0x01C00000)
N#define CAN_BITTMNG_SJW_Msk                     ((uint32_t)0x06000000)
N#define CAN_BITTMNG_SB                          ((uint32_t)0x08000000)
N
N/** @} */ /* End of group CAN_BITTMNG */
N
N/** @defgroup Periph_CAN_INT_EN	CAN INT EN
N  * @{
N  */ 
N
N/*-- CAN_INT_EN: CAN Interrupt enable Register ---------------------*/
N/* Bit field positions: */
N#define CAN_INT_EN_GLB_INT_EN_Pos               0
N#define CAN_INT_EN_RX_INT_EN_Pos                1
N#define CAN_INT_EN_TX_INT_EN_Pos                2
N#define CAN_INT_EN_ERR_INT_EN_Pos               3
N#define CAN_INT_EN_ERR_OVER_INT_EN_Pos          4
N
N/* Bit field masks: */
N#define CAN_INT_EN_GLB_INT_EN                   ((uint32_t)0x00000001)
N#define CAN_INT_EN_RX_INT_EN                    ((uint32_t)0x00000002)
N#define CAN_INT_EN_TX_INT_EN                    ((uint32_t)0x00000004)
N#define CAN_INT_EN_ERR_INT_EN                   ((uint32_t)0x00000008)
N#define CAN_INT_EN_ERR_OVER_INT_EN              ((uint32_t)0x00000010)
N
N/** @} */ /* End of group CAN_INT_EN */
N
N/** @defgroup Periph_CAN_RXID	CAN RXID
N  * @{
N  */ 
N
N/*-- CAN_RXID:   CAN Receive ID Register ---------------------------*/
N/*-- CAN_TXID:   CAN Transmit ID Register --------------------------*/
N/*-- CAN_BUF_ID: CAN Buffer ID Register ----------------------------*/
N/* Bit field positions: */
N#define CAN_ID_EID_Pos                          0
N#define CAN_ID_SID_Pos                          18
N
N/* Bit field masks: */
N#define CAN_ID_EID_Msk                          ((uint32_t)0x0003FFFF)
N#define CAN_ID_SID_Msk                          ((uint32_t)0x1FFC0000)
N
N/** @} */ /* End of group CAN_RXID */
N
N/** @defgroup Periph_CAN_RXDLC	CAN RXDLC
N  * @{
N  */ 
N
N/*-- CAN_RXDLC:   CAN Receive DLC Register -------------------------*/
N/*-- CAN_TXDLC:   CAN Transmit DLC Register ------------------------*/
N/*-- CAN_BUF_DLC: CAN Buffer DLC Register --------------------------*/
N/* Bit field positions: */
N#define CAN_DLC_Pos                             0
N#define CAN_DLC_RTR_Pos                         8
N#define CAN_DLC_R1_Pos                          9
N#define CAN_DLC_R0_Pos                          10
N#define CAN_DLC_SSR_Pos                         11
N#define CAN_DLC_IDE_Pos                         12
N
N/* Bit field masks: */
N#define CAN_DLC_Msk                             ((uint32_t)0x0000000F)
N#define CAN_DLC_RTR                             ((uint32_t)0x00000100)
N#define CAN_DLC_R1                              ((uint32_t)0x00000200)
N#define CAN_DLC_R0                              ((uint32_t)0x00000400)
N#define CAN_DLC_SSR                             ((uint32_t)0x00000800)
N#define CAN_DLC_IDE                             ((uint32_t)0x00001000)
N
N/** @} */ /* End of group CAN_RXDLC */
N
N/** @defgroup Periph_CAN_RXDATAL	CAN RXDATAL
N  * @{
N  */ 
N
N/*-- CAN_RXDATAL:   CAN Receive Data low Register ------------------*/
N/*-- CAN_DATAL:     CAN Transmit Data low Register -----------------*/
N/*-- CAN_BUF_DATAL: CAN Buffer Data low Register -------------------*/
N/* Bit field positions: */
N#define CAN_DATAL_DB0_Pos                       0
N#define CAN_DATAL_DB1_Pos                       8
N#define CAN_DATAL_DB2_Pos                       16
N#define CAN_DATAL_DB3_Pos                       24
N
N/* Bit field masks: */
N#define CAN_DATAL_DB0_Msk                       ((uint32_t)0x000000FF)
N#define CAN_DATAL_DB1_Msk                       ((uint32_t)0x0000FF00)
N#define CAN_DATAL_DB2_Msk                       ((uint32_t)0x00FF0000)
N#define CAN_DATAL_DB3_Msk                       ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_RXDATAL */
N
N/** @defgroup Periph_CAN_RXDATAH	CAN RXDATAH
N  * @{
N  */ 
N
N/*-- CAN_RXDATAH:   CAN Receive Data high Register -----------------*/
N/*-- CAN_DATAH:     CAN Transmit Data high Register ----------------*/
N/*-- CAN_BUF_DATAH: CAN Buffer Data high Register ------------------*/
N/* Bit field positions: */
N#define CAN_DATAH_DB4_Pos                       0
N#define CAN_DATAH_DB5_Pos                       8
N#define CAN_DATAH_DB6_Pos                       16
N#define CAN_DATAH_DB7_Pos                       24
N
N/* Bit field masks: */
N#define CAN_DATAH_DB4_Msk                       ((uint32_t)0x000000FF)
N#define CAN_DATAH_DB5_Msk                       ((uint32_t)0x0000FF00)
N#define CAN_DATAH_DB6_Msk                       ((uint32_t)0x00FF0000)
N#define CAN_DATAH_DB7_Msk                       ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_RXDATAH */
N
N/** @defgroup Periph_CAN_BUF_CON	CAN BUF CON
N  * @{
N  */ 
N
N/*-- CAN_BUF_CON: CAN Buffer Connection Register -------------------*/
N/* Bit field positions: */
N#define CAN_BUF_CON_EN_Pos                      0
N#define CAN_BUF_CON_RX_TXN_Pos                  1
N#define CAN_BUF_CON_OVER_EN_Pos                 2
N#define CAN_BUF_CON_RTR_EN_Pos                  3
N#define CAN_BUF_CON_PRIOR_0_Pos                 4
N#define CAN_BUF_CON_TX_REQ_Pos                  5
N#define CAN_BUF_CON_RX_FULL_Pos                 6
N#define CAN_BUF_CON_OVER_WR_Pos                 7
N
N/* Bit field masks: */
N#define CAN_BUF_CON_EN                          ((uint32_t)0x00000001)
N#define CAN_BUF_CON_RX_TXN                      ((uint32_t)0x00000002)
N#define CAN_BUF_CON_OVER_EN                     ((uint32_t)0x00000004)
N#define CAN_BUF_CON_RTR_EN                      ((uint32_t)0x00000008)
N#define CAN_BUF_CON_PRIOR_0                     ((uint32_t)0x00000010)
N#define CAN_BUF_CON_TX_REQ                      ((uint32_t)0x00000020)
N#define CAN_BUF_CON_RX_FULL                     ((uint32_t)0x00000040)
N#define CAN_BUF_CON_OVER_WR                     ((uint32_t)0x00000080)
N
N/** @} */ /* End of group CAN_BUF_CON */
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN */
N
N/** @defgroup MDR32Fx_Periph_USB USB
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_USB_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_USB_SEP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t STS;
X  volatile uint32_t STS;
N  __IO uint32_t TS;
X  volatile uint32_t TS;
N  __IO uint32_t NTS;
X  volatile uint32_t NTS;
N}MDR_USB_SEP_TypeDef;
N
N/* MDR_USB_SEP_FIFO_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t RXFD;
X  volatile uint32_t RXFD;
N       uint32_t RESERVED0;
N  __IO uint32_t RXFDC_L;
X  volatile uint32_t RXFDC_L;
N  __IO uint32_t RXFDC_H;
X  volatile uint32_t RXFDC_H;
N  __IO uint32_t RXFC;
X  volatile uint32_t RXFC;
N       uint32_t RESERVED1[11];
N  __IO uint32_t TXFD;
X  volatile uint32_t TXFD;
N       uint32_t RESERVED2[3];
N  __IO uint32_t TXFDC;
X  volatile uint32_t TXFDC;
N       uint32_t RESERVED3[11];
N}MDR_USB_SEP_FIFO_TypeDef;
N
N/* MDR_USB_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t HTXC;
X  volatile uint32_t HTXC;
N  __IO uint32_t HTXT;
X  volatile uint32_t HTXT;
N  __IO uint32_t HTXLC;
X  volatile uint32_t HTXLC;
N  __IO uint32_t HTXSE;
X  volatile uint32_t HTXSE;
N  __IO uint32_t HTXA;
X  volatile uint32_t HTXA;
N  __IO uint32_t HTXE;
X  volatile uint32_t HTXE;
N  __IO uint32_t HFN_L;
X  volatile uint32_t HFN_L;
N  __IO uint32_t HFN_H;
X  volatile uint32_t HFN_H;
N  __IO uint32_t HIS;
X  volatile uint32_t HIS;
N  __IO uint32_t HIM;
X  volatile uint32_t HIM;
N  __IO uint32_t HRXS;
X  volatile uint32_t HRXS;
N  __IO uint32_t HRXP;
X  volatile uint32_t HRXP;
N  __IO uint32_t HRXA;
X  volatile uint32_t HRXA;
N  __IO uint32_t HRXE;
X  volatile uint32_t HRXE;
N  __IO uint32_t HRXCS;
X  volatile uint32_t HRXCS;
N  __IO uint32_t HSTM;
X  volatile uint32_t HSTM;
N       uint32_t RESERVED0[16];
N  __IO uint32_t HRXFD;
X  volatile uint32_t HRXFD;
N       uint32_t RESERVED1;
N  __IO uint32_t HRXFDC_L;
X  volatile uint32_t HRXFDC_L;
N  __IO uint32_t HRXFDC_H;
X  volatile uint32_t HRXFDC_H;
N  __IO uint32_t HRXFC;
X  volatile uint32_t HRXFC;
N       uint32_t RESERVED2[11];
N  __IO uint32_t HTXFD;
X  volatile uint32_t HTXFD;
N       uint32_t RESERVED3[3];
N  __IO uint32_t HTXFC;
X  volatile uint32_t HTXFC;
N       uint32_t RESERVED4[11];
N    MDR_USB_SEP_TypeDef USB_SEP[4];
N  __IO uint32_t SC;
X  volatile uint32_t SC;
N  __IO uint32_t SLS;
X  volatile uint32_t SLS;
N  __IO uint32_t SIS;
X  volatile uint32_t SIS;
N  __IO uint32_t SIM;
X  volatile uint32_t SIM;
N  __IO uint32_t SA;
X  volatile uint32_t SA;
N  __IO uint32_t SFN_L;
X  volatile uint32_t SFN_L;
N  __IO uint32_t SFN_H;
X  volatile uint32_t SFN_H;
N       uint32_t RESERVED5[9];
N    MDR_USB_SEP_FIFO_TypeDef USB_SEP_FIFO[4];
N  __IO uint32_t HSCR;
X  volatile uint32_t HSCR;
N  __IO uint32_t HSVR;
X  volatile uint32_t HSVR;
N}MDR_USB_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_USB_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_HTXC	USB HTXC
N  * @{
N  */ 
N
N/*-- USB_HTXC: USB HTXC Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HTXC_TREQ_Pos                       0
N#define USB_HTXC_SOFS_Pos                       1
N#define USB_HTXC_PREEN_Pos                      2
N#define USB_HTXC_ISOEN_Pos                      3
N
N/* Bit field masks: */
N#define USB_HTXC_TREQ                           ((uint32_t)0x00000001)
N#define USB_HTXC_SOFS                           ((uint32_t)0x00000002)
N#define USB_HTXC_PREEN                          ((uint32_t)0x00000004)
N#define USB_HTXC_ISOEN                          ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HTXC */
N
N/** @defgroup Periph_USB_HTXLC	USB HTXLC
N  * @{
N  */ 
N
N/*-- USB_HTXLC: USB HTXLC Register ---------------------------------*/
N/* Bit field positions: */
N#define USB_HTXLC_Pos                           0
N#define USB_HTXLC_DC_Pos                        2
N#define USB_HTXLC_FSPL_Pos                      3
N#define USB_HTXLC_FSLR_Pos                      4
N
N/* Bit field masks: */
N#define USB_HTXLC_Msk                           ((uint32_t)0x00000003)
N#define USB_HTXLC_DC                            ((uint32_t)0x00000004)
N#define USB_HTXLC_FSPL                          ((uint32_t)0x00000008)
N#define USB_HTXLC_FSLR                          ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_HTXLC */
N
N/** @defgroup Periph_USB_HIS	USB HIS
N  * @{
N  */ 
N
N/*-- USB_HIS: USB_HIS Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_HIS_TDONE_Pos                       0
N#define USB_HIS_RESUME_Pos                      1
N#define USB_HIS_CONEV_Pos                       2
N#define USB_HIS_SOFS_Pos                        3
N
N/* Bit field masks: */
N#define USB_HIS_TDONE                           ((uint32_t)0x00000001)
N#define USB_HIS_RESUME                          ((uint32_t)0x00000002)
N#define USB_HIS_CONEV                           ((uint32_t)0x00000004)
N#define USB_HIS_SOFS                            ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HIS */
N
N/** @defgroup Periph_USB_HIM	USB HIM
N  * @{
N  */ 
N
N/*-- USB_HIM: USB_HIM Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_HIM_TDONEIE_Pos                     0
N#define USB_HIM_RESUMEIE_Pos                    1
N#define USB_HIM_CONEVIE_Pos                     2
N#define USB_HIM_SOFIE_Pos                       3
N
N/* Bit field masks: */
N#define USB_HIM_TDONEIE                         ((uint32_t)0x00000001)
N#define USB_HIM_RESUMEIE                        ((uint32_t)0x00000002)
N#define USB_HIM_CONEVIE                         ((uint32_t)0x00000004)
N#define USB_HIM_SOFIE                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HIM */
N
N/** @defgroup Periph_USB_HRXS	USB HRXS
N  * @{
N  */ 
N
N/*-- USB_HRXS: USB_HRXS Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HRXS_CRCERR_Pos                     0
N#define USB_HRXS_BSERR_Pos                      1
N#define USB_HRXS_RXOF_Pos                       2
N#define USB_HRXS_RXTO_Pos                       3
N#define USB_HRXS_NAKRXED_Pos                    4
N#define USB_HRXS_STALLRXED_Pos                  5
N#define USB_HRXS_ACKRXED_Pos                    6
N#define USB_HRXS_DATASEQ_Pos                    7
N
N/* Bit field masks: */
N#define USB_HRXS_CRCERR                         ((uint32_t)0x00000001)
N#define USB_HRXS_BSERR                          ((uint32_t)0x00000002)
N#define USB_HRXS_RXOF                           ((uint32_t)0x00000004)
N#define USB_HRXS_RXTO                           ((uint32_t)0x00000008)
N#define USB_HRXS_NAKRXED                        ((uint32_t)0x00000010)
N#define USB_HRXS_STALLRXED                      ((uint32_t)0x00000020)
N#define USB_HRXS_ACKRXED                        ((uint32_t)0x00000040)
N#define USB_HRXS_DATASEQ                        ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_HRXS */
N
N/** @defgroup Periph_USB_SEP_CTRL	USB SEP CTRL
N  * @{
N  */ 
N
N/*-- USB_SEP_CTRL: USB_SEP Control Register ------------------------*/
N/* Bit field positions: */
N#define USB_SEP_CTRL_EPEN_Pos                   0
N#define USB_SEP_CTRL_EPRDY_Pos                  1
N#define USB_SEP_CTRL_EPDATASEQ_Pos              2
N#define USB_SEP_CTRL_EPSSTALL_Pos               3
N#define USB_SEP_CTRL_EPISOEN_Pos                4
N
N/* Bit field masks: */
N#define USB_SEP_CTRL_EPEN                       ((uint32_t)0x00000001)
N#define USB_SEP_CTRL_EPRDY                      ((uint32_t)0x00000002)
N#define USB_SEP_CTRL_EPDATASEQ                  ((uint32_t)0x00000004)
N#define USB_SEP_CTRL_EPSSTALL                   ((uint32_t)0x00000008)
N#define USB_SEP_CTRL_EPISOEN                    ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SEP_CTRL */
N
N/** @defgroup Periph_USB_SEP_STS	USB SEP STS
N  * @{
N  */ 
N
N/*-- USB_SEP_STS: USB_SEP Status Register --------------------------*/
N/* Bit field positions: */
N#define USB_SEP_STS_SCCRCERR_Pos                0
N#define USB_SEP_STS_SCBSERR_Pos                 1
N#define USB_SEP_STS_SCRXOF_Pos                  2
N#define USB_SEP_STS_SCRXTO_Pos                  3
N#define USB_SEP_STS_SCNAKSENT_Pos               4
N#define USB_SEP_STS_SCSTALLSENT_Pos             5
N#define USB_SEP_STS_SCACKRXED_Pos               6
N#define USB_SEP_STS_SCDATASEQ_Pos               7
N
N/* Bit field masks: */
N#define USB_SEP_STS_SCCRCERR                    ((uint32_t)0x00000001)
N#define USB_SEP_STS_SCBSERR                     ((uint32_t)0x00000002)
N#define USB_SEP_STS_SCRXOF                      ((uint32_t)0x00000004)
N#define USB_SEP_STS_SCRXTO                      ((uint32_t)0x00000008)
N#define USB_SEP_STS_SCNAKSENT                   ((uint32_t)0x00000010)
N#define USB_SEP_STS_SCSTALLSENT                 ((uint32_t)0x00000020)
N#define USB_SEP_STS_SCACKRXED                   ((uint32_t)0x00000040)
N#define USB_SEP_STS_SCDATASEQ                   ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_SEP_STS */
N
N/** @defgroup Periph_USB_SC	USB SC
N  * @{
N  */ 
N
N/*-- USB_SC: USB_SC Register ---------------------------------------*/
N/* Bit field positions: */
N#define USB_SCGEN_Pos                           0
N#define USB_SCTXLS_Pos                          1
N#define USB_SCDC_Pos                            3
N#define USB_SCFSP_Pos                           4
N#define USB_SCFSR_Pos                           5
N
N/* Bit field masks: */
N#define USB_SCGEN                               ((uint32_t)0x00000001)
N#define USB_SCTXLS_Msk                          ((uint32_t)0x00000006)
N#define USB_SCDC                                ((uint32_t)0x00000008)
N#define USB_SCFSP                               ((uint32_t)0x00000010)
N#define USB_SCFSR                               ((uint32_t)0x00000020)
N
N/** @} */ /* End of group USB_SC */
N
N/** @defgroup Periph_USB_SIS	USB SIS
N  * @{
N  */ 
N
N/*-- USB_SIS: USB_SIS Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_SIS_SCTDONE_Pos                     0
N#define USB_SIS_SCRESUME_Pos                    1
N#define USB_SIS_SCRESETEV_Pos                   2
N#define USB_SIS_SCSOFREC_Pos                    3
N#define USB_SIS_SCNAKSENT_Pos                   4
N
N/* Bit field masks: */
N#define USB_SIS_SCTDONE                         ((uint32_t)0x00000001)
N#define USB_SIS_SCRESUME                        ((uint32_t)0x00000002)
N#define USB_SIS_SCRESETEV                       ((uint32_t)0x00000004)
N#define USB_SIS_SCSOFREC                        ((uint32_t)0x00000008)
N#define USB_SIS_SCNAKSENT                       ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SIS */
N
N/** @defgroup Periph_USB_SIM	USB SIM
N  * @{
N  */ 
N
N/*-- USB_SIM: USB_SIM Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_SIM_SCTDONEIE_Pos                   0
N#define USB_SIM_SCRESUMEIE_Pos                  1
N#define USB_SIM_SCRESETEVIE_Pos                 2
N#define USB_SIM_SCSOFRECIE_Pos                  3
N#define USB_SIM_SCNAKSENTIE_Pos                 4
N
N/* Bit field masks: */
N#define USB_SIM_SCTDONEIE                       ((uint32_t)0x00000001)
N#define USB_SIM_SCRESUMEIE                      ((uint32_t)0x00000002)
N#define USB_SIM_SCRESETEVIE                     ((uint32_t)0x00000004)
N#define USB_SIM_SCSOFRECIE                      ((uint32_t)0x00000008)
N#define USB_SIM_SCNAKSENTIE                     ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SIM */
N
N/** @defgroup Periph_USB_HSCR	USB HSCR
N  * @{
N  */ 
N
N/*-- USB_HSCR: USB_HSCR Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HSCR_HOST_MODE_Pos                  0
N#define USB_HSCR_RESET_CORE_Pos                 1
N#define USB_HSCR_EN_TX_Pos                      2
N#define USB_HSCR_EN_RX_Pos                      3
N#define USB_HSCR_DP_PULLUP_Pos                  4
N#define USB_HSCR_DP_PULLDOWN_Pos                5
N#define USB_HSCR_DM_PULLUP_Pos                  6
N#define USB_HSCR_DM_PULLDOWN_Pos                7
N
N/* Bit field masks: */
N#define USB_HSCR_HOST_MODE                      ((uint32_t)0x00000001)
N#define USB_HSCR_RESET_CORE                     ((uint32_t)0x00000002)
N#define USB_HSCR_EN_TX                          ((uint32_t)0x00000004)
N#define USB_HSCR_EN_RX                          ((uint32_t)0x00000008)
N#define USB_HSCR_DP_PULLUP                      ((uint32_t)0x00000010)
N#define USB_HSCR_DP_PULLDOWN                    ((uint32_t)0x00000020)
N#define USB_HSCR_DM_PULLUP                      ((uint32_t)0x00000040)
N#define USB_HSCR_DM_PULLDOWN                    ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_HSCR */
N
N/** @defgroup Periph_USB_HSVR	USB HSVR
N  * @{
N  */ 
N
N/*-- USB_HSVR: USB_HSVR Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HSVR_VERSION_Pos                    0
N#define USB_HSVR_REVISION_Pos                   4
N
N/* Bit field masks: */
N#define USB_HSVR_VERSION_Msk                    ((uint32_t)0x0000000F)
N#define USB_HSVR_REVISION_Msk                   ((uint32_t)0x000000F0)
N
N/** @} */ /* End of group USB_HSVR */
N
N/** @} */ /* End of group MDR32Fx_Periph_USB_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_USB */
N
N/** @defgroup MDR32Fx_Periph_EEPROM EEPROM
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_EEPROM_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_EEPROM_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CMD;
X  volatile uint32_t CMD;
N  __IO uint32_t ADR;
X  volatile uint32_t ADR;
N  __IO uint32_t DI;
X  volatile uint32_t DI;
N  __IO uint32_t DO;
X  volatile uint32_t DO;
N  __IO uint32_t KEY;
X  volatile uint32_t KEY;
N}MDR_EEPROM_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_EEPROM_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EEPROM_CMD	EEPROM CMD
N  * @{
N  */ 
N
N/*-- EEPROM_CMD: EEPROM Command Register ---------------------------*/
N/* Bit field positions: */
N#define EEPROM_CMD_CON_Pos                      0
N#define EEPROM_CMD_WR_Pos                       1
N#define EEPROM_CMD_RD_Pos                       2
N#define EEPROM_CMD_DELAY_Pos                    3
N#define EEPROM_CMD_XE_Pos                       6
N#define EEPROM_CMD_YE_Pos                       7
N#define EEPROM_CMD_SE_Pos                       8
N#define EEPROM_CMD_IFREN_Pos                    9
N#define EEPROM_CMD_ERASE_Pos                    10
N#define EEPROM_CMD_MAS1_Pos                     11
N#define EEPROM_CMD_PROG_Pos                     12
N#define EEPROM_CMD_NVSTR_Pos                    13
N
N/* Bit field masks: */
N#define EEPROM_CMD_CON                          ((uint32_t)0x00000001)
N#define EEPROM_CMD_WR                           ((uint32_t)0x00000002)
N#define EEPROM_CMD_RD                           ((uint32_t)0x00000004)
N#define EEPROM_CMD_DELAY_Msk                    ((uint32_t)0x00000038)
N#define EEPROM_CMD_XE                           ((uint32_t)0x00000040)
N#define EEPROM_CMD_YE                           ((uint32_t)0x00000080)
N#define EEPROM_CMD_SE                           ((uint32_t)0x00000100)
N#define EEPROM_CMD_IFREN                        ((uint32_t)0x00000200)
N#define EEPROM_CMD_ERASE                        ((uint32_t)0x00000400)
N#define EEPROM_CMD_MAS1                         ((uint32_t)0x00000800)
N#define EEPROM_CMD_PROG                         ((uint32_t)0x00001000)
N#define EEPROM_CMD_NVSTR                        ((uint32_t)0x00002000)
N
N/** @} */ /* End of group EEPROM_CMD */
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK RST_CLK
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_RST_CLK_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CLOCK_STATUS;
X  volatile uint32_t CLOCK_STATUS;
N  __IO uint32_t PLL_CONTROL;
X  volatile uint32_t PLL_CONTROL;
N  __IO uint32_t HS_CONTROL;
X  volatile uint32_t HS_CONTROL;
N  __IO uint32_t CPU_CLOCK;
X  volatile uint32_t CPU_CLOCK;
N  __IO uint32_t USB_CLOCK;
X  volatile uint32_t USB_CLOCK;
N  __IO uint32_t ADC_MCO_CLOCK;
X  volatile uint32_t ADC_MCO_CLOCK;
N  __IO uint32_t RTC_CLOCK;
X  volatile uint32_t RTC_CLOCK;
N  __IO uint32_t PER_CLOCK;
X  volatile uint32_t PER_CLOCK;
N  __IO uint32_t CAN_CLOCK;
X  volatile uint32_t CAN_CLOCK;
N  __IO uint32_t TIM_CLOCK;
X  volatile uint32_t TIM_CLOCK;
N  __IO uint32_t UART_CLOCK;
X  volatile uint32_t UART_CLOCK;
N  __IO uint32_t SSP_CLOCK;
X  volatile uint32_t SSP_CLOCK;
N}MDR_RST_CLK_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_CLOCK_STATUS	RST CLK CLOCK STATUS
N  * @{
N  */ 
N
N/*-- RST_CLK_CLOCK_STATUS: Clock Status Register -------------------*/
N/* Bit field positions: */
N#define RST_CLK_CLOCK_STATUS_PLL_USB_RDY_Pos    0
N#define RST_CLK_CLOCK_STATUS_PLL_CPU_RDY_Pos    1
N#define RST_CLK_CLOCK_STATUS_HSE_RDY_Pos        2
N
N/* Bit field masks: */
N#define RST_CLK_CLOCK_STATUS_PLL_USB_RDY        ((uint32_t)0x00000001)
N#define RST_CLK_CLOCK_STATUS_PLL_CPU_RDY        ((uint32_t)0x00000002)
N#define RST_CLK_CLOCK_STATUS_HSE_RDY            ((uint32_t)0x00000004)
N
N/** @} */ /* End of group RST_CLK_CLOCK_STATUS */
N
N/** @defgroup Periph_RST_CLK_PLL_CONTROL	RST CLK PLL CONTROL
N  * @{
N  */ 
N
N/*-- RST_CLK_PLL_CONTROL: PLL Control Register ---------------------*/
N/* Bit field positions: */
N#define RST_CLK_PLL_CONTROL_PLL_USB_ON_Pos      0
N#define RST_CLK_PLL_CONTROL_PLL_USB_RLD_Pos     1
N#define RST_CLK_PLL_CONTROL_PLL_CPU_ON_Pos      2
N#define RST_CLK_PLL_CONTROL_PLL_CPU_PLD_Pos     3
N#define RST_CLK_PLL_CONTROL_PLL_USB_MUL_Pos     4
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos     8
N
N/* Bit field masks: */
N#define RST_CLK_PLL_CONTROL_PLL_USB_ON          ((uint32_t)0x00000001)
N#define RST_CLK_PLL_CONTROL_PLL_USB_RLD         ((uint32_t)0x00000002)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_ON          ((uint32_t)0x00000004)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_PLD         ((uint32_t)0x00000008)
N#define RST_CLK_PLL_CONTROL_PLL_USB_MUL_Msk     ((uint32_t)0x000000F0)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Msk     ((uint32_t)0x00000F00)
N
N/** @} */ /* End of group RST_CLK_PLL_CONTROL */
N
N/** @defgroup Periph_RST_CLK_HS_CONTROL	RST CLK HS CONTROL
N  * @{
N  */ 
N
N/*-- RST_CLK_HS_CONTROL: HS Control Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_HS_CONTROL_HSE_ON_Pos           0
N#define RST_CLK_HS_CONTROL_HSE_BYP_Pos          1
N
N/* Bit field masks: */
N#define RST_CLK_HS_CONTROL_HSE_ON               ((uint32_t)0x00000001)
N#define RST_CLK_HS_CONTROL_HSE_BYP              ((uint32_t)0x00000002)
N
N/** @} */ /* End of group RST_CLK_HS_CONTROL */
N
N/** @defgroup Periph_RST_CLK_CPU_CLOCK	RST CLK CPU CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_CPU_CLOCK: CPU Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos        0
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos        2
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos        4
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_Pos          8
N
N/* Bit field masks: */
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_Msk        ((uint32_t)0x00000003)
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL            ((uint32_t)0x00000004)
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_Msk        ((uint32_t)0x000000F0)
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_Msk          ((uint32_t)0x00000300)
N
N/** @} */ /* End of group RST_CLK_CPU_CLOCK */
N
N/** @defgroup Periph_RST_CLK_USB_CLOCK	RST CLK USB CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_USB_CLOCK: USB Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_Pos        0
N#define RST_CLK_USB_CLOCK_USB_C2_SEL_Pos        2
N#define RST_CLK_USB_CLOCK_USB_C3_SEL_Pos        4
N#define RST_CLK_USB_CLOCK_USB_CLK_EN_Pos        8
N
N/* Bit field masks: */
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_Msk        ((uint32_t)0x00000003)
N#define RST_CLK_USB_CLOCK_USB_C2_SEL            ((uint32_t)0x00000004)
N#define RST_CLK_USB_CLOCK_USB_C3_SEL	        ((uint32_t)0x00000010)
N#define RST_CLK_USB_CLOCK_USB_CLK_EN            ((uint32_t)0x00000100)
N
N/** @} */ /* End of group RST_CLK_USB_CLOCK */
N
N/** @defgroup Periph_RST_CLK_ADC_MCO_CLOCK	RST CLK ADC MCO CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_ADC_MCO_CLOCK: ADC Clock Register ---------------------*/
N/* Bit field positions: */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Pos    0
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Pos    4
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Pos    8
N#define RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN_Pos    13
N
N/* Bit field masks: */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Msk    ((uint32_t)0x00000003)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Msk    ((uint32_t)0x00000030)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Msk    ((uint32_t)0x00000F00)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN        ((uint32_t)0x00002000)
N
N/** @} */ /* End of group RST_CLK_ADC_MCO_CLOCK */
N
N/** @defgroup Periph_RST_CLK_RTC_CLOCK	RST CLK RTC CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_RTC_CLOCK: RTC Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_RTC_CLOCK_HSE_SEL_Pos           0
N#define RST_CLK_RTC_CLOCK_HSI_SEL_Pos           4
N#define RST_CLK_RTC_CLOCK_HSE_RTC_EN_Pos        8
N#define RST_CLK_RTC_CLOCK_HSI_RTC_EN_Pos        9
N
N/* Bit field masks: */
N#define RST_CLK_RTC_CLOCK_HSE_SEL_Msk           ((uint32_t)0x0000000F)
N#define RST_CLK_RTC_CLOCK_HSI_SEL_Msk           ((uint32_t)0x000000F0)
N#define RST_CLK_RTC_CLOCK_HSE_RTC_EN            ((uint32_t)0x00000100)
N#define RST_CLK_RTC_CLOCK_HSI_RTC_EN            ((uint32_t)0x00000200)
N
N/** @} */ /* End of group RST_CLK_RTC_CLOCK */
N
N/** @defgroup Periph_RST_CLK_CAN_CLOCK	RST CLK CAN CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_CAN_CLOCK: CAN Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_CAN_CLOCK_CAN1_BRG_Pos          0
N#define RST_CLK_CAN_CLOCK_CAN2_BRG_Pos          8
N#define RST_CLK_CAN_CLOCK_CAN1_CLK_EN_Pos       24
N#define RST_CLK_CAN_CLOCK_CAN2_CLK_EN_Pos       25
N
N/* Bit field masks: */
N#define RST_CLK_CAN_CLOCK_CAN1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_CAN_CLOCK_CAN2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_CAN_CLOCK_CAN1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_CAN_CLOCK_CAN2_CLK_EN           ((uint32_t)0x02000000)
N
N/** @} */ /* End of group RST_CLK_CAN_CLOCK */
N
N/** @defgroup Periph_RST_CLK_TIM_CLOCK	RST CLK TIM CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_TIM_CLOCK: Timer Clock Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_TIM_CLOCK_TIM1_BRG_Pos          0
N#define RST_CLK_TIM_CLOCK_TIM2_BRG_Pos          8
N#define RST_CLK_TIM_CLOCK_TIM3_BRG_Pos          16
N#define RST_CLK_TIM_CLOCK_TIM1_CLK_EN_Pos       24
N#define RST_CLK_TIM_CLOCK_TIM2_CLK_EN_Pos       25
N#define RST_CLK_TIM_CLOCK_TIM3_CLK_EN_Pos       26
N
N/* Bit field masks: */
N#define RST_CLK_TIM_CLOCK_TIM1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_TIM_CLOCK_TIM2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_TIM_CLOCK_TIM3_BRG_Msk          ((uint32_t)0x00FF0000)
N#define RST_CLK_TIM_CLOCK_TIM1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_TIM_CLOCK_TIM2_CLK_EN           ((uint32_t)0x02000000)
N#define RST_CLK_TIM_CLOCK_TIM3_CLK_EN           ((uint32_t)0x04000000)
N
N/** @} */ /* End of group RST_CLK_TIM_CLOCK */
N
N/** @defgroup Periph_RST_CLK_UART_CLOCK	RST CLK UART CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_UART_CLOCK: UART Clock Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_UART_CLOCK_UART1_BRG_Pos        0
N#define RST_CLK_UART_CLOCK_UART2_BRG_Pos        8
N#define RST_CLK_UART_CLOCK_UART1_CLK_EN_Pos     24
N#define RST_CLK_UART_CLOCK_UART2_CLK_EN_Pos     25
N
N/* Bit field masks: */
N#define RST_CLK_UART_CLOCK_UART1_BRG_Msk        ((uint32_t)0x000000FF)
N#define RST_CLK_UART_CLOCK_UART2_BRG_Msk        ((uint32_t)0x0000FF00)
N#define RST_CLK_UART_CLOCK_UART1_CLK_EN         ((uint32_t)0x01000000)
N#define RST_CLK_UART_CLOCK_UART2_CLK_EN         ((uint32_t)0x02000000)
N
N/** @} */ /* End of group RST_CLK_UART_CLOCK */
N
N/** @defgroup Periph_RST_CLK_SSP_CLOCK	RST CLK SSP CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_SSP_CLOCK: SSP Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_SSP_CLOCK_SSP1_BRG_Pos          0
N#define RST_CLK_SSP_CLOCK_SSP2_BRG_Pos          8
N#define RST_CLK_SSP_CLOCK_SSP1_CLK_EN_Pos       24
N#define RST_CLK_SSP_CLOCK_SSP2_CLK_EN_Pos       25
N
N/* Bit field masks: */
N#define RST_CLK_SSP_CLOCK_SSP1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_SSP_CLOCK_SSP2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_SSP_CLOCK_SSP1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_SSP_CLOCK_SSP2_CLK_EN           ((uint32_t)0x02000000)
N
N/** @} */ /* End of group RST_CLK_SSP_CLOCK */
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK */
N
N/** @defgroup MDR32Fx_Periph_DMA DMA
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_DMA_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_DMA_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t CTRL_BASE_PTR;
X  volatile uint32_t CTRL_BASE_PTR;
N  __IO uint32_t ALT_CTRL_BASE_PTR;
X  volatile uint32_t ALT_CTRL_BASE_PTR;
N  __IO uint32_t WAITONREQ_STATUS;
X  volatile uint32_t WAITONREQ_STATUS;
N  __IO uint32_t CHNL_SW_REQUEST;
X  volatile uint32_t CHNL_SW_REQUEST;
N  __IO uint32_t CHNL_USEBURST_SET;
X  volatile uint32_t CHNL_USEBURST_SET;
N  __IO uint32_t CHNL_USEBURST_CLR;
X  volatile uint32_t CHNL_USEBURST_CLR;
N  __IO uint32_t CHNL_REQ_MASK_SET;
X  volatile uint32_t CHNL_REQ_MASK_SET;
N  __IO uint32_t CHNL_REQ_MASK_CLR;
X  volatile uint32_t CHNL_REQ_MASK_CLR;
N  __IO uint32_t CHNL_ENABLE_SET;
X  volatile uint32_t CHNL_ENABLE_SET;
N  __IO uint32_t CHNL_ENABLE_CLR;
X  volatile uint32_t CHNL_ENABLE_CLR;
N  __IO uint32_t CHNL_PRI_ALT_SET;
X  volatile uint32_t CHNL_PRI_ALT_SET;
N  __IO uint32_t CHNL_PRI_ALT_CLR;
X  volatile uint32_t CHNL_PRI_ALT_CLR;
N  __IO uint32_t CHNL_PRIORITY_SET;
X  volatile uint32_t CHNL_PRIORITY_SET;
N  __IO uint32_t CHNL_PRIORITY_CLR;
X  volatile uint32_t CHNL_PRIORITY_CLR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t ERR_CLR;
X  volatile uint32_t ERR_CLR;
N}MDR_DMA_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_DMA_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DMA_STATUS	DMA STATUS
N  * @{
N  */ 
N
N/*-- DMA_STATUS: DMA Status Register -------------------------------*/
N/* Bit field positions: */
N#define DMA_STATUS_MASTER_ENABLE_Pos            0
N#define DMA_STATUS_STATE_Pos                    4
N#define DMA_STATUS_CHNLS_MINUS1_Pos             16
N#define DMA_STATUS_TEST_STATUS_Pos              28
N
N/* Bit field masks: */
N#define DMA_STATUS_MASTER_ENABLE                ((uint32_t)0x00000001)
N#define DMA_STATUS_STATE_Msk                    ((uint32_t)0x000000F0)
N#define DMA_STATUS_CHNLS_MINUS1_Msk             ((uint32_t)0x001F0000)
N#define DMA_STATUS_TEST_STATUS_Msk              ((uint32_t)0xF0000000)
N
N/** @} */ /* End of group DMA_STATUS */
N
N/** @defgroup Periph_DMA_CFG	DMA CFG
N  * @{
N  */ 
N
N/*-- DMA_CFG: DMA Configuration Register ---------------------------*/
N/* Bit field positions: */
N#define DMA_CFG_MASTER_ENABLE_Pos               0
N#define DMA_CFG_CHNL_PROT_CTRL_Pos              5
N
N/* Bit field masks: */
N#define DMA_CFG_MASTER_ENABLE                   ((uint32_t)0x00000001)
N#define DMA_CFG_CHNL_PROT_CTRL_Msk              ((uint32_t)0x000000E0)
N
N/** @} */ /* End of group DMA_CFG */
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA */
N
N/** @defgroup MDR32Fx_Periph_UART UART
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_UART_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_UART_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __IO uint32_t RSR_ECR;
X  volatile uint32_t RSR_ECR;
N       uint32_t RESERVED0[4];
N  __IO uint32_t FR;
X  volatile uint32_t FR;
N       uint32_t RESERVED1;
N  __IO uint32_t ILPR;
X  volatile uint32_t ILPR;
N  __IO uint32_t IBRD;
X  volatile uint32_t IBRD;
N  __IO uint32_t FBRD;
X  volatile uint32_t FBRD;
N  __IO uint32_t LCR_H;
X  volatile uint32_t LCR_H;
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t IFLS;
X  volatile uint32_t IFLS;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N}MDR_UART_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_UART_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_DR	UART DR
N  * @{
N  */ 
N
N/*-- UART_DR: UART Data Register -----------------------------------*/
N/* Bit field positions: */
N#define UART_DR_DATA_Pos                        0
N#define UART_DR_FE_Pos                          8
N#define UART_DR_PE_Pos                          9
N#define UART_DR_BE_Pos                          10
N#define UART_DR_OE_Pos                          11
N
N/* Bit field masks: */
N#define UART_DR_DATA_Msk                        ((uint32_t)0x000000FF)
N#define UART_DR_FE                              ((uint32_t)0x00000100)
N#define UART_DR_PE                              ((uint32_t)0x00000200)
N#define UART_DR_BE                              ((uint32_t)0x00000400)
N#define UART_DR_OE                              ((uint32_t)0x00000800)
N
N/** @} */ /* End of group UART_DR */
N
N/** @defgroup Periph_UART_RSR_ECR	UART RSR ECR
N  * @{
N  */ 
N
N/*-- UART_RSR_ECR: UART RSR Register -------------------------------*/
N/* Bit field positions: */
N#define UART_RSR_ECR_FE_Pos                     0
N#define UART_RSR_ECR_PE_Pos                     1
N#define UART_RSR_ECR_BE_Pos                     2
N#define UART_RSR_ECR_OE_Pos                     3
N
N/* Bit field masks: */
N#define UART_RSR_ECR_FE                         ((uint32_t)0x00000001)
N#define UART_RSR_ECR_PE                         ((uint32_t)0x00000002)
N#define UART_RSR_ECR_BE                         ((uint32_t)0x00000004)
N#define UART_RSR_ECR_OE                         ((uint32_t)0x00000008)
N
N/** @} */ /* End of group UART_RSR_ECR */
N
N/** @defgroup Periph_UART_FR	UART FR
N  * @{
N  */ 
N
N/*-- UART_FR: UART Flag Register -----------------------------------*/
N/* Bit field positions: */
N#define UART_FR_CTS_Pos                         0
N#define UART_FR_DSR_Pos                         1
N#define UART_FR_DCD_Pos                         2
N#define UART_FR_BUSY_Pos                        3
N#define UART_FR_RXFE_Pos                        4
N#define UART_FR_TXFF_Pos                        5
N#define UART_FR_RXFF_Pos                        6
N#define UART_FR_TXFE_Pos                        7
N#define UART_FR_RI_Pos                          8
N
N/* Bit field masks: */
N#define UART_FR_CTS                             ((uint32_t)0x00000001)
N#define UART_FR_DSR                             ((uint32_t)0x00000002)
N#define UART_FR_DCD                             ((uint32_t)0x00000004)
N#define UART_FR_BUSY                            ((uint32_t)0x00000008)
N#define UART_FR_RXFE                            ((uint32_t)0x00000010)
N#define UART_FR_TXFF                            ((uint32_t)0x00000020)
N#define UART_FR_RXFF                            ((uint32_t)0x00000040)
N#define UART_FR_TXFE                            ((uint32_t)0x00000080)
N#define UART_FR_RI                              ((uint32_t)0x00000100)
N
N/** @} */ /* End of group UART_FR */
N
N/** @defgroup Periph_UART_LCR_H	UART LCR H
N  * @{
N  */ 
N
N/*-- UART_LCR_H: UART LCR_H Register -------------------------------*/
N/* Bit field positions: */
N#define UART_LCR_H_BRK_Pos                      0
N#define UART_LCR_H_PEN_Pos                      1
N#define UART_LCR_H_EPS_Pos                      2
N#define UART_LCR_H_STP2_Pos                     3
N#define UART_LCR_H_FEN_Pos                      4
N#define UART_LCR_H_WLEN_Pos                     5
N#define UART_LCR_H_SPS_Pos                      7
N
N/* Bit field masks: */
N#define UART_LCR_H_BRK                          ((uint32_t)0x00000001)
N#define UART_LCR_H_PEN                          ((uint32_t)0x00000002)
N#define UART_LCR_H_EPS                          ((uint32_t)0x00000004)
N#define UART_LCR_H_STP2                         ((uint32_t)0x00000008)
N#define UART_LCR_H_FEN                          ((uint32_t)0x00000010)
N#define UART_LCR_H_WLEN_Msk                     ((uint32_t)0x00000060)
N#define UART_LCR_H_SPS                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group UART_LCR_H */
N
N/** @defgroup Periph_UART_CR	UART CR
N  * @{
N  */ 
N
N/*-- UART_CR: UART Command Register --------------------------------*/
N/* Bit field positions: */
N#define UART_CR_UARTEN_Pos                      0
N#define UART_CR_SIREN_Pos                       1
N#define UART_CR_SIRLP_Pos                       2
N#define UART_CR_LBE_Pos                         7
N#define UART_CR_TXE_Pos                         8
N#define UART_CR_RXE_Pos                         9
N#define UART_CR_DTR_Pos                         10
N#define UART_CR_RTS_Pos                         11
N#define UART_CR_OUT1_Pos                        12
N#define UART_CR_OUT2_Pos                        13
N#define UART_CR_RTSEN_Pos                       14
N#define UART_CR_CTSEN_Pos                       15
N
N/* Bit field masks: */
N#define UART_CR_UARTEN                          ((uint32_t)0x00000001)
N#define UART_CR_SIREN                           ((uint32_t)0x00000002)
N#define UART_CR_SIRLP                           ((uint32_t)0x00000004)
N#define UART_CR_LBE                             ((uint32_t)0x00000080)
N#define UART_CR_TXE                             ((uint32_t)0x00000100)
N#define UART_CR_RXE                             ((uint32_t)0x00000200)
N#define UART_CR_DTR                             ((uint32_t)0x00000400)
N#define UART_CR_RTS                             ((uint32_t)0x00000800)
N#define UART_CR_OUT1                            ((uint32_t)0x00001000)
N#define UART_CR_OUT2                            ((uint32_t)0x00002000)
N#define UART_CR_RTSEN                           ((uint32_t)0x00004000)
N#define UART_CR_CTSEN                           ((uint32_t)0x00008000)
N
N/** @} */ /* End of group UART_CR */
N
N/** @defgroup Periph_UART_IFLS	UART IFLS
N  * @{
N  */ 
N
N/*-- UART_IFLS: UART IFLS Register ---------------------------------*/
N/* Bit field positions: */
N#define UART_IFLS_TXIFLSEL_Pos                  0
N#define UART_IFLS_RXIFLSEL_Pos                  3
N
N/* Bit field masks: */
N#define UART_IFLS_TXIFLSEL_Msk                  ((uint32_t)0x00000007)
N#define UART_IFLS_RXIFLSEL_Msk                  ((uint32_t)0x00000038)
N
N/** @} */ /* End of group UART_IFLS */
N
N/** @defgroup Periph_UART_IMSC	UART IMSC
N  * @{
N  */ 
N
N/*-- UART_IMSC: UART Interrupt Mask Register -----------------------*/
N/* Bit field positions: */
N#define UART_IMSC_RIMIM_Pos                     0
N#define UART_IMSC_CTSMIM_Pos                    1
N#define UART_IMSC_DCDMIM_Pos                    2
N#define UART_IMSC_DSRMIM_Pos                    3
N#define UART_IMSC_RXIM_Pos                      4
N#define UART_IMSC_TXIM_Pos                      5
N#define UART_IMSC_RTIM_Pos                      6
N#define UART_IMSC_FEIM_Pos                      7
N#define UART_IMSC_PEIM_Pos                      8
N#define UART_IMSC_BEIM_Pos                      9
N#define UART_IMSC_OEIM_Pos                      10
N
N/* Bit field masks: */
N#define UART_IMSC_RIMIM                         ((uint32_t)0x00000001)
N#define UART_IMSC_CTSMIM                        ((uint32_t)0x00000002)
N#define UART_IMSC_DCDMIM                        ((uint32_t)0x00000004)
N#define UART_IMSC_DSRMIM                        ((uint32_t)0x00000008)
N#define UART_IMSC_RXIM                          ((uint32_t)0x00000010)
N#define UART_IMSC_TXIM                          ((uint32_t)0x00000020)
N#define UART_IMSC_RTIM                          ((uint32_t)0x00000040)
N#define UART_IMSC_FEIM                          ((uint32_t)0x00000080)
N#define UART_IMSC_PEIM                          ((uint32_t)0x00000100)
N#define UART_IMSC_BEIM                          ((uint32_t)0x00000200)
N#define UART_IMSC_OEIM                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_IMSC */
N
N/** @defgroup Periph_UART_RIS	UART RIS
N  * @{
N  */ 
N
N/*-- UART_RIS: UART Interrupt Pending Register ---------------------*/
N/* Bit field positions: */
N#define UART_RIS_RIRMIS_Pos                     0
N#define UART_RIS_CTSRMIS_Pos                    1
N#define UART_RIS_DCDRMIS_Pos                    2
N#define UART_RIS_DSRRMIS_Pos                    3
N#define UART_RIS_RXRIS_Pos                      4
N#define UART_RIS_TXRIS_Pos                      5
N#define UART_RIS_RTRIS_Pos                      6
N#define UART_RIS_FERIS_Pos                      7
N#define UART_RIS_PERIS_Pos                      8
N#define UART_RIS_BERIS_Pos                      9
N#define UART_RIS_OERIS_Pos                      10
N
N/* Bit field masks: */
N#define UART_RIS_RIRMIS                         ((uint32_t)0x00000001)
N#define UART_RIS_CTSRMIS                        ((uint32_t)0x00000002)
N#define UART_RIS_DCDRMIS                        ((uint32_t)0x00000004)
N#define UART_RIS_DSRRMIS                        ((uint32_t)0x00000008)
N#define UART_RIS_RXRIS                          ((uint32_t)0x00000010)
N#define UART_RIS_TXRIS                          ((uint32_t)0x00000020)
N#define UART_RIS_RTRIS                          ((uint32_t)0x00000040)
N#define UART_RIS_FERIS                          ((uint32_t)0x00000080)
N#define UART_RIS_PERIS                          ((uint32_t)0x00000100)
N#define UART_RIS_BERIS                          ((uint32_t)0x00000200)
N#define UART_RIS_OERIS                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_RIS */
N
N/** @defgroup Periph_UART_MIS	UART MIS
N  * @{
N  */ 
N
N/*-- UART_MIS: UART Masked Interrupt Pending Register --------------*/
N/* Bit field positions: */
N#define UART_MIS_RIMMIS_Pos                     0
N#define UART_MIS_CTSMMIS_Pos                    1
N#define UART_MIS_DCDMMIS_Pos                    2
N#define UART_MIS_DSRMMIS_Pos                    3
N#define UART_MIS_RXMIS_Pos                      4
N#define UART_MIS_TXMIS_Pos                      5
N#define UART_MIS_RTMIS_Pos                      6
N#define UART_MIS_FEMIS_Pos                      7
N#define UART_MIS_PEMIS_Pos                      8
N#define UART_MIS_BEMIS_Pos                      9
N#define UART_MIS_OEMIS_Pos                      10
N
N/* Bit field masks: */
N#define UART_MIS_RIMMIS                         ((uint32_t)0x00000001)
N#define UART_MIS_CTSMMIS                        ((uint32_t)0x00000002)
N#define UART_MIS_DCDMMIS                        ((uint32_t)0x00000004)
N#define UART_MIS_DSRMMIS                        ((uint32_t)0x00000008)
N#define UART_MIS_RXMIS                          ((uint32_t)0x00000010)
N#define UART_MIS_TXMIS                          ((uint32_t)0x00000020)
N#define UART_MIS_RTMIS                          ((uint32_t)0x00000040)
N#define UART_MIS_FEMIS                          ((uint32_t)0x00000080)
N#define UART_MIS_PEMIS                          ((uint32_t)0x00000100)
N#define UART_MIS_BEMIS                          ((uint32_t)0x00000200)
N#define UART_MIS_OEMIS                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_MIS */
N
N/** @defgroup Periph_UART_ICR	UART ICR
N  * @{
N  */ 
N
N/*-- UART_ICR: UART Interrupt Clear Register -----------------------*/
N/* Bit field positions: */
N#define UART_ICR_RIMIC_Pos                      0
N#define UART_ICR_CTSMIC_Pos                     1
N#define UART_ICR_DCDMIC_Pos                     2
N#define UART_ICR_DSRMIC_Pos                     3
N#define UART_ICR_RXIC_Pos                       4
N#define UART_ICR_TXIC_Pos                       5
N#define UART_ICR_RTIC_Pos                       6
N#define UART_ICR_FEIC_Pos                       7
N#define UART_ICR_PEIC_Pos                       8
N#define UART_ICR_BEIC_Pos                       9
N#define UART_ICR_OEIC_Pos                       10
N
N/* Bit field masks: */
N#define UART_ICR_RIMIC                          ((uint32_t)0x00000001)
N#define UART_ICR_CTSMIC                         ((uint32_t)0x00000002)
N#define UART_ICR_DCDMIC                         ((uint32_t)0x00000004)
N#define UART_ICR_DSRMIC                         ((uint32_t)0x00000008)
N#define UART_ICR_RXIC                           ((uint32_t)0x00000010)
N#define UART_ICR_TXIC                           ((uint32_t)0x00000020)
N#define UART_ICR_RTIC                           ((uint32_t)0x00000040)
N#define UART_ICR_FEIC                           ((uint32_t)0x00000080)
N#define UART_ICR_PEIC                           ((uint32_t)0x00000100)
N#define UART_ICR_BEIC                           ((uint32_t)0x00000200)
N#define UART_ICR_OEIC                           ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_ICR */
N
N/** @defgroup Periph_UART_DMACR	UART DMACR
N  * @{
N  */ 
N
N/*-- UART_DMACR: UART DMA Control Register -------------------------*/
N/* Bit field positions: */
N#define UART_DMACR_RXDMAE_Pos                   0
N#define UART_DMACR_TXDMAE_Pos                   1
N#define UART_DMACR_DMAONERR_Pos                 2
N
N/* Bit field masks: */
N#define UART_DMACR_RXDMAE                       ((uint32_t)0x00000001)
N#define UART_DMACR_TXDMAE                       ((uint32_t)0x00000002)
N#define UART_DMACR_DMAONERR                     ((uint32_t)0x00000004)
N
N/** @} */ /* End of group UART_DMACR */
N
N/** @} */ /* End of group MDR32Fx_Periph_UART_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_UART */
N
N/** @defgroup MDR32Fx_Periph_SSP SSP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_SSP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_SSP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CR0;
X  volatile uint32_t CR0;
N  __IO uint32_t CR1;
X  volatile uint32_t CR1;
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N  __IO uint32_t CPSR;
X  volatile uint32_t CPSR;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N}MDR_SSP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_SSP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SSP_CR0	SSP CR0
N  * @{
N  */ 
N
N/*-- SSP_CR0: SSP Control0 Register --------------------------------*/
N/* Bit field positions: */
N#define SSP_CR0_DSS_Pos                         0
N#define SSP_CR0_FRF_Pos                         4
N#define SSP_CR0_SPO_Pos                         6
N#define SSP_CR0_SPH_Pos                         7
N#define SSP_CR0_SCR_Pos                         8
N
N/* Bit field masks: */
N#define SSP_CR0_DSS_Msk                         ((uint32_t)0x0000000F)
N#define SSP_CR0_FRF_Msk                         ((uint32_t)0x00000030)
N#define SSP_CR0_SPO                             ((uint32_t)0x00000040)
N#define SSP_CR0_SPH                             ((uint32_t)0x00000080)
N#define SSP_CR0_SCR_Msk                         ((uint32_t)0x0000FF00)
N
N/** @} */ /* End of group SSP_CR0 */
N
N/** @defgroup Periph_SSP_CR1	SSP CR1
N  * @{
N  */ 
N
N/*-- SSP_CR1: SSP Control1 Register --------------------------------*/
N/* Bit field positions: */
N#define SSP_CR1_LBM_Pos                         0
N#define SSP_CR1_SSE_Pos                         1
N#define SSP_CR1_MS_Pos                          2
N#define SSP_CR1_SOD_Pos                         3
N
N/* Bit field masks: */
N#define SSP_CR1_LBM                             ((uint32_t)0x00000001)
N#define SSP_CR1_SSE                             ((uint32_t)0x00000002)
N#define SSP_CR1_MS                              ((uint32_t)0x00000004)
N#define SSP_CR1_SOD                             ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_CR1 */
N
N/** @defgroup Periph_SSP_SR	SSP SR
N  * @{
N  */ 
N
N/*-- SSP_SR: SSP Status Register -----------------------------------*/
N/* Bit field positions: */
N#define SSP_SR_TFE_Pos                          0
N#define SSP_SR_TNF_Pos                          1
N#define SSP_SR_RNE_Pos                          2
N#define SSP_SR_RFF_Pos                          3
N#define SSP_SR_BSY_Pos                          4
N
N/* Bit field masks: */
N#define SSP_SR_TFE                              ((uint32_t)0x00000001)
N#define SSP_SR_TNF                              ((uint32_t)0x00000002)
N#define SSP_SR_RNE                              ((uint32_t)0x00000004)
N#define SSP_SR_RFF                              ((uint32_t)0x00000008)
N#define SSP_SR_BSY                              ((uint32_t)0x00000010)
N
N/** @} */ /* End of group SSP_SR */
N
N/** @defgroup Periph_SSP_IMSC	SSP IMSC
N  * @{
N  */ 
N
N/*-- SSP_IMSC: SSP Interrupt Mask Register -------------------------*/
N/* Bit field positions: */
N#define SSP_IMSC_RORIM_Pos                      0
N#define SSP_IMSC_RTIM_Pos                       1
N#define SSP_IMSC_RXIM_Pos                       2
N#define SSP_IMSC_TXIM_Pos                       3
N
N/* Bit field masks: */
N#define SSP_IMSC_RORIM                          ((uint32_t)0x00000001)
N#define SSP_IMSC_RTIM                           ((uint32_t)0x00000002)
N#define SSP_IMSC_RXIM                           ((uint32_t)0x00000004)
N#define SSP_IMSC_TXIM                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_IMSC */
N
N/** @defgroup Periph_SSP_RIS	SSP RIS
N  * @{
N  */ 
N
N/*-- SSP_RIS: SSP Interrupt Pending Register -----------------------*/
N/* Bit field positions: */
N#define SSP_RIS_RORRIS_Pos                      0
N#define SSP_RIS_RTRIS_Pos                       1
N#define SSP_RIS_RXRIS_Pos                       2
N#define SSP_RIS_TXRIS_Pos                       3
N
N/* Bit field masks: */
N#define SSP_RIS_RORRIS                          ((uint32_t)0x00000001)
N#define SSP_RIS_RTRIS                           ((uint32_t)0x00000002)
N#define SSP_RIS_RXRIS                           ((uint32_t)0x00000004)
N#define SSP_RIS_TXRIS                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_RIS */
N
N/** @defgroup Periph_SSP_MIS	SSP MIS
N  * @{
N  */ 
N
N/*-- SSP_MIS: SSP Masked Interrupt Pending Register ----------------*/
N/* Bit field positions: */
N#define SSP_MIS_RORMIS_Pos                      0
N#define SSP_MIS_RTMIS_Pos                       1
N#define SSP_MIS_RXMIS_Pos                       2
N#define SSP_MIS_TXMIS_Pos                       3
N
N/* Bit field masks: */
N#define SSP_MIS_RORMIS                          ((uint32_t)0x00000001)
N#define SSP_MIS_RTMIS                           ((uint32_t)0x00000002)
N#define SSP_MIS_RXMIS                           ((uint32_t)0x00000004)
N#define SSP_MIS_TXMIS                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_MIS */
N
N/** @defgroup Periph_SSP_ICR	SSP ICR
N  * @{
N  */ 
N
N/*-- SSP_ICR: SSP Interrupt Clear Register -------------------------*/
N/* Bit field positions: */
N#define SSP_ICR_RORIC_Pos                       0
N#define SSP_ICR_RTIC_Pos                        1
N
N/* Bit field masks: */
N#define SSP_ICR_RORIC                           ((uint32_t)0x00000001)
N#define SSP_ICR_RTIC                            ((uint32_t)0x00000002)
N
N/** @} */ /* End of group SSP_ICR */
N
N/** @defgroup Periph_SSP_DMACR	SSP DMACR
N  * @{
N  */ 
N
N/*-- SSP_DMACR: SSP DMA Control Register ---------------------------*/
N/* Bit field positions: */
N#define SSP_DMACR_RXDMAE_Pos                    0
N#define SSP_DMACR_TXDMAE_Pos                    1
N
N/* Bit field masks: */
N#define SSP_DMACR_RXDMAE                        ((uint32_t)0x00000001)
N#define SSP_DMACR_TXDMAE                        ((uint32_t)0x00000002)
N
N/** @} */ /* End of group SSP_DMACR */
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP */
N
N/** @defgroup MDR32Fx_Periph_I2C I2C
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_I2C_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_I2C_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t PRL;
X  volatile uint32_t PRL;
N  __IO uint32_t PRH;
X  volatile uint32_t PRH;
N  __IO uint32_t CTR;
X  volatile uint32_t CTR;
N  __IO uint32_t RXD;
X  volatile uint32_t RXD;
N  __IO uint32_t STA;
X  volatile uint32_t STA;
N  __IO uint32_t TXD;
X  volatile uint32_t TXD;
N  __IO uint32_t CMD;
X  volatile uint32_t CMD;
N}MDR_I2C_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_I2C_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_I2C_CTR	I2C CTR
N  * @{
N  */ 
N
N/*-- I2C_CTR: I2C Control Register ---------------------------------*/
N/* Bit field positions: */
N#define I2C_CTR_S_I2C_Pos                       5
N#define I2C_CTR_EN_INT_Pos                      6
N#define I2C_CTR_EN_I2C_Pos                      7
N
N/* Bit field masks: */
N#define I2C_CTR_S_I2C                           ((uint32_t)0x00000020)
N#define I2C_CTR_EN_INT                          ((uint32_t)0x00000040)
N#define I2C_CTR_EN_I2C                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_CTR */
N
N/** @defgroup Periph_I2C_STA	I2C STA
N  * @{
N  */ 
N
N/*-- I2C_STA: I2C Status Register ----------------------------------*/
N/* Bit field positions: */
N#define I2C_STA_INT_Pos                         0
N#define I2C_STA_TR_PROG_Pos                     1
N#define I2C_STA_LOST_ARB_Pos                    5
N#define I2C_STA_BUSY_Pos                        6
N#define I2C_STA_RX_ACK_Pos                      7
N
N/* Bit field masks: */
N#define I2C_STA_INT                             ((uint32_t)0x00000001)
N#define I2C_STA_TR_PROG                         ((uint32_t)0x00000002)
N#define I2C_STA_LOST_ARB                        ((uint32_t)0x00000020)
N#define I2C_STA_BUSY                            ((uint32_t)0x00000040)
N#define I2C_STA_RX_ACK                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_STA */
N
N/** @defgroup Periph_I2C_CMD	I2C CMD
N  * @{
N  */ 
N
N/*-- I2C_CMD: I2C Command Register ---------------------------------*/
N/* Bit field positions: */
N#define I2C_CMD_CLRINT_Pos                      0
N#define I2C_CMD_ACK_Pos                         3
N#define I2C_CMD_WR_Pos                          4
N#define I2C_CMD_RD_Pos                          5
N#define I2C_CMD_STOP_Pos                        6
N#define I2C_CMD_START_Pos                       7
N
N/* Bit field masks: */
N#define I2C_CMD_CLRINT                          ((uint32_t)0x00000001)
N#define I2C_CMD_ACK                             ((uint32_t)0x00000008)
N#define I2C_CMD_WR                              ((uint32_t)0x00000010)
N#define I2C_CMD_RD                              ((uint32_t)0x00000020)
N#define I2C_CMD_STOP                            ((uint32_t)0x00000040)
N#define I2C_CMD_START                           ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_CMD */
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C */
N
N/** @defgroup MDR32Fx_Periph_POWER POWER
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_POWER_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_POWER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t PVDCS;
X  volatile uint32_t PVDCS;
N}MDR_POWER_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_POWER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_POWER_PVDCS	POWER PVDCS
N  * @{
N  */ 
N
N/*-- POWER_PVDCS: POWER Power Detector Control/Status Register -----*/
N/* Bit field positions: */
N#define POWER_PVDCS_PVDEN_Pos                   0
N#define POWER_PVDCS_PBLS_Pos                    1
N#define POWER_PVDCS_PLS_Pos                     3
N#define POWER_PVDCS_PVBD_Pos                    6
N#define POWER_PVDCS_PVD_Pos                     7
N#define POWER_PVDCS_IEPVBD_Pos                  8
N#define POWER_PVDCS_IEPVD_Pos                   9
N#define POWER_PVDCS_INVB_Pos                    10
N#define POWER_PVDCS_INV_Pos                     11
N
N/* Bit field masks: */
N#define POWER_PVDCS_PVDEN                       ((uint32_t)0x00000001)
N#define POWER_PVDCS_PBLS_Msk                    ((uint32_t)0x00000006)
N#define POWER_PVDCS_PLS_Msk                     ((uint32_t)0x00000038)
N#define POWER_PVDCS_PVBD                        ((uint32_t)0x00000040)
N#define POWER_PVDCS_PVD                         ((uint32_t)0x00000080)
N#define POWER_PVDCS_IEPVBD                      ((uint32_t)0x00000100)
N#define POWER_PVDCS_IEPVD                       ((uint32_t)0x00000200)
N#define POWER_PVDCS_INVB                        ((uint32_t)0x00000400)
N#define POWER_PVDCS_INV                         ((uint32_t)0x00000800)
N
N/** @} */ /* End of group POWER_PVDCS */
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER */
N
N/** @defgroup MDR32Fx_Periph_WWDG WWDG
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_WWDG_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_WWDG_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CFR;
X  volatile uint32_t CFR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N}MDR_WWDG_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_WWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_WWDG_CR	WWDG CR
N  * @{
N  */ 
N
N/*-- WWDG_CR: WWDG Command Register --------------------------------*/
N/* Bit field positions: */
N#define WWDG_CR_T_Pos                           0
N#define WWDG_CR_WDGA_Pos                        7
N
N/* Bit field masks: */
N#define WWDG_CR_T_Msk                           ((uint32_t)0x0000007F)
N#define WWDG_CR_WDGA                            ((uint32_t)0x00000080)
N
N/** @} */ /* End of group WWDG_CR */
N
N/** @defgroup Periph_WWDG_CFR	WWDG CFR
N  * @{
N  */ 
N
N/*-- WWDG_CFR: WWDG Configuration Register -------------------------*/
N/* Bit field positions: */
N#define WWDG_CFR_W_Pos                          0
N#define WWDG_CFR_WGTB_Pos                       7
N#define WWDG_CFR_EWI_Pos                        9
N
N/* Bit field masks: */
N#define WWDG_CFR_W_Msk                          ((uint32_t)0x0000007F)
N#define WWDG_CFR_WGTB_Msk                       ((uint32_t)0x00000180)
N#define WWDG_CFR_EWI                            ((uint32_t)0x00000200)
N
N/** @} */ /* End of group WWDG_CFR */
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG */
N
N/** @defgroup MDR32Fx_Periph_IWDG IWDG
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_IWDG_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_IWDG_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t KR;
X  volatile uint32_t KR;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t RLR;
X  volatile uint32_t RLR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N}MDR_IWDG_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_IWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_IWDG_SR	IWDG SR
N  * @{
N  */ 
N
N/*-- IWDG_SR: IWDG Status Register ---------------------------------*/
N/* Bit field positions: */
N#define IWDG_SR_PVU_Pos                         0
N#define IWDG_SR_RVU_Pos                         1
N
N/* Bit field masks: */
N#define IWDG_SR_PVU                             ((uint32_t)0x00000001)
N#define IWDG_SR_RVU                             ((uint32_t)0x00000002)
N
N/** @} */ /* End of group IWDG_SR */
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG */
N
N/** @defgroup MDR32Fx_Periph_TIMER TIMER
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_TIMER_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_TIMER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CNT;
X  volatile uint32_t CNT;
N  __IO uint32_t PSG;
X  volatile uint32_t PSG;
N  __IO uint32_t ARR;
X  volatile uint32_t ARR;
N  __IO uint32_t CNTRL;
X  volatile uint32_t CNTRL;
N  __IO uint32_t CCR1;
X  volatile uint32_t CCR1;
N  __IO uint32_t CCR2;
X  volatile uint32_t CCR2;
N  __IO uint32_t CCR3;
X  volatile uint32_t CCR3;
N  __IO uint32_t CCR4;
X  volatile uint32_t CCR4;
N  __IO uint32_t CH1_CNTRL;
X  volatile uint32_t CH1_CNTRL;
N  __IO uint32_t CH2_CNTRL;
X  volatile uint32_t CH2_CNTRL;
N  __IO uint32_t CH3_CNTRL;
X  volatile uint32_t CH3_CNTRL;
N  __IO uint32_t CH4_CNTRL;
X  volatile uint32_t CH4_CNTRL;
N  __IO uint32_t CH1_CNTRL1;
X  volatile uint32_t CH1_CNTRL1;
N  __IO uint32_t CH2_CNTRL1;
X  volatile uint32_t CH2_CNTRL1;
N  __IO uint32_t CH3_CNTRL1;
X  volatile uint32_t CH3_CNTRL1;
N  __IO uint32_t CH4_CNTRL1;
X  volatile uint32_t CH4_CNTRL1;
N  __IO uint32_t CH1_DTG;
X  volatile uint32_t CH1_DTG;
N  __IO uint32_t CH2_DTG;
X  volatile uint32_t CH2_DTG;
N  __IO uint32_t CH3_DTG;
X  volatile uint32_t CH3_DTG;
N  __IO uint32_t CH4_DTG;
X  volatile uint32_t CH4_DTG;
N  __IO uint32_t BRKETR_CNTRL;
X  volatile uint32_t BRKETR_CNTRL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t IE;
X  volatile uint32_t IE;
N  __IO uint32_t DMA_RE;
X  volatile uint32_t DMA_RE;
N  __IO uint32_t CH1_CNTRL2;
X  volatile uint32_t CH1_CNTRL2;
N  __IO uint32_t CH2_CNTRL2;
X  volatile uint32_t CH2_CNTRL2;
N  __IO uint32_t CH3_CNTRL2;
X  volatile uint32_t CH3_CNTRL2;
N  __IO uint32_t CH4_CNTRL2;
X  volatile uint32_t CH4_CNTRL2;
N  __IO uint32_t CCR11;
X  volatile uint32_t CCR11;
N  __IO uint32_t CCR21;
X  volatile uint32_t CCR21;
N  __IO uint32_t CCR31;
X  volatile uint32_t CCR31;
N  __IO uint32_t CCR41;
X  volatile uint32_t CCR41;
N}MDR_TIMER_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_CNTRL	TIMER CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_CNTRL: Timer Control Register ---------------------------*/
N/* Bit field positions: */
N#define TIMER_CNTRL_CNT_EN_Pos                  0
N#define TIMER_CNTRL_ARRB_EN_Pos                 1
N#define TIMER_CNTRL_WR_CMPL_Pos                 2
N#define TIMER_CNTRL_DIR_Pos                     3
N#define TIMER_CNTRL_FDTS_Pos                    4
N#define TIMER_CNTRL_CNT_MODE_Pos                6
N#define TIMER_CNTRL_EVENT_SEL_Pos               8
N
N/* Bit field masks: */
N#define TIMER_CNTRL_CNT_EN                      ((uint32_t)0x00000001)
N#define TIMER_CNTRL_ARRB_EN                     ((uint32_t)0x00000002)
N#define TIMER_CNTRL_WR_CMPL                     ((uint32_t)0x00000004)
N#define TIMER_CNTRL_DIR                         ((uint32_t)0x00000008)
N#define TIMER_CNTRL_FDTS_Msk                    ((uint32_t)0x00000030)
N#define TIMER_CNTRL_CNT_MODE_Msk                ((uint32_t)0x000000C0)
N#define TIMER_CNTRL_EVENT_SEL_Msk               ((uint32_t)0x00000F00)
N
N/** @} */ /* End of group TIMER_CNTRL */
N
N/** @defgroup Periph_TIMER_CH_CNTRL	TIMER CH CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL: Timer Channel Control Register ----------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL_CHFLTR_Pos               0
N#define TIMER_CH_CNTRL_CHSEL_Pos                4
N#define TIMER_CH_CNTRL_CHPSC_Pos                6
N#define TIMER_CH_CNTRL_OCCE_Pos                 8
N#define TIMER_CH_CNTRL_OCCM_Pos                 9
N#define TIMER_CH_CNTRL_BRKEN_Pos                12
N#define TIMER_CH_CNTRL_ETREN_Pos                13
N#define TIMER_CH_CNTRL_WR_CMPL_Pos              14
N#define TIMER_CH_CNTRL_CAP_NPWM_Pos             15
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL_CHFLTR_Msk               ((uint32_t)0x0000000F)
N#define TIMER_CH_CNTRL_CHSEL_Msk                ((uint32_t)0x00000030)
N#define TIMER_CH_CNTRL_CHPSC_Msk                ((uint32_t)0x000000C0)
N#define TIMER_CH_CNTRL_OCCE                     ((uint32_t)0x00000100)
N#define TIMER_CH_CNTRL_OCCM_Msk                 ((uint32_t)0x00000E00)
N#define TIMER_CH_CNTRL_BRKEN                    ((uint32_t)0x00001000)
N#define TIMER_CH_CNTRL_ETREN                    ((uint32_t)0x00002000)
N#define TIMER_CH_CNTRL_WR_CMPL                  ((uint32_t)0x00004000)
N#define TIMER_CH_CNTRL_CAP_NPWM                 ((uint32_t)0x00008000)
N
N/** @} */ /* End of group TIMER_CH_CNTRL */
N
N/** @defgroup Periph_TIMER_CH_CNTRL1	TIMER CH CNTRL1
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL1: Timer Channel Control1 Register --------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL1_SELOE_Pos               0
N#define TIMER_CH_CNTRL1_SELO_Pos                2
N#define TIMER_CH_CNTRL1_INV_Pos                 4
N#define TIMER_CH_CNTRL1_NSELOE_Pos              8
N#define TIMER_CH_CNTRL1_NSELO_Pos               10
N#define TIMER_CH_CNTRL1_NINV_Pos                12
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL1_SELOE_Msk               ((uint32_t)0x00000003)
N#define TIMER_CH_CNTRL1_SELO_Msk                ((uint32_t)0x0000000C)
N#define TIMER_CH_CNTRL1_INV                     ((uint32_t)0x00000010)
N#define TIMER_CH_CNTRL1_NSELOE_Msk              ((uint32_t)0x00000300)
N#define TIMER_CH_CNTRL1_NSELO_Msk               ((uint32_t)0x00000C00)
N#define TIMER_CH_CNTRL1_NINV                    ((uint32_t)0x00001000)
N
N/** @} */ /* End of group TIMER_CH_CNTRL1 */
N
N/** @defgroup Periph_TIMER_CH_DTG	TIMER CH DTG
N  * @{
N  */ 
N
N/*-- TIMER_CH_DTG: Timer Channel DTG Register ----------------------*/
N/* Bit field positions: */
N#define TIMER_CH_DTGX_Pos                       0
N#define TIMER_CH_DTG_EDTS_Pos                   4
N#define TIMER_CH_DTG_Pos                        8
N
N/* Bit field masks: */
N#define TIMER_CH_DTGX_Msk                       ((uint32_t)0x0000000F)
N#define TIMER_CH_DTG_EDTS                       ((uint32_t)0x00000010)
N#define TIMER_CH_DTG_Msk                        ((uint32_t)0x0000FF00)
N
N/** @} */ /* End of group TIMER_CH_DTG */
N
N/** @defgroup Periph_TIMER_BRKETR_CNTRL	TIMER BRKETR CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_BRKETR_CNTRL: Timer BRK/ETR Control Register ------------*/
N/* Bit field positions: */
N#define TIMER_BRKETR_CNTRL_BRK_INV_Pos          0
N#define TIMER_BRKETR_CNTRL_ETR_INV_Pos          1
N#define TIMER_BRKETR_CNTRL_ETR_PSC_Pos          2
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_Pos       4
N
N/* Bit field masks: */
N#define TIMER_BRKETR_CNTRL_BRK_INV              ((uint32_t)0x00000001)
N#define TIMER_BRKETR_CNTRL_ETR_INV              ((uint32_t)0x00000002)
N#define TIMER_BRKETR_CNTRL_ETR_PSC_Msk          ((uint32_t)0x0000000C)
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_Msk       ((uint32_t)0x000000F0)
N
N/** @} */ /* End of group TIMER_BRKETR_CNTRL */
N
N/** @defgroup Periph_TIMER_STATUS	TIMER STATUS
N  * @{
N  */ 
N
N/*-- TIMER_STATUS: Timer Status Register ---------------------------*/
N/* Bit field positions: */
N#define TIMER_STATUS_CNT_ZERO_EVENT_Pos         0
N#define TIMER_STATUS_CNT_ARR_EVENT_Pos          1
N#define TIMER_STATUS_ETR_RE_EVENT_Pos           2
N#define TIMER_STATUS_ETR_FE_EVENT_Pos           3
N#define TIMER_STATUS_BRK_EVENT_Pos              4
N#define TIMER_STATUS_CCR_CAP_EVENT_Pos          5
N#define TIMER_STATUS_CCR_REF_EVENT_Pos          9
N#define TIMER_STATUS_CCR1_CAP_EVENT_Pos         13
N
N/* Bit field masks: */
N#define TIMER_STATUS_CNT_ZERO_EVENT             ((uint32_t)0x00000001)
N#define TIMER_STATUS_CNT_ARR_EVENT              ((uint32_t)0x00000002)
N#define TIMER_STATUS_ETR_RE_EVENT               ((uint32_t)0x00000004)
N#define TIMER_STATUS_ETR_FE_EVENT               ((uint32_t)0x00000008)
N#define TIMER_STATUS_BRK_EVENT                  ((uint32_t)0x00000010)
N#define TIMER_STATUS_CCR_CAP_EVENT_Msk          ((uint32_t)0x000001E0)
N#define TIMER_STATUS_CCR_REF_EVENT_Msk          ((uint32_t)0x00001E00)
N#define TIMER_STATUS_CCR1_CAP_EVENT_Msk         ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_STATUS */
N
N/** @defgroup Periph_TIMER_IE	TIMER IE
N  * @{
N  */ 
N
N/*-- TIMER_IE: Timer Interrupt Enable Register ---------------------*/
N/* Bit field positions: */
N#define TIMER_IE_CNT_ZERO_EVENT_IE_Pos          0
N#define TIMER_IE_CNT_ARR_EVENT_IE_Pos           1
N#define TIMER_IE_ETR_RE_EVENT_IE_Pos            2
N#define TIMER_IE_ETR_FE_EVENT_IE_Pos            3
N#define TIMER_IE_BRK_EVENT_IE_Pos               4
N#define TIMER_IE_CCR_CAP_EVENT_IE_Pos           5
N#define TIMER_IE_CCR_REF_EVENT_IE_Pos           9
N#define TIMER_IE_CCR1_CAP_EVENT_IE_Pos          13
N
N/* Bit field masks: */
N#define TIMER_IE_CNT_ZERO_EVENT_IE              ((uint32_t)0x00000001)
N#define TIMER_IE_CNT_ARR_EVENT_IE               ((uint32_t)0x00000002)
N#define TIMER_IE_ETR_RE_EVENT_IE                ((uint32_t)0x00000004)
N#define TIMER_IE_ETR_FE_EVENT_IE                ((uint32_t)0x00000008)
N#define TIMER_IE_BRK_EVENT_IE                   ((uint32_t)0x00000010)
N#define TIMER_IE_CCR_CAP_EVENT_IE_Msk           ((uint32_t)0x000001E0)
N#define TIMER_IE_CCR_REF_EVENT_IE_Msk           ((uint32_t)0x00001E00)
N#define TIMER_IE_CCR1_CAP_EVENT_IE_Msk          ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_IE */
N
N/** @defgroup Periph_TIMER_DMA_RE	TIMER DMA RE
N  * @{
N  */ 
N
N/*-- TIMER_DMA_RE: Timer DMA Request Enable Register ---------------*/
N/* Bit field positions: */
N#define TIMER_DMA_RE_CNT_ZERO_EVENT_RE_Pos      0
N#define TIMER_DMA_RE_CNT_ARR_EVENT_RE_Pos       1
N#define TIMER_DMA_RE_ETR_RE_EVENT_RE_Pos        2
N#define TIMER_DMA_RE_ETR_FE_EVENT_RE_Pos        3
N#define TIMER_DMA_RE_BRK_EVENT_RE_Pos           4
N#define TIMER_DMA_RE_CCR_CAP_EVENT_RE_Pos       5
N#define TIMER_DMA_RE_CCR_REF_EVENT_RE_Pos       9
N#define TIMER_DMA_RE_CCR1_CAP_EVENT_RE_Pos      13
N
N/* Bit field masks: */
N#define TIMER_DMA_RE_CNT_ZERO_EVENT_RE          ((uint32_t)0x00000001)
N#define TIMER_DMA_RE_CNT_ARR_EVENT_RE           ((uint32_t)0x00000002)
N#define TIMER_DMA_RE_ETR_RE_EVENT_RE            ((uint32_t)0x00000004)
N#define TIMER_DMA_RE_ETR_FE_EVENT_RE            ((uint32_t)0x00000008)
N#define TIMER_DMA_RE_BRK_EVENT_RE               ((uint32_t)0x00000010)
N#define TIMER_DMA_RE_CCR_CAP_EVENT_RE_Msk       ((uint32_t)0x000001E0)
N#define TIMER_DMA_RE_CCR_REF_EVENT_RE_Msk       ((uint32_t)0x00001E00)
N#define TIMER_DMA_RE_CCR1_CAP_EVENT_RE_Msk      ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_DMA_RE */
N
N/** @defgroup Periph_TIMER_CH_CNTRL2	TIMER CH CNTRL2
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL2: Timer Channel Control2 Register --------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL2_CHSEL1_Pos              0
N#define TIMER_CH_CNTRL2_CCR1_EN_Pos             2
N#define TIMER_CH_CNTRL2_CCRRLD_Pos              3
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL2_CHSEL1_Msk              ((uint32_t)0x00000003)
N#define TIMER_CH_CNTRL2_CCR1_EN                 ((uint32_t)0x00000004)
N#define TIMER_CH_CNTRL2_CCRRLD                  ((uint32_t)0x00000008)
N
N/** @} */ /* End of group TIMER_CH_CNTRL2 */
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER */
N
N/** @defgroup MDR32Fx_Periph_ADC ADC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_ADC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_ADC_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t ADC1_CFG;
X  volatile uint32_t ADC1_CFG;
N  __IO uint32_t ADC2_CFG;
X  volatile uint32_t ADC2_CFG;
N  __IO uint32_t ADC1_H_LEVEL;
X  volatile uint32_t ADC1_H_LEVEL;
N  __IO uint32_t ADC2_H_LEVEL;
X  volatile uint32_t ADC2_H_LEVEL;
N  __IO uint32_t ADC1_L_LEVEL;
X  volatile uint32_t ADC1_L_LEVEL;
N  __IO uint32_t ADC2_L_LEVEL;
X  volatile uint32_t ADC2_L_LEVEL;
N  __IO uint32_t ADC1_RESULT;
X  volatile uint32_t ADC1_RESULT;
N  __IO uint32_t ADC2_RESULT;
X  volatile uint32_t ADC2_RESULT;
N  __IO uint32_t ADC1_STATUS;
X  volatile uint32_t ADC1_STATUS;
N  __IO uint32_t ADC2_STATUS;
X  volatile uint32_t ADC2_STATUS;
N  __IO uint32_t ADC1_CHSEL;
X  volatile uint32_t ADC1_CHSEL;
N  __IO uint32_t ADC2_CHSEL;
X  volatile uint32_t ADC2_CHSEL;
N}MDR_ADC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_ADC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ADC1_CFG	ADC1 CFG
N  * @{
N  */ 
N
N/*-- ADC1_CFG: ADC1 Configuration Register -------------------------*/
N/* Bit field positions: */
N#define ADC1_CFG_REG_ADON_Pos                   0
N#define ADC1_CFG_REG_GO_Pos                     1
N#define ADC1_CFG_REG_CLKS_Pos                   2
N#define ADC1_CFG_REG_SAMPLE_Pos                 3
N#define ADC1_CFG_REG_CHS_Pos                    4
N#define ADC1_CFG_REG_CHCH_Pos                   9
N#define ADC1_CFG_REG_RNGC_Pos                   10
N#define ADC1_CFG_M_REF_Pos                      11
N#define ADC1_CFG_REG_DIVCLK_Pos                 12
N#define ADC1_CFG_SYNC_CONVER_Pos                16
N#define ADC1_CFG_TS_EN_Pos                      17
N#define ADC1_CFG_TS_BUF_EN_Pos                  18
N#define ADC1_CFG_SEL_TS_Pos                     19
N#define ADC1_CFG_SEL_VREF_Pos                   20
N#define ADC1_CFG_TR_Pos                         21
N#define ADC1_CFG_DELAY_GO_Pos                   25
N#define ADC1_CFG_DELAY_ADC_Pos                  28
N
N/* Bit field masks: */
N#define ADC1_CFG_REG_ADON                       ((uint32_t)0x00000001)
N#define ADC1_CFG_REG_GO                         ((uint32_t)0x00000002)
N#define ADC1_CFG_REG_CLKS                       ((uint32_t)0x00000004)
N#define ADC1_CFG_REG_SAMPLE                     ((uint32_t)0x00000008)
N#define ADC1_CFG_REG_CHS_Msk                    ((uint32_t)0x000001F0)
N#define ADC1_CFG_REG_CHCH                       ((uint32_t)0x00000200)
N#define ADC1_CFG_REG_RNGC                       ((uint32_t)0x00000400)
N#define ADC1_CFG_M_REF                          ((uint32_t)0x00000800)
N#define ADC1_CFG_REG_DIVCLK_Msk                 ((uint32_t)0x0000F000)
N#define ADC1_CFG_SYNC_CONVER                    ((uint32_t)0x00010000)
N#define ADC1_CFG_TS_EN                          ((uint32_t)0x00020000)
N#define ADC1_CFG_TS_BUF_EN                      ((uint32_t)0x00040000)
N#define ADC1_CFG_SEL_TS                         ((uint32_t)0x00080000)
N#define ADC1_CFG_SEL_VREF                       ((uint32_t)0x00100000)
N#define ADC1_CFG_TR_Msk                         ((uint32_t)0x01E00000)
N#define ADC1_CFG_DELAY_GO_Msk                   ((uint32_t)0x0E000000)
N#define ADC1_CFG_DELAY_ADC_Msk                  ((uint32_t)0xF0000000)
N
N/** @} */ /* End of group ADC1_CFG */
N
N/** @defgroup Periph_ADC2_CFG	ADC2 CFG
N  * @{
N  */ 
N
N/*-- ADC2_CFG: ADC2 Configuration Register -------------------------*/
N/* Bit field positions: */
N#define ADC2_CFG_REG_ADON_Pos                   0
N#define ADC2_CFG_REG_GO_Pos                     1
N#define ADC2_CFG_REG_CLKS_Pos                   2
N#define ADC2_CFG_REG_SAMPLE_Pos                 3
N#define ADC2_CFG_REG_CHS_Pos                    4
N#define ADC2_CFG_REG_CHCH_Pos                   9
N#define ADC2_CFG_REG_RNGC_Pos                   10
N#define ADC2_CFG_M_REF_Pos                      11
N#define ADC2_CFG_REG_DIVCLK_Pos                 12
N#define ADC2_CFG_ADC1_OP_Pos                    17
N#define ADC2_CFG_ADC2_OP_Pos                    18
N#define ADC2_CFG_DELAY_GO_Pos                   25
N
N/* Bit field masks: */
N#define ADC2_CFG_REG_ADON                       ((uint32_t)0x00000001)
N#define ADC2_CFG_REG_GO                         ((uint32_t)0x00000002)
N#define ADC2_CFG_REG_CLKS                       ((uint32_t)0x00000004)
N#define ADC2_CFG_REG_SAMPLE                     ((uint32_t)0x00000008)
N#define ADC2_CFG_REG_CHS_Msk                    ((uint32_t)0x000001F0)
N#define ADC2_CFG_REG_CHCH                       ((uint32_t)0x00000200)
N#define ADC2_CFG_REG_RNGC                       ((uint32_t)0x00000400)
N#define ADC2_CFG_M_REF                          ((uint32_t)0x00000800)
N#define ADC2_CFG_REG_DIVCLK_Msk                 ((uint32_t)0x0000F000)
N#define ADC2_CFG_ADC1_OP                        ((uint32_t)0x00020000)
N#define ADC2_CFG_ADC2_OP                        ((uint32_t)0x00040000)
N#define ADC2_CFG_DELAY_GO_Msk                   ((uint32_t)0x0E000000)
N
N/** @} */ /* End of group ADC2_CFG */
N
N/** @defgroup Periph_ADC1_RESULT	ADC1 RESULT
N  * @{
N  */ 
N
N/*-- ADC1_RESULT: ADC1 Result Register -----------------------------*/
N/*-- ADC2_RESULT: ADC2 Result Register -----------------------------*/
N/* Bit field positions: */
N#define ADC_RESULT_Pos                          0
N#define ADC_RESULT_CHANNEL_Pos                  16
N
N/* Bit field masks: */
N#define ADC_RESULT_Msk                          ((uint32_t)0x00000FFF)
N#define ADC_RESULT_CHANNEL_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group ADC1_RESULT */
N
N/** @defgroup Periph_ADC1_STATUS	ADC1 STATUS
N  * @{
N  */ 
N
N/*-- ADC1_STATUS: ADC1 Status Register -----------------------------*/
N/*-- ADC2_STATUS: ADC2 Status Register -----------------------------*/
N/* Bit field positions: */
N#define ADC_STATUS_FLG_REG_OVERWRITE_Pos        0
N#define ADC_STATUS_FLG_REG_AWOIFEN_Pos          1
N#define ADC_STATUS_FLG_REG_EOCIF_Pos            2
N#define ADC_STATUS_AWOIF_IE_Pos                 3
N#define ADC_STATUS_ECOIF_IE_Pos                 4
N
N/* Bit field masks: */
N#define ADC_STATUS_FLG_REG_OVERWRITE            ((uint32_t)0x00000001)
N#define ADC_STATUS_FLG_REG_AWOIFEN              ((uint32_t)0x00000002)
N#define ADC_STATUS_FLG_REG_EOCIF                ((uint32_t)0x00000004)
N#define ADC_STATUS_AWOIF_IE                     ((uint32_t)0x00000008)
N#define ADC_STATUS_ECOIF_IE                     ((uint32_t)0x00000010)
N
N/** @} */ /* End of group ADC1_STATUS */
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC */
N
N/** @defgroup MDR32Fx_Periph_DAC DAC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_DAC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_DAC_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t DAC1_DATA;
X  volatile uint32_t DAC1_DATA;
N  __IO uint32_t DAC2_DATA;
X  volatile uint32_t DAC2_DATA;
N}MDR_DAC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_DAC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DAC_CFG	DAC CFG
N  * @{
N  */ 
N
N/*-- DAC_CFG: DAC Configuration Register ---------------------------*/
N/* Bit field positions: */
N#define DAC_CFG_M_REF0_Pos                      0
N#define DAC_CFG_M_REF1_Pos                      1
N#define DAC_CFG_ON_DAC0_Pos                     2
N#define DAC_CFG_ON_DAC1_Pos                     3
N#define DAC_CFG_SYNC_A_Pos                      4
N
N/* Bit field masks: */
N#define DAC_CFG_M_REF0                          ((uint32_t)0x00000001)
N#define DAC_CFG_M_REF1                          ((uint32_t)0x00000002)
N#define DAC_CFG_ON_DAC0                         ((uint32_t)0x00000004)
N#define DAC_CFG_ON_DAC1                         ((uint32_t)0x00000008)
N#define DAC_CFG_SYNC_A                          ((uint32_t)0x00000010)
N
N/** @} */ /* End of group DAC_CFG */
N
N/** @defgroup Periph_DAC1_DATA	DAC1 DATA
N  * @{
N  */ 
N
N/*-- DAC1_DATA: DAC1 Data Register ---------------------------------*/
N/* Bit field positions: */
N#define DAC1_DATA_DAC0DATA_Pos                  0
N#define DAC1_DATA_DAC1DATA_Pos                  16
N
N/* Bit field masks: */
N#define DAC1_DATA_DAC0DATA_Msk                  ((uint32_t)0x00000FFF)
N#define DAC1_DATA_DAC1DATA_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group DAC1_DATA */
N
N/** @defgroup Periph_DAC2_DATA	DAC2 DATA
N  * @{
N  */ 
N
N/*-- DAC2_DATA: DAC2 Data Register ---------------------------------*/
N/* Bit field positions: */
N#define DAC2_DATA_DAC1DATA_Pos                  0
N#define DAC2_DATA_DAC0DATA_Pos                  16
N
N/* Bit field masks: */
N#define DAC2_DATA_DAC1DATA_Msk                  ((uint32_t)0x00000FFF)
N#define DAC2_DATA_DAC0DATA_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group DAC2_DATA */
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC */
N
N/** @defgroup MDR32Fx_Periph_COMP COMP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_COMP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_COMP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t RESULT;
X  volatile uint32_t RESULT;
N  __IO uint32_t RESULT_LATCH;
X  volatile uint32_t RESULT_LATCH;
N}MDR_COMP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_COMP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_COMP_CFG	COMP CFG
N  * @{
N  */ 
N
N/*-- COMP_CFG: COMP Configuration Register -------------------------*/
N/* Bit field positions: */
N#define COMP_CFG_ON_Pos                         0
N#define COMP_CFG_CVRR_Pos                       1
N#define COMP_CFG_CVRSS_Pos                      2
N#define COMP_CFG_CVREN_Pos                      3
N#define COMP_CFG_CVR_Pos                        4
N#define COMP_CFG_CREF_Pos                       8
N#define COMP_CFG_CCH_Pos                        9
N#define COMP_CFG_INV_Pos                        11
N#define COMP_CFG_READY_Pos                      12
N#define COMP_CFG_CMPIE_Pos                      13
N
N/* Bit field masks: */
N#define COMP_CFG_ON                             ((uint32_t)0x00000001)
N#define COMP_CFG_CVRR                           ((uint32_t)0x00000002)
N#define COMP_CFG_CVRSS                          ((uint32_t)0x00000004)
N#define COMP_CFG_CVREN                          ((uint32_t)0x00000008)
N#define COMP_CFG_CVR_Msk                        ((uint32_t)0x000000F0)
N#define COMP_CFG_CREF                           ((uint32_t)0x00000100)
N#define COMP_CFG_CCH_Msk                        ((uint32_t)0x00000600)
N#define COMP_CFG_INV                            ((uint32_t)0x00000800)
N#define COMP_CFG_READY                          ((uint32_t)0x00001000)
N#define COMP_CFG_CMPIE                          ((uint32_t)0x00002000)
N
N/** @} */ /* End of group COMP_CFG */
N
N/** @defgroup Periph_COMP_RESULT	COMP RESULT
N  * @{
N  */ 
N
N/*-- COMP_RESULT: COMP Result Register -----------------------------*/
N/* Bit field positions: */
N#define COMP_RESULT_RSLT_SY_Pos                 0
N#define COMP_RESULT_RSLT_AS_Pos                 1
N#define COMP_RESULT_RST_LCH_Pos                 2
N
N/* Bit field masks: */
N#define COMP_RESULT_RSLT_SY                     ((uint32_t)0x00000001)
N#define COMP_RESULT_RSLT_AS                     ((uint32_t)0x00000002)
N#define COMP_RESULT_RST_LCH                     ((uint32_t)0x00000004)
N
N/** @} */ /* End of group COMP_RESULT */
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP */
N
N/** @defgroup MDR32Fx_Periph_PORT PORT
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_PORT_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_PORT_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t RXTX;
X  volatile uint32_t RXTX;
N  __IO uint32_t OE;
X  volatile uint32_t OE;
N  __IO uint32_t FUNC;
X  volatile uint32_t FUNC;
N  __IO uint32_t ANALOG;
X  volatile uint32_t ANALOG;
N  __IO uint32_t PULL;
X  volatile uint32_t PULL;
N  __IO uint32_t PD;
X  volatile uint32_t PD;
N  __IO uint32_t PWR;
X  volatile uint32_t PWR;
N  __IO uint32_t GFEN;
X  volatile uint32_t GFEN;
N}MDR_PORT_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_PORT_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_PORT_FUNC	PORT FUNC
N  * @{
N  */ 
N
N/*-- PORT_FUNC: PORT Function Register -----------------------------*/
N/* Bit field positions: */
N#define PORT_FUNC_MODE0_Pos                     0
N#define PORT_FUNC_MODE1_Pos                     2
N#define PORT_FUNC_MODE2_Pos                     4
N#define PORT_FUNC_MODE3_Pos                     6
N#define PORT_FUNC_MODE4_Pos                     8
N#define PORT_FUNC_MODE5_Pos                     10
N#define PORT_FUNC_MODE6_Pos                     12
N#define PORT_FUNC_MODE7_Pos                     14
N#define PORT_FUNC_MODE8_Pos                     16
N#define PORT_FUNC_MODE9_Pos                     18
N#define PORT_FUNC_MODE10_Pos                    20
N#define PORT_FUNC_MODE11_Pos                    22
N#define PORT_FUNC_MODE12_Pos                    24
N#define PORT_FUNC_MODE13_Pos                    26
N#define PORT_FUNC_MODE14_Pos                    28
N#define PORT_FUNC_MODE15_Pos                    30
N
N/* Bit field masks: */
N#define PORT_FUNC_MODE0_Msk                     ((uint32_t)0x00000003)
N#define PORT_FUNC_MODE1_Msk                     ((uint32_t)0x0000000C)
N#define PORT_FUNC_MODE2_Msk                     ((uint32_t)0x00000030)
N#define PORT_FUNC_MODE3_Msk                     ((uint32_t)0x000000C0)
N#define PORT_FUNC_MODE4_Msk                     ((uint32_t)0x00000300)
N#define PORT_FUNC_MODE5_Msk                     ((uint32_t)0x00000C00)
N#define PORT_FUNC_MODE6_Msk                     ((uint32_t)0x00003000)
N#define PORT_FUNC_MODE7_Msk                     ((uint32_t)0x0000C000)
N#define PORT_FUNC_MODE8_Msk                     ((uint32_t)0x00030000)
N#define PORT_FUNC_MODE9_Msk                     ((uint32_t)0x000C0000)
N#define PORT_FUNC_MODE10_Msk                    ((uint32_t)0x00300000)
N#define PORT_FUNC_MODE11_Msk                    ((uint32_t)0x00C00000)
N#define PORT_FUNC_MODE12_Msk                    ((uint32_t)0x03000000)
N#define PORT_FUNC_MODE13_Msk                    ((uint32_t)0x0C000000)
N#define PORT_FUNC_MODE14_Msk                    ((uint32_t)0x30000000)
N#define PORT_FUNC_MODE15_Msk                    ((uint32_t)0xC0000000)
N
N/** @} */ /* End of group PORT_FUNC */
N
N/** @defgroup Periph_PORT_PULL	PORT PULL
N  * @{
N  */ 
N
N/*-- PORT_PULL: PORT Pull Up/Down Register -------------------------*/
N/* Bit field positions: */
N#define PORT_PULL_DOWN_Pos                      0
N#define PORT_PULL_UP_Pos                        16
N
N/* Bit field masks: */
N#define PORT_PULL_DOWN_Msk                      ((uint32_t)0x0000FFFF)
N#define PORT_PULL_UP_Msk                        ((uint32_t)0xFFFF0000)
N
N/** @} */ /* End of group PORT_PULL */
N
N/** @defgroup Periph_PORT_PD	PORT PD
N  * @{
N  */ 
N
N/*-- PORT_PD: PORT Driver Mode Register ----------------------------*/
N/* Bit field positions: */
N#define PORT_PD_Pos                             0
N#define PORT_PD_SHM_Pos                         16
N
N/* Bit field masks: */
N#define PORT_PD_Msk                             ((uint32_t)0x0000FFFF)
N#define PORT_PD_SHM_Msk                         ((uint32_t)0xFFFF0000)
N
N/** @} */ /* End of group PORT_PD */
N
N/** @defgroup Periph_PORT_PWR	PORT PWR
N  * @{
N  */ 
N
N/*-- PORT_PWR: PORT Power Register ---------------------------------*/
N/* Bit field positions: */
N#define PORT_PWR0_Pos                           0
N#define PORT_PWR1_Pos                           2
N#define PORT_PWR2_Pos                           4
N#define PORT_PWR3_Pos                           6
N#define PORT_PWR4_Pos                           8
N#define PORT_PWR5_Pos                           10
N#define PORT_PWR6_Pos                           12
N#define PORT_PWR7_Pos                           14
N#define PORT_PWR8_Pos                           16
N#define PORT_PWR9_Pos                           18
N#define PORT_PWR10_Pos                          20
N#define PORT_PWR11_Pos                          22
N#define PORT_PWR12_Pos                          24
N#define PORT_PWR13_Pos                          26
N#define PORT_PWR14_Pos                          28
N#define PORT_PWR15_Pos                          30
N
N/* Bit field masks: */
N#define PORT_PWR0_Msk                           ((uint32_t)0x00000003)
N#define PORT_PWR1_Msk                           ((uint32_t)0x0000000C)
N#define PORT_PWR2_Msk                           ((uint32_t)0x00000030)
N#define PORT_PWR3_Msk                           ((uint32_t)0x000000C0)
N#define PORT_PWR4_Msk                           ((uint32_t)0x00000300)
N#define PORT_PWR5_Msk                           ((uint32_t)0x00000C00)
N#define PORT_PWR6_Msk                           ((uint32_t)0x00003000)
N#define PORT_PWR7_Msk                           ((uint32_t)0x0000C000)
N#define PORT_PWR8_Msk                           ((uint32_t)0x00030000)
N#define PORT_PWR9_Msk                           ((uint32_t)0x000C0000)
N#define PORT_PWR10_Msk                          ((uint32_t)0x00300000)
N#define PORT_PWR11_Msk                          ((uint32_t)0x00C00000)
N#define PORT_PWR12_Msk                          ((uint32_t)0x03000000)
N#define PORT_PWR13_Msk                          ((uint32_t)0x0C000000)
N#define PORT_PWR14_Msk                          ((uint32_t)0x30000000)
N#define PORT_PWR15_Msk                          ((uint32_t)0xC0000000)
N
N/** @} */ /* End of group PORT_PWR */
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT */
N
N/** @defgroup MDR32Fx_Periph_BKP BKP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_BKP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_BKP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t REG_00;
X  volatile uint32_t REG_00;
N  __IO uint32_t REG_01;
X  volatile uint32_t REG_01;
N  __IO uint32_t REG_02;
X  volatile uint32_t REG_02;
N  __IO uint32_t REG_03;
X  volatile uint32_t REG_03;
N  __IO uint32_t REG_04;
X  volatile uint32_t REG_04;
N  __IO uint32_t REG_05;
X  volatile uint32_t REG_05;
N  __IO uint32_t REG_06;
X  volatile uint32_t REG_06;
N  __IO uint32_t REG_07;
X  volatile uint32_t REG_07;
N  __IO uint32_t REG_08;
X  volatile uint32_t REG_08;
N  __IO uint32_t REG_09;
X  volatile uint32_t REG_09;
N  __IO uint32_t REG_0A;
X  volatile uint32_t REG_0A;
N  __IO uint32_t REG_0B;
X  volatile uint32_t REG_0B;
N  __IO uint32_t REG_0C;
X  volatile uint32_t REG_0C;
N  __IO uint32_t REG_0D;
X  volatile uint32_t REG_0D;
N  __IO uint32_t REG_0E;
X  volatile uint32_t REG_0E;
N  __IO uint32_t REG_0F;
X  volatile uint32_t REG_0F;
N  __IO uint32_t RTC_CNT;
X  volatile uint32_t RTC_CNT;
N  __IO uint32_t RTC_DIV;
X  volatile uint32_t RTC_DIV;
N  __IO uint32_t RTC_PRL;
X  volatile uint32_t RTC_PRL;
N  __IO uint32_t RTC_ALRM;
X  volatile uint32_t RTC_ALRM;
N  __IO uint32_t RTC_CS;
X  volatile uint32_t RTC_CS;
N}MDR_BKP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_BKP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_BKP_REG_0E	BKP REG 0E
N  * @{
N  */ 
N
N/*-- BKP_REG_0E: Backup Register 14 --------------------------------*/
N/* Bit field positions: */
N#define BKP_REG_0E_LOW_Pos                      0
N#define BKP_REG_0E_SELECTRI_Pos                 3
N#define BKP_REG_0E_JTAGA_Pos                    6
N#define BKP_REG_0E_JTAGB_Pos                    7
N#define BKP_REG_0E_TRIM_Pos                     8
N#define BKP_REG_0E_FPOR_Pos                     11
N#define BKP_REG_0E_BKP_REG_Pos                  12
N
N/* Bit field masks: */
N#define BKP_REG_0E_LOW_Msk                      ((uint32_t)0x00000007)
N#define BKP_REG_0E_SELECTRI_Msk                 ((uint32_t)0x00000038)
N#define BKP_REG_0E_JTAGA                        ((uint32_t)0x00000040)
N#define BKP_REG_0E_JTAGB                        ((uint32_t)0x00000080)
N#define BKP_REG_0E_TRIM_Msk                     ((uint32_t)0x00000700)
N#define BKP_REG_0E_FPOR                         ((uint32_t)0x00000800)
N#define BKP_REG_0E_BKP_REG_Msk                  ((uint32_t)0xFFFFF000)
N
N/** @} */ /* End of group BKP_REG_0E */
N
N/** @defgroup Periph_BKP_REG_0F	BKP REG 0F
N  * @{
N  */ 
N
N/*-- BKP_REG_0F: Backup Register 15 --------------------------------*/
N/* Bit field positions: */
N#define BKP_REG_0F_LSE_ON_Pos                   0
N#define BKP_REG_0F_LSE_BYP_Pos                  1
N#define BKP_REG_0F_RTC_SEL_Pos                  2
N#define BKP_REG_0F_RTC_EN_Pos                   4
N#define BKP_REG_0F_CAL_Pos                      5
N#define BKP_REG_0F_LSE_RDY_Pos                  13
N#define BKP_REG_0F_BKP_REG_Pos                  14
N#define BKP_REG_0F_LSI_ON_Pos                   15
N#define BKP_REG_0F_LSI_TRIM_Pos                 16
N#define BKP_REG_0F_LSI_RDY_Pos                  21
N#define BKP_REG_0F_HSI_ON_Pos                   22
N#define BKP_REG_0F_HSI_RDY_Pos                  23
N#define BKP_REG_0F_HSI_TRIM_Pos                 24
N#define BKP_REG_0F_STANDBY_Pos                  30
N#define BKP_REG_0F_RTC_RESET_Pos                31
N
N/* Bit field masks: */
N#define BKP_REG_0F_LSE_ON                       ((uint32_t)0x00000001)
N#define BKP_REG_0F_LSE_BYP                      ((uint32_t)0x00000002)
N#define BKP_REG_0F_RTC_SEL_Msk                  ((uint32_t)0x0000000C)
N#define BKP_REG_0F_RTC_EN                       ((uint32_t)0x00000010)
N#define BKP_REG_0F_CAL_Msk                      ((uint32_t)0x00001FE0)
N#define BKP_REG_0F_LSE_RDY                      ((uint32_t)0x00002000)
N#define BKP_REG_0F_BKP_REG                      ((uint32_t)0x00004000)
N#define BKP_REG_0F_LSI_ON                       ((uint32_t)0x00008000)
N#define BKP_REG_0F_LSI_TRIM_Msk                 ((uint32_t)0x001F0000)
N#define BKP_REG_0F_LSI_RDY                      ((uint32_t)0x00200000)
N#define BKP_REG_0F_HSI_ON                       ((uint32_t)0x00400000)
N#define BKP_REG_0F_HSI_RDY                      ((uint32_t)0x00800000)
N#define BKP_REG_0F_HSI_TRIM_Msk                 ((uint32_t)0x3F000000)
N#define BKP_REG_0F_STANDBY                      ((uint32_t)0x40000000)
N#define BKP_REG_0F_RTC_RESET                    ((uint32_t)0x80000000)
N
N/** @} */ /* End of group BKP_REG_0F */
N
N/** @defgroup Periph_BKP_RTC_CS	BKP RTC CS
N  * @{
N  */ 
N
N/*-- BKP_RTC_CS: Backup Realtime clock Register --------------------*/
N/* Bit field positions: */
N#define BKP_RTC_CS_OWF_Pos                      0
N#define BKP_RTC_CS_SECF_Pos                     1
N#define BKP_RTC_CS_ALRF_Pos                     2
N#define BKP_RTC_CS_OWF_IE_Pos                   3
N#define BKP_RTC_CS_SECF_IE_Pos                  4
N#define BKP_RTC_CS_ALRF_IE_Pos                  5
N#define BKP_RTC_CS_WEC_Pos                      6
N
N/* Bit field masks: */
N#define BKP_RTC_CS_OWF                          ((uint32_t)0x00000001)
N#define BKP_RTC_CS_SECF                         ((uint32_t)0x00000002)
N#define BKP_RTC_CS_ALRF                         ((uint32_t)0x00000004)
N#define BKP_RTC_CS_OWF_IE                       ((uint32_t)0x00000008)
N#define BKP_RTC_CS_SECF_IE                      ((uint32_t)0x00000010)
N#define BKP_RTC_CS_ALRF_IE                      ((uint32_t)0x00000020)
N#define BKP_RTC_CS_WEC                          ((uint32_t)0x00000040)
N
N/** @} */ /* End of group BKP_RTC_CS */
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP */
N
N/** @defgroup MDR32Fx_Periph_EBC EBC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_EBC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_EBC_TypeDef structure */
Ntypedef struct
N{
N       uint32_t RESERVED0[20];
N  __IO uint32_t NAND_CYCLES;
X  volatile uint32_t NAND_CYCLES;
N  __IO uint32_t CONTROL;
X  volatile uint32_t CONTROL;
N#if defined (USE_MDR1986VE94)
X#if 0L
S  __IO uint32_t MEM_REGION[4];
N#endif
N}MDR_EBC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_EBC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EBC_NAND_CYCLES	EBC NAND CYCLES
N  * @{
N  */ 
N
N/*-- EBC_NAND_CYCLES: EBC NAND Timing Register ---------------------*/
N/* Bit field positions: */
N#define EBC_NAND_CYCLES_TRC_Pos                 0
N#define EBC_NAND_CYCLES_TWC_Pos                 4
N#define EBC_NAND_CYCLES_TREA_Pos                8
N#define EBC_NAND_CYCLES_TWP_Pos                 12
N#define EBC_NAND_CYCLES_TWHR_Pos                16
N#define EBC_NAND_CYCLES_TALEA_Pos               20
N#define EBC_NAND_CYCLES_TRR_Pos                 24
N
N/* Bit field masks: */
N#define EBC_NAND_CYCLES_TRC_Msk                 ((uint32_t)0x0000000F)
N#define EBC_NAND_CYCLES_TWC_Msk                 ((uint32_t)0x000000F0)
N#define EBC_NAND_CYCLES_TREA_Msk                ((uint32_t)0x00000F00)
N#define EBC_NAND_CYCLES_TWP_Msk                 ((uint32_t)0x0000F000)
N#define EBC_NAND_CYCLES_TWHR_Msk                ((uint32_t)0x000F0000)
N#define EBC_NAND_CYCLES_TALEA_Msk               ((uint32_t)0x00F00000)
N#define EBC_NAND_CYCLES_TRR_Msk                 ((uint32_t)0x0F000000)
N
N/** @} */ /* End of group EBC_NAND_CYCLES */
N
N/** @defgroup Periph_EBC_CONTROL	EBC CONTROL
N  * @{
N  */ 
N
N/*-- EBC_CONTROL: EBC Control Register -----------------------------*/
N/* Bit field positions: */
N#define EBC_CONTROL_ROM_Pos                     0
N#define EBC_CONTROL_RAM_Pos                     1
N#define EBC_CONTROL_NAND_Pos                    2
N#define EBC_CONTROL_CPOL_Pos                    3
N#define EBC_CONTROL_BUSY_Pos                    7
N#define EBC_CONTROL_WAIT_STATE_Pos              12
N#if defined (USE_MDR1986VE94)
X#if 0L
S	#define EBC_CONTROL_FS_RDY_Pos					16
S	#define EBC_CONTROL_FF_RDY_Pos					17
N#endif
N
N/* Bit field masks: */
N#define EBC_CONTROL_ROM                         ((uint32_t)0x00000001)
N#define EBC_CONTROL_RAM                         ((uint32_t)0x00000002)
N#define EBC_CONTROL_NAND                        ((uint32_t)0x00000004)
N#define EBC_CONTROL_CPOL                        ((uint32_t)0x00000008)
N#define EBC_CONTROL_BUSY                        ((uint32_t)0x00000080)
N#define EBC_CONTROL_WAIT_STATE_Msk              ((uint32_t)0x0000F000)
N#if defined (USE_MDR1986VE94)
X#if 0L
S	#define EBC_CONTROL_FS_RDY					((uint32_t)0x00010000)
S	#define EBC_CONTROL_FF_RDY					((uint32_t)0x00020000)
N#endif
N
N
N/** @} */ /* End of group EBC_CONTROL */
N
N#if defined (USE_MDR1986VE94)
X#if 0L
S
S/** @defgroup Periph_EBC_RAM_CYCLESx	EBC RAM CYCLESx
S  * @{
S  */
S
S/*-- EBC_RAM_CYCLESx: Register customization options exchange with RAM -------*/
S/* Bit field positions: */
S#define EBC_RAM_CYCLES_ENABLE_TUNE_Pos			0
S#define EBC_RAM_CYCLES_WS_ACTIVE_Pos			1
S#define EBC_RAM_CYCLES_WS_SETUP_Pos				8
S#define EBC_RAM_CYCLES_WS_HOLD_Pos				11
S#define EBC_RAM_CYCLES_USE_READY_Pos			14
S
S/* Bit field masks: */
S#define EBC_RAM_CYCLES_ENABLE_TUNE				((uint32_t)0x00000001)
S#define EBC_RAM_CYCLES_WS_ACTIVE_Msk			((uint32_t)0x000000FE)
S#define EBC_RAM_CYCLES_WS_SETUP_Msk				((uint32_t)0x00000700)
S#define EBC_RAM_CYCLES_WS_HOLD_Msk				((uint32_t)0x00003200)
S#define EBC_RAM_CYCLES_USE_READY				((uint32_t)0x00004000)
S
S/** @} */ /* End of group EBC_RAM_CYCLESx */
N#endif
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC */
N
N/** @} */ /* End of group __MDR32Fx_Peripheral_Units */
N
N
N/** @defgroup __Peripheral_Memory_Map Peripheral Memory Map
N  * @{
N  */
N
N#define MDR_CAN1_BASE       (0x40000000)
N#define MDR_CAN2_BASE       (0x40008000)
N#define MDR_USB_BASE        (0x40010000)
N#define MDR_EEPROM_BASE     (0x40018000)
N#define MDR_RST_CLK_BASE    (0x40020000)
N#define MDR_DMA_BASE        (0x40028000)
N#define MDR_UART1_BASE      (0x40030000)
N#define MDR_UART2_BASE      (0x40038000)
N#define MDR_SSP1_BASE       (0x40040000)
N#define MDR_I2C_BASE        (0x40050000)
N#define MDR_POWER_BASE      (0x40058000)
N#define MDR_WWDG_BASE       (0x40060000)
N#define MDR_IWDG_BASE       (0x40068000)
N#define MDR_TIMER1_BASE     (0x40070000)
N#define MDR_TIMER2_BASE     (0x40078000)
N#define MDR_TIMER3_BASE     (0x40080000)
N#define MDR_ADC_BASE        (0x40088000)
N#define MDR_DAC_BASE        (0x40090000)
N#define MDR_COMP_BASE       (0x40098000)
N#define MDR_SSP2_BASE       (0x400A0000)
N#define MDR_PORTA_BASE      (0x400A8000)
N#define MDR_PORTB_BASE      (0x400B0000)
N#define MDR_PORTC_BASE      (0x400B8000)
N#define MDR_PORTD_BASE      (0x400C0000)
N#define MDR_PORTE_BASE      (0x400C8000)
N#define MDR_BKP_BASE        (0x400D8000)
N#define MDR_PORTF_BASE      (0x400E8000)
N#define MDR_EBC_BASE        (0x400F0000)
N
N/** @} */ /* End of group __Peripheral_Memory_Map */
N
N/** @defgroup __Peripheral_declaration Peripheral declaration
N  * @{
N  */
N
N#define MDR_CAN1            ((MDR_CAN_TypeDef     *) MDR_CAN1_BASE)
N#define MDR_CAN2            ((MDR_CAN_TypeDef     *) MDR_CAN2_BASE)
N#define MDR_USB             ((MDR_USB_TypeDef     *) MDR_USB_BASE)
N#define MDR_EEPROM          ((MDR_EEPROM_TypeDef  *) MDR_EEPROM_BASE)
N#define MDR_RST_CLK         ((MDR_RST_CLK_TypeDef *) MDR_RST_CLK_BASE)
N#define MDR_DMA             ((MDR_DMA_TypeDef     *) MDR_DMA_BASE)
N#define MDR_UART1           ((MDR_UART_TypeDef    *) MDR_UART1_BASE)
N#define MDR_UART2           ((MDR_UART_TypeDef    *) MDR_UART2_BASE)
N#define MDR_SSP1            ((MDR_SSP_TypeDef     *) MDR_SSP1_BASE)
N#define MDR_I2C             ((MDR_I2C_TypeDef     *) MDR_I2C_BASE)
N#define MDR_POWER           ((MDR_POWER_TypeDef   *) MDR_POWER_BASE)
N#define MDR_WWDG            ((MDR_WWDG_TypeDef    *) MDR_WWDG_BASE)
N#define MDR_IWDG            ((MDR_IWDG_TypeDef    *) MDR_IWDG_BASE)
N#define MDR_TIMER1          ((MDR_TIMER_TypeDef   *) MDR_TIMER1_BASE)
N#define MDR_TIMER2          ((MDR_TIMER_TypeDef   *) MDR_TIMER2_BASE)
N#define MDR_TIMER3          ((MDR_TIMER_TypeDef   *) MDR_TIMER3_BASE)
N#define MDR_ADC             ((MDR_ADC_TypeDef     *) MDR_ADC_BASE)
N#define MDR_DAC             ((MDR_DAC_TypeDef     *) MDR_DAC_BASE)
N#define MDR_COMP            ((MDR_COMP_TypeDef    *) MDR_COMP_BASE)
N#define MDR_SSP2            ((MDR_SSP_TypeDef     *) MDR_SSP2_BASE)
N#define MDR_PORTA           ((MDR_PORT_TypeDef    *) MDR_PORTA_BASE)
N#define MDR_PORTB           ((MDR_PORT_TypeDef    *) MDR_PORTB_BASE)
N#define MDR_PORTC           ((MDR_PORT_TypeDef    *) MDR_PORTC_BASE)
N#define MDR_PORTD           ((MDR_PORT_TypeDef    *) MDR_PORTD_BASE)
N#define MDR_PORTE           ((MDR_PORT_TypeDef    *) MDR_PORTE_BASE)
N#define MDR_BKP             ((MDR_BKP_TypeDef     *) MDR_BKP_BASE)
N#define MDR_PORTF           ((MDR_PORT_TypeDef    *) MDR_PORTF_BASE)
N#define MDR_EBC             ((MDR_EBC_TypeDef     *) MDR_EBC_BASE)
N
N/** @} */ /* End of group __Peripheral_declaration */
N
N#ifdef __cplusplus
S}
N#endif
N
N/** @} */ /* End of group __MDR32Fx_Peripheral */
N
N/** @} */ /* End of group MDR1986VE9x */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __MDR32FX_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE MDR32Fx.h */
L 61 "..\..\Config\MDR32F9Qx_config.h" 2
N#elif defined (USE_MDR1986VE1T)
S	#include "MDR1986VE1T.h"
S#elif defined ( USE_MDR1986VE3 )
S	#include "MDR1986VE3.h"
N#endif
N
N/* Uncomment the line(s) below to define used JTAG port(s). Leave all commented
N * if there is no JTAG ports */
N#if (((!defined(USE_MDR1986VE3)) || (!defined(USE_MDR1986VE1T))) && (defined(USE_MDR1986VE9x)))
X#if (((!0L) || (!0L)) && (1L))
N #define USE_JTAG_A 
N //#define USE_JTAG_B 
N#endif
N
N/* Target system parameters */
N/* RST_CLK generators frequencies in HZ */
N#define HSI_Value       ((uint32_t)8000000)
N#define HSE_Value       ((uint32_t)8000000)
N#define HSE2_Value      ((uint32_t)25000000)
N#define LSI_Value       ((uint32_t)40000)
N#define LSE_Value       ((uint32_t)32768)
N
N/* RST_CLK frequencies startup timeouts settings */
N#define HSEonTimeOut    ((uint16_t)0x0600)
N#define HSE2onTimeOut	((uint16_t)0x8000)
N#define LSEonTimeOut    ((uint16_t)0x0600)
N#define HSIonTimeOut    ((uint16_t)0x0600)
N#define LSIonTimeOut    ((uint16_t)0x0600)
N#define PLLCPUonTimeOut ((uint16_t)0x0600)
N#define PLLUSBonTimeOut ((uint16_t)0x0600)
N
N#define FLASH_PROG_FREQ_MHZ     (8.0)
N/* Use debug uart */
N#define _USE_DEBUG_UART_
N
N#if defined (_USE_DEBUG_UART_)
X#if 1L
N
N#if defined (USE_MDR1986VE3)
X#if 0L
S	#define DEBUG_UART 					MDR_UART2
S	#define DEBUG_UART_PORT				MDR_PORTD
S	#define DEBUG_UART_PINS				(PORT_Pin_13 | PORT_Pin_14)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_MAIN
S	#define DEBUG_BAUD_RATE				230400
S#elif defined (USE_MDR1986VE1T)
X#elif 0L
S	#define DEBUG_UART 					MDR_UART1
S	#define DEBUG_UART_PORT				MDR_PORTC
S	#define DEBUG_UART_PINS				(PORT_Pin_3 | PORT_Pin_4)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_MAIN
S	#define DEBUG_BAUD_RATE				230400
N#elif defined (USE_MDR1986VE9x)
X#elif 1L
N	#define DEBUG_UART 					MDR_UART2
N	#define DEBUG_UART_PORT				MDR_PORTF
N	#define DEBUG_UART_PINS				(PORT_Pin_0 | PORT_Pin_1)
N	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_OVERRID
N	#define DEBUG_BAUD_RATE				230400
N#endif
N
N//#define PRINTF_FORMAT_FULL
N//#define PRINTF_FORMAT_LARGE
N
N#endif /* #if defined (_USE_DEBUG_UART_) */
N
N#if defined ( USE_MDR1986VE3 ) || defined ( USE_MDR1986VE1T )
X#if 0L || 0L
S	#define MIL_STD_1553_TERMINAL_ADDRESS	0x01
N#endif /* #if defined ( USE_MDR1986VE3 ) || defined ( USE_MDR1986VE1T ) */
N
N/* RTC configuration parameters */
N#define RTC_CalibratorValue   	0
N#define RTC_PRESCALER_VALUE		32768
N
N/* DMA configuration parameters */
N/* Number of DMA channels to use */
N#define DMA_Channels_Number   32          /* This parameter is in range 1..32 */
N
N/* Alternate Control Data Structure Usage */
N/* This parameter can be a value of:
N    0 = DMA_ALternateDataDisabled;
N    1 = DMA_ALternateDataEnabled; */
N/*#define DMA_AlternateData   0 */          /* DMA_AlternateDataDisabled */
N#define DMA_AlternateData   1             /* DMA_AlternateDataEnabled */
N
N/* USB configuration parameters ----------------------------------------------*/
N/* Uncomment one of the lines below to select the Device Class. Leave all commented
N * if the desired device class is not currently supported by USB library */
N#define USB_DEVICE_CLASS  USB_DEVICE_CLASS_CDC
N
N/* USB Device management */
N/* Uncomment the line below to enable appropriate functionality. */
N/* #define USB_REMOTE_WAKEUP_SUPPORTED */
N/* #define USB_SELF_POWERED_SUPPORTED */
N
N/* Uncomment the line below to let the library provide USB interrupt handler.
N * Leave this line commented if you are willing to implement the handler yourself. */
N#define USB_INT_HANDLE_REQUIRED
N
N/* USB CDC management */
N/* Uncomment the lines below to enable appropriate functionality. */
N/* #define USB_CDC_STATE_REPORTING_SUPPORTED */
N/* #define USB_CDC_ENCAPSULATION_SUPPORTED */
N/* #define USB_CDC_COMM_FEATURE_SUPPORTED */
N#define USB_CDC_LINE_CODING_SUPPORTED
N/* #define USB_CDC_CONTROL_LINE_STATE_SUPPORTED */
N/* #define USB_CDC_LINE_BREAK_SUPPORTED */
N
N/* VCOM Echo example flags */
N
N/* Uncomment USB_VCOM_SYNC to enable "reliable delivery" mode: no new data
N * would be received (EP3 will reply NAK) until all previous data is sent
N * to host. */
N//#define USB_VCOM_SYNC
N
N/* Uncomment USB_DEBUG_PROTO to utilize the ring buffer for received setup
N * packets and send/receive byte counters (for debug purposes). */
N//#define USB_DEBUG_PROTO
N
N/* Known errors workaround control -------------------------------------------*/
N/* MDR32F9Qx Series Errata Notice, Error 0002 */
N#define WORKAROUND_MDR32F9QX_ERROR_0002
N
N/* Parameter run-time check support ------------------------------------------*/
N
N/* Select one of the following values of USE_ASSERT_INFO macro to control
N   parameter checking in the Standard Peripheral Library drivers:
N     0 - no parameter checks ("assert_param" macro is disabled);
N     1 - check enabled, source file ID and line number are available;
N     2 - check enabled, source file ID, line number and checking expression
N         (as string) are available (increased code size).
N*/
N #define USE_ASSERT_INFO    0 
N/* #define USE_ASSERT_INFO    1 */
N/* #define USE_ASSERT_INFO    2 */
N
N/**
N  * @brief  The assert_param macro is used for function's parameters check.
N  * @param  expr: If expr is false, it calls assert_failed user's function
N  *   which gets the source file ID (see MDR32F9Qx_lib.h), line number and
N  *   expression text (if USE_ASSERT_INFO == 2) of the call that failed. That
N  *   function should not return. If expr is true, nothing is done.
N  * @retval None
N  */
N#if (USE_ASSERT_INFO == 0)
X#if (0 == 0)
N  #define assert_param(expr) ((void)0)
N#elif (USE_ASSERT_INFO == 1)
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed(ASSERT_INFO_FILE_ID, __LINE__))
S  void assert_failed(uint32_t file_id, uint32_t line);
S#elif (USE_ASSERT_INFO == 2)
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed(ASSERT_INFO_FILE_ID, __LINE__, #expr))
S  void assert_failed(uint32_t file_id, uint32_t line, const uint8_t* expr);
S#else
S  #error "Unsupported USE_ASSERT_INFO level"
N#endif /* USE_ASSERT_INFO */
N
N#if defined (__ICCARM__)
X#if 0L
S	#define __attribute__(name_section)
S	#if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
S		#pragma section = "EXECUTABLE_MEMORY_SECTION"
S		#define IAR_SECTION(section) @ section
S	#elif defined (USE_MDR1986VE9x)
S		#define IAR_SECTION(section)
S	#endif
N#endif
N#if defined (__CMCARM__)
X#if 0L
S		#define __attribute__(name_section)
S		#define IAR_SECTION(section)
N#endif
N
N#endif /* __MDR32F9Qx_CONFIG_H */
N
N/******************* (C) COPYRIGHT 2011 Milandr *********************************
N*
N* END OF FILE MDR32F9Qx_config.h */
L 27 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\USB_Library\MDR32F9Qx_usb_device.c" 2
N#include "MDR32F9Qx_rst_clk.h"
L 1 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_rst_clk.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32F9Qx_rst_clk.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    23/09/2011
N  * @brief   This file contains all the functions prototypes for the RST_CLK
N  *          firmware library.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32F9Qx_rst_clk.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_RST_CLK_H
N#define __MDR32F9Qx_RST_CLK_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_lib.h"
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup RST_CLK
N  * @{
N  */
N
N/** @defgroup RST_CLK_Exported_Types RST_CLK Exported Types
N  * @{
N  */
N
N/**
N  * @brief Structure type for modules clocks frequencies expressed in Hz
N  */
N
Ntypedef struct
N{
N  uint32_t CPU_CLK_Frequency;
N  uint32_t USB_CLK_Frequency;
N  uint32_t ADC_CLK_Frequency;
N  uint32_t RTCHSI_Frequency;
N  uint32_t RTCHSE_Frequency;
N}RST_CLK_FreqTypeDef;
N
N/**
N  * @brief RST_CLK unit non-volatile settings init structure
N  */
N
Ntypedef struct {
N     uint32_t REG_0F;
N} Init_NonVolatile_RST_CLK_TypeDef;
N
N/** @} */ /* End of group RST_CLK_Exported_Types */
N
N/** @defgroup RST_CLK_Exported_Constants RST_CLK Exported Constants
N  * @{
N  */
N
N/** @defgroup HSE_configuration HSE configuration
N  * @{
N  */
N
N/**
N  * @brief RST_CLK HSE (High Speed External) clock mode and source selection constants
N  */
N
N#define RST_CLK_HSE_OFF                      ((uint32_t)0x00000000)
N#define RST_CLK_HSE_ON                       ((uint32_t)0x00000001)
N#define RST_CLK_HSE_Bypass                   ((uint32_t)0x00000002)
N
N#define IS_RST_CLK_HSE(HSE)                  (((HSE) == RST_CLK_HSE_OFF) || \
N                                              ((HSE) == RST_CLK_HSE_ON)  || \
N                                              ((HSE) == RST_CLK_HSE_Bypass))
X#define IS_RST_CLK_HSE(HSE)                  (((HSE) == RST_CLK_HSE_OFF) ||                                               ((HSE) == RST_CLK_HSE_ON)  ||                                               ((HSE) == RST_CLK_HSE_Bypass))
N
N/** @} */ /* End of group HSE_configuration */
N
N
N#if defined  (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
X#if 0L || 0L
S/** @defgroup HSE2_configuration HSE2 configuration
S *  @{
S */
S
S/**
S  * @brief RST_CLK HSE2 (High Speed External 2 ) clock mode and source selection constants
S  */
S
S#define RST_CLK_HSE2_OFF						((uint32_t)0x00000000)
S#define RST_CLK_HSE2_ON							((uint32_t)0x00000004)
S#define RST_CLK_HSE2_Bypass						((uint32_t)0x00000008)
S
S#define IS_RST_CLK_HSE2(HSE2)                  	(((HSE2) == RST_CLK_HSE2_OFF) || \
S                                              	 ((HSE2) == RST_CLK_HSE2_ON)  || \
S                                              	 ((HSE2) == RST_CLK_HSE2_Bypass))
X#define IS_RST_CLK_HSE2(HSE2)                  	(((HSE2) == RST_CLK_HSE2_OFF) ||                                               	 ((HSE2) == RST_CLK_HSE2_ON)  ||                                               	 ((HSE2) == RST_CLK_HSE2_Bypass))
S
S/** @} */ /* End of group HSE2_configuration */
S
N#endif /* #if defined  (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) */
N
N/** @defgroup LSE_configuration LSE configuration
N  * @{
N  */
N
N/**
N  * @brief RST_CLK LSE (Low Speed External) clock mode and source selection constants
N  */
N
N#define RST_CLK_LSE_OFF                      ((uint32_t)0x00000000)
N#define RST_CLK_LSE_ON                       ((uint32_t)0x00000001)
N#define RST_CLK_LSE_Bypass                   ((uint32_t)0x00000002)
N
N#define IS_RST_CLK_LSE(LSE)                  (((LSE) == RST_CLK_LSE_OFF) || \
N                                              ((LSE) == RST_CLK_LSE_ON)  || \
N                                              ((LSE) == RST_CLK_LSE_Bypass))
X#define IS_RST_CLK_LSE(LSE)                  (((LSE) == RST_CLK_LSE_OFF) ||                                               ((LSE) == RST_CLK_LSE_ON)  ||                                               ((LSE) == RST_CLK_LSE_Bypass))
N
N/** @} */ /* End of group LSE_configuration */
N
N/** @defgroup CPU_PLL_entry_clock_source CPU PLL entry clock source
N  * @{
N  */
N
N/**
N  * @brief RST_CLK CPU_PLL clock mode and source selection constants
N  */
N
N#define RST_CLK_CPU_PLLsrcHSIdiv1           ((uint32_t)0x00000000)
N#define RST_CLK_CPU_PLLsrcHSIdiv2           ((uint32_t)0x00000001)
N#define RST_CLK_CPU_PLLsrcHSEdiv1           ((uint32_t)0x00000002)
N#define RST_CLK_CPU_PLLsrcHSEdiv2           ((uint32_t)0x00000003)
N
N#define IS_RST_CLK_CPU_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_CPU_PLLsrcHSIdiv1) || \
N                                             ((SRC) == RST_CLK_CPU_PLLsrcHSIdiv2) || \
N                                             ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv1) || \
N                                             ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv2))
X#define IS_RST_CLK_CPU_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_CPU_PLLsrcHSIdiv1) ||                                              ((SRC) == RST_CLK_CPU_PLLsrcHSIdiv2) ||                                              ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv1) ||                                              ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv2))
N
N/** @} */ /* End of group CPU_PLL_entry_clock_source */
N
N/** @defgroup CPU_PLL_clock_multiplier CPU_PLL clock multiplier
N  * @{
N  */
N
N/**
N  * @brief RST_CLK PLL_CPU_MUL multiplier of the CPU_C1 clock constants
N  */
N
N#define RST_CLK_CPU_PLLmul1                     ((uint32_t)0x00000000)
N#define RST_CLK_CPU_PLLmul2                     ((uint32_t)0x00000001)
N#define RST_CLK_CPU_PLLmul3                     ((uint32_t)0x00000002)
N#define RST_CLK_CPU_PLLmul4                     ((uint32_t)0x00000003)
N#define RST_CLK_CPU_PLLmul5                     ((uint32_t)0x00000004)
N#define RST_CLK_CPU_PLLmul6                     ((uint32_t)0x00000005)
N#define RST_CLK_CPU_PLLmul7                     ((uint32_t)0x00000006)
N#define RST_CLK_CPU_PLLmul8                     ((uint32_t)0x00000007)
N#define RST_CLK_CPU_PLLmul9                     ((uint32_t)0x00000008)
N#define RST_CLK_CPU_PLLmul10                    ((uint32_t)0x00000009)
N#define RST_CLK_CPU_PLLmul11                    ((uint32_t)0x0000000A)
N#define RST_CLK_CPU_PLLmul12                    ((uint32_t)0x0000000B)
N#define RST_CLK_CPU_PLLmul13                    ((uint32_t)0x0000000C)
N#define RST_CLK_CPU_PLLmul14                    ((uint32_t)0x0000000D)
N#define RST_CLK_CPU_PLLmul15                    ((uint32_t)0x0000000E)
N#define RST_CLK_CPU_PLLmul16                    ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_CPU_PLL_MUL(SRC)             ((SRC>=0) && (SRC<16))
N
N/** @} */ /* End of group CPU_PLL_clock_multiplier */
N
N
N/** @defgroup USB_PLL_entry_clock_source USB PLL entry clock source
N  * @{
N  */
N
N/**
N  * @brief RST_CLK USB_PLL clock mode and source selection constants
N  */
N
N#define RST_CLK_USB_PLLsrcHSIdiv1           ((uint32_t)0x00000000)
N#define RST_CLK_USB_PLLsrcHSIdiv2           ((uint32_t)0x00000001)
N#define RST_CLK_USB_PLLsrcHSEdiv1           ((uint32_t)0x00000002)
N#define RST_CLK_USB_PLLsrcHSEdiv2           ((uint32_t)0x00000003)
N
N#define IS_RST_CLK_USB_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_USB_PLLsrcHSIdiv1) ||\
N                                             ((SRC) == RST_CLK_USB_PLLsrcHSIdiv2) ||\
N                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv1) ||\
N                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv2))
X#define IS_RST_CLK_USB_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_USB_PLLsrcHSIdiv1) ||                                             ((SRC) == RST_CLK_USB_PLLsrcHSIdiv2) ||                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv1) ||                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv2))
N
N/** @} */ /* End of group USB_PLL_entry_clock_source */
N
N/** @defgroup USB_PLL_clock_multiplier USB_PLL clock multiplier
N  * @{
N  */
N
N/**
N  * @brief RST_CLK USB_C1 clock PLL_USB_MUL multiplier constants
N  */
N
N#define RST_CLK_USB_PLLmul1                     ((uint32_t)0x00000000)
N#define RST_CLK_USB_PLLmul2                     ((uint32_t)0x00000001)
N#define RST_CLK_USB_PLLmul3                     ((uint32_t)0x00000002)
N#define RST_CLK_USB_PLLmul4                     ((uint32_t)0x00000003)
N#define RST_CLK_USB_PLLmul5                     ((uint32_t)0x00000004)
N#define RST_CLK_USB_PLLmul6                     ((uint32_t)0x00000005)
N#define RST_CLK_USB_PLLmul7                     ((uint32_t)0x00000006)
N#define RST_CLK_USB_PLLmul8                     ((uint32_t)0x00000007)
N#define RST_CLK_USB_PLLmul9                     ((uint32_t)0x00000008)
N#define RST_CLK_USB_PLLmul10                    ((uint32_t)0x00000009)
N#define RST_CLK_USB_PLLmul11                    ((uint32_t)0x0000000A)
N#define RST_CLK_USB_PLLmul12                    ((uint32_t)0x0000000B)
N#define RST_CLK_USB_PLLmul13                    ((uint32_t)0x0000000C)
N#define RST_CLK_USB_PLLmul14                    ((uint32_t)0x0000000D)
N#define RST_CLK_USB_PLLmul15                    ((uint32_t)0x0000000E)
N#define RST_CLK_USB_PLLmul16                    ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_USB_PLL_MUL(SRC)             ((SRC>=0) && (SRC<16))
N
N/** @} */ /* End of group USB_PLL_clock_multiplier */
N
N
N/** @defgroup CPU_CLK_divider CPU CLK divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK CPU_PLL output clock CPU_CLK_DIV divider constants
N  */
N
N#define RST_CLK_CPUclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_CPUclkDIV2                    ((uint32_t)0x00000008)
N#define RST_CLK_CPUclkDIV4                    ((uint32_t)0x00000009)
N#define RST_CLK_CPUclkDIV8                    ((uint32_t)0x0000000A)
N#define RST_CLK_CPUclkDIV16                   ((uint32_t)0x0000000B)
N#define RST_CLK_CPUclkDIV32                   ((uint32_t)0x0000000C)
N#define RST_CLK_CPUclkDIV64                   ((uint32_t)0x0000000D)
N#define RST_CLK_CPUclkDIV128                  ((uint32_t)0x0000000E)
N#define RST_CLK_CPUclkDIV256                  ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_CPUclkDIV(DIV)             (((DIV) == RST_CLK_CPUclkDIV1)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV2)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV4)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV8)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV16)  || \
N                                               ((DIV) == RST_CLK_CPUclkDIV32)  || \
N                                               ((DIV) == RST_CLK_CPUclkDIV64)  || \
N                                               ((DIV) == RST_CLK_CPUclkDIV128) || \
N                                               ((DIV) == RST_CLK_CPUclkDIV256))
X#define IS_RST_CLK_CPUclkDIV(DIV)             (((DIV) == RST_CLK_CPUclkDIV1)   ||                                                ((DIV) == RST_CLK_CPUclkDIV2)   ||                                                ((DIV) == RST_CLK_CPUclkDIV4)   ||                                                ((DIV) == RST_CLK_CPUclkDIV8)   ||                                                ((DIV) == RST_CLK_CPUclkDIV16)  ||                                                ((DIV) == RST_CLK_CPUclkDIV32)  ||                                                ((DIV) == RST_CLK_CPUclkDIV64)  ||                                                ((DIV) == RST_CLK_CPUclkDIV128) ||                                                ((DIV) == RST_CLK_CPUclkDIV256))
N
N/** @} */ /* End of group CPU_CLK_divider */
N
N/** @defgroup CPU_CLK_selector CPU CLK selector
N  * @{
N  */
N
N/**
N  * @brief RST_CLK CPU_CLK source CPU_CLK selector constants
N  */
N
N#define RST_CLK_CPUclkHSI                     ((uint32_t)0x00000000)
N#define RST_CLK_CPUclkCPU_C3                  ((uint32_t)0x00000100)
N#define RST_CLK_CPUclkLSE                     ((uint32_t)0x00000200)
N#define RST_CLK_CPUclkLSI                     ((uint32_t)0x00000300)
N
N#define IS_RST_CPU_CLK(SRC)                   (((SRC) == RST_CLK_CPUclkHSI)    || \
N                                               ((SRC) == RST_CLK_CPUclkCPU_C3) || \
N                                               ((SRC) == RST_CLK_CPUclkLSE)    || \
N                                               ((SRC) == RST_CLK_CPUclkLSI))
X#define IS_RST_CPU_CLK(SRC)                   (((SRC) == RST_CLK_CPUclkHSI)    ||                                                ((SRC) == RST_CLK_CPUclkCPU_C3) ||                                                ((SRC) == RST_CLK_CPUclkLSE)    ||                                                ((SRC) == RST_CLK_CPUclkLSI))
N
N/** @} */ /* End of group CPU_CLK_selector */
N
N/** @defgroup ADC_MCO_CLOCK_source ADC clock source
N  * @{
N  */
N
N/**
N  * @brief RST_CLK ADC_CLK selector constants
N  */
N#define RST_CLK_ADCclkCPU_C1                  ((uint32_t)0x00000020)
N#define RST_CLK_ADCclkUSB_C1                  ((uint32_t)0x00000021)
N#define RST_CLK_ADCclkCPU_C2                  ((uint32_t)0x00000022)
N#define RST_CLK_ADCclkUSB_C2                  ((uint32_t)0x00000023)
N#define RST_CLK_ADCclkLSE                     ((uint32_t)0x00000000)
N#define RST_CLK_ADCclkLSI                     ((uint32_t)0x00000010)
N#define RST_CLK_ADCclkHSI_C1                  ((uint32_t)0x00000030)
N
N#define IS_RST_CLK_ADCclk(SRC)                (((SRC) == RST_CLK_ADCclkCPU_C1) || \
N                                               ((SRC) == RST_CLK_ADCclkUSB_C1) || \
N                                               ((SRC) == RST_CLK_ADCclkCPU_C2) || \
N                                               ((SRC) == RST_CLK_ADCclkUSB_C2) || \
N                                               ((SRC) == RST_CLK_ADCclkLSE)    || \
N                                               ((SRC) == RST_CLK_ADCclkLSI)    || \
N                                               ((SRC) == RST_CLK_ADCclkHSI_C1))
X#define IS_RST_CLK_ADCclk(SRC)                (((SRC) == RST_CLK_ADCclkCPU_C1) ||                                                ((SRC) == RST_CLK_ADCclkUSB_C1) ||                                                ((SRC) == RST_CLK_ADCclkCPU_C2) ||                                                ((SRC) == RST_CLK_ADCclkUSB_C2) ||                                                ((SRC) == RST_CLK_ADCclkLSE)    ||                                                ((SRC) == RST_CLK_ADCclkLSI)    ||                                                ((SRC) == RST_CLK_ADCclkHSI_C1))
N/** @} */ /* End of group ADC_MCO_CLOCK_source */
N
N/** @defgroup ADC_MCO_CS3_SEL ADC clock divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK ADC_CS2_SEL output clock ADC_CS3_SEL divider constants
N  */
N
N#define RST_CLK_ADCclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_ADCclkDIV2                    ((uint32_t)0x00000008)
N#define RST_CLK_ADCclkDIV4                    ((uint32_t)0x00000009)
N#define RST_CLK_ADCclkDIV8                    ((uint32_t)0x0000000A)
N#define RST_CLK_ADCclkDIV16                   ((uint32_t)0x0000000B)
N#define RST_CLK_ADCclkDIV32                   ((uint32_t)0x0000000C)
N#define RST_CLK_ADCclkDIV64                   ((uint32_t)0x0000000D)
N#define RST_CLK_ADCclkDIV128                  ((uint32_t)0x0000000E)
N#define RST_CLK_ADCclkDIV256                  ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_ADCclkDivValue(SRC)        (((SRC) == RST_CLK_ADCclkDIV1)    || \
N                                               ((SRC) == RST_CLK_ADCclkDIV2)    || \
N                                               ((SRC) == RST_CLK_ADCclkDIV4)    || \
N                                               ((SRC) == RST_CLK_ADCclkDIV8)    || \
N                                               ((SRC) == RST_CLK_ADCclkDIV16)   || \
N                                               ((SRC) == RST_CLK_ADCclkDIV32)   || \
N                                               ((SRC) == RST_CLK_ADCclkDIV64)   || \
N                                               ((SRC) == RST_CLK_ADCclkDIV128)  || \
N                                               ((SRC) == RST_CLK_ADCclkDIV256))
X#define IS_RST_CLK_ADCclkDivValue(SRC)        (((SRC) == RST_CLK_ADCclkDIV1)    ||                                                ((SRC) == RST_CLK_ADCclkDIV2)    ||                                                ((SRC) == RST_CLK_ADCclkDIV4)    ||                                                ((SRC) == RST_CLK_ADCclkDIV8)    ||                                                ((SRC) == RST_CLK_ADCclkDIV16)   ||                                                ((SRC) == RST_CLK_ADCclkDIV32)   ||                                                ((SRC) == RST_CLK_ADCclkDIV64)   ||                                                ((SRC) == RST_CLK_ADCclkDIV128)  ||                                                ((SRC) == RST_CLK_ADCclkDIV256))
N
N/** @} */ /* End of group ADC_MCO_CS3_SEL */
N
N/** @defgroup AUC_MCO_CLOCK_source AUC clock source
N *  @{
N */
N
N/**
N * @brief RST_CLK AUC_CLK selector constants
N */
N#define RST_CLK_AUCclkHSI_C1						((uint32_t)0x00000000)
N#define RST_CLK_AUCclkHSI_2_C1						((uint32_t)0x00010000)
N#define RST_CLK_AUCclkHSE_C1						((uint32_t)0x00020000)
N#define RST_CLK_AUCclkHSE_2_C1						((uint32_t)0x00030000)
N#define RST_CLK_AUCclkPLLCPU						((uint32_t)0x00100000)
N#define RST_CLK_AUCclkPLLUSB						((uint32_t)0x00200000)
N
N#define IS_RST_CLK_AUCclk(SRC)						(((SRC) == RST_CLK_AUCclkHSI_C1)   || \
N													 ((SRC) == RST_CLK_AUCclkHSI_2_C1) || \
N													 ((SRC) == RST_CLK_AUCclkHSE_C1)   || \
N													 ((SRC) == RST_CLK_AUCclkHSE_2_C1) || \
N													 ((SRC) == RST_CLK_AUCclkPLLCPU)   || \
N													 ((SRC) == RST_CLK_AUCclkPLLUSB))
X#define IS_RST_CLK_AUCclk(SRC)						(((SRC) == RST_CLK_AUCclkHSI_C1)   || 													 ((SRC) == RST_CLK_AUCclkHSI_2_C1) || 													 ((SRC) == RST_CLK_AUCclkHSE_C1)   || 													 ((SRC) == RST_CLK_AUCclkHSE_2_C1) || 													 ((SRC) == RST_CLK_AUCclkPLLCPU)   || 													 ((SRC) == RST_CLK_AUCclkPLLUSB))
N/** @} */ /* End of group AUC_MCO_CLOCK_source */
N
N/** @defgroup AUCclkDIV_divider AUC MCO divider
N *	@{
N */
N
N /**
N  * @brief AUC_MCO_CLK AUC_CLK output clock AUC_CLK_DIV divider
N  */
N#define RST_CLK_AUCclkDIV1							((uint32_t)0x00000000)
N#define RST_CLK_AUCclkDIV2							((uint32_t)0x08000000 | 0x00000000)
N#define RST_CLK_AUCclkDIV4							((uint32_t)0x08000000 | 0x01000000)
N#define RST_CLK_AUCclkDIV8							((uint32_t)0x08000000 | 0x02000000)
N#define RST_CLK_AUCclkDIV16							((uint32_t)0x08000000 | 0x03000000)
N#define RST_CLK_AUCclkDIV32							((uint32_t)0x08000000 | 0x04000000)
N#define RST_CLK_AUCclkDIV64							((uint32_t)0x08000000 | 0x05000000)
N#define RST_CLK_AUCclkDIV128						((uint32_t)0x08000000 | 0x06000000)
N#define RST_CLK_AUCclkDIV256						((uint32_t)0x08000000 | 0x07000000)
N
N#define IS_RST_CLK_AUCclkDIV(DIV)					(((DIV) == RST_CLK_AUCclkDIV1)   || \
N													 ((DIV) == RST_CLK_AUCclkDIV2)   || \
N													 ((DIV) == RST_CLK_AUCclkDIV4)   || \
N													 ((DIV) == RST_CLK_AUCclkDIV8)   || \
N													 ((DIV) == RST_CLK_AUCclkDIV16)  || \
N													 ((DIV) == RST_CLK_AUCclkDIV32)  || \
N													 ((DIV) == RST_CLK_AUCclkDIV64)  || \
N													 ((DIV) == RST_CLK_AUCclkDIV128) || \
N													 ((DIV) == RST_CLK_AUCclkDIV256))
X#define IS_RST_CLK_AUCclkDIV(DIV)					(((DIV) == RST_CLK_AUCclkDIV1)   || 													 ((DIV) == RST_CLK_AUCclkDIV2)   || 													 ((DIV) == RST_CLK_AUCclkDIV4)   || 													 ((DIV) == RST_CLK_AUCclkDIV8)   || 													 ((DIV) == RST_CLK_AUCclkDIV16)  || 													 ((DIV) == RST_CLK_AUCclkDIV32)  || 													 ((DIV) == RST_CLK_AUCclkDIV64)  || 													 ((DIV) == RST_CLK_AUCclkDIV128) || 													 ((DIV) == RST_CLK_AUCclkDIV256))
N/** @} */ /* End of group AUCclkDIV_divider */
N
N
N/** @defgroup CLK_peripheral CLK peripheral
N  * @{
N  */
N
N/**
N  * @brief RST_CLK peripheral modules clock constants
N  */
N
N#define PCLK_BIT(BASE)              ((uint32_t)(1 << ((((uint32_t)BASE) >> 15) & 0x1F)))
N#if defined USE_MDR1986VE3
X#if 0L
S	#define PCLK_BIT2(BASE)				((uint32_t)(1 << ((((uint32_t)BASE) >> 15) & 0x0F)))
N#endif
N
N#ifdef USE_MDR1986VE9x /* For cortex M3 */
N
N	#define RST_CLK_PCLK_CAN1           PCLK_BIT(MDR_CAN1_BASE)
N	#define RST_CLK_PCLK_CAN2           PCLK_BIT(MDR_CAN2_BASE)
N	#define RST_CLK_PCLK_USB            PCLK_BIT(MDR_USB_BASE)
N	#define RST_CLK_PCLK_EEPROM         PCLK_BIT(MDR_EEPROM_BASE)
N	#define RST_CLK_PCLK_RST_CLK        PCLK_BIT(MDR_RST_CLK_BASE)
N	#define RST_CLK_PCLK_DMA            PCLK_BIT(MDR_DMA_BASE)
N	#define RST_CLK_PCLK_UART1          PCLK_BIT(MDR_UART1_BASE)
N	#define RST_CLK_PCLK_UART2          PCLK_BIT(MDR_UART2_BASE)
N	#define RST_CLK_PCLK_SSP1           PCLK_BIT(MDR_SSP1_BASE)
N	#define RST_CLK_PCLK_09             PCLK_BIT(0x40048000)
N	#define RST_CLK_PCLK_I2C            PCLK_BIT(MDR_I2C_BASE)
N	#define RST_CLK_PCLK_POWER          PCLK_BIT(MDR_POWER_BASE)
N	#define RST_CLK_PCLK_WWDG           PCLK_BIT(MDR_WWDG_BASE)
N	#define RST_CLK_PCLK_IWDG           PCLK_BIT(MDR_IWDG_BASE)
N	#define RST_CLK_PCLK_TIMER1         PCLK_BIT(MDR_TIMER1_BASE)
N	#define RST_CLK_PCLK_TIMER2         PCLK_BIT(MDR_TIMER2_BASE)
N	#define RST_CLK_PCLK_TIMER3         PCLK_BIT(MDR_TIMER3_BASE)
N	#define RST_CLK_PCLK_ADC            PCLK_BIT(MDR_ADC_BASE)
N	#define RST_CLK_PCLK_DAC            PCLK_BIT(MDR_DAC_BASE)
N	#define RST_CLK_PCLK_COMP           PCLK_BIT(MDR_COMP_BASE)
N	#define RST_CLK_PCLK_SSP2           PCLK_BIT(MDR_SSP2_BASE)
N	#define RST_CLK_PCLK_PORTA          PCLK_BIT(MDR_PORTA_BASE)
N	#define RST_CLK_PCLK_PORTB          PCLK_BIT(MDR_PORTB_BASE)
N	#define RST_CLK_PCLK_PORTC          PCLK_BIT(MDR_PORTC_BASE)
N	#define RST_CLK_PCLK_PORTD          PCLK_BIT(MDR_PORTD_BASE)
N	#define RST_CLK_PCLK_PORTE          PCLK_BIT(MDR_PORTE_BASE)
N	#define RST_CLK_PCLK_26             PCLK_BIT(0x400D0000)
N	#define RST_CLK_PCLK_BKP            PCLK_BIT(MDR_BKP_BASE)
N	#define RST_CLK_PCLK_28             PCLK_BIT(0x400E0000)
N	#define RST_CLK_PCLK_PORTF          PCLK_BIT(MDR_PORTF_BASE)
N	#define RST_CLK_PCLK_EBC            PCLK_BIT(MDR_EBC_BASE)
N	#define RST_CLK_PCLK_31             PCLK_BIT(0x400F8000)
N
N	#define IS_RST_CLK_PCLK(PCLK)       ((((PCLK) & RST_CLK_PCLK_09) == 0x00) && \
N										 (((PCLK) & RST_CLK_PCLK_26) == 0x00) && \
N										 (((PCLK) & RST_CLK_PCLK_28) == 0x00) && \
N										 (((PCLK) & RST_CLK_PCLK_31) == 0x00))
X	#define IS_RST_CLK_PCLK(PCLK)       ((((PCLK) & RST_CLK_PCLK_09) == 0x00) && 										 (((PCLK) & RST_CLK_PCLK_26) == 0x00) && 										 (((PCLK) & RST_CLK_PCLK_28) == 0x00) && 										 (((PCLK) & RST_CLK_PCLK_31) == 0x00))
N#endif // #ifdef USE_MDR1986VE9x /* For cortex M3 */
N
N#if defined (USE_MDR1986VE1T)
X#if 0L
S	#define RST_CLK_PCLK_CAN1           PCLK_BIT(MDR_CAN1_BASE)
S	#define RST_CLK_PCLK_CAN2           PCLK_BIT(MDR_CAN2_BASE)
S	#define RST_CLK_PCLK_USB            PCLK_BIT(MDR_USB_BASE)
S	#define RST_CLK_PCLK_EEPROM         PCLK_BIT(MDR_EEPROM_BASE)
S	#define RST_CLK_PCLK_RST_CLK        PCLK_BIT(MDR_RST_CLK_BASE)
S	#define RST_CLK_PCLK_DMA            PCLK_BIT(MDR_DMA_BASE)
S	#define RST_CLK_PCLK_UART1          PCLK_BIT(MDR_UART1_BASE)
S	#define RST_CLK_PCLK_UART2          PCLK_BIT(MDR_UART2_BASE)
S	#define RST_CLK_PCLK_SSP1           PCLK_BIT(MDR_SSP1_BASE)
S	#define RST_CLK_PCLK_MIL_STD_15531  PCLK_BIT(MDR_MIL_STD_15531_BASE)
S	#define RST_CLK_PCLK_MIL_STD_15532  PCLK_BIT(MDR_MIL_STD_15532_BASE)
S	#define RST_CLK_PCLK_POWER          PCLK_BIT(MDR_POWER_BASE)
S	#define RST_CLK_PCLK_WWDG           PCLK_BIT(MDR_WWDG_BASE)
S	#define RST_CLK_PCLK_IWDG           PCLK_BIT(MDR_IWDG_BASE)
S	#define RST_CLK_PCLK_TIMER1         PCLK_BIT(MDR_TIMER1_BASE)
S	#define RST_CLK_PCLK_TIMER2         PCLK_BIT(MDR_TIMER2_BASE)
S	#define RST_CLK_PCLK_TIMER3         PCLK_BIT(MDR_TIMER3_BASE)
S	#define RST_CLK_PCLK_ADC            PCLK_BIT(MDR_ADC_BASE)
S	#define RST_CLK_PCLK_DAC            PCLK_BIT(MDR_DAC_BASE)
S	#define RST_CLK_PCLK_TIMER4         PCLK_BIT(MDR_TIMER4_BASE)
S	#define RST_CLK_PCLK_SSP2           PCLK_BIT(MDR_SSP2_BASE)
S	#define RST_CLK_PCLK_PORTA          PCLK_BIT(MDR_PORTA_BASE)
S	#define RST_CLK_PCLK_PORTB          PCLK_BIT(MDR_PORTB_BASE)
S	#define RST_CLK_PCLK_PORTC          PCLK_BIT(MDR_PORTC_BASE)
S	#define RST_CLK_PCLK_PORTD          PCLK_BIT(MDR_PORTD_BASE)
S	#define RST_CLK_PCLK_PORTE          PCLK_BIT(MDR_PORTE_BASE)
S	#define RST_CLK_PCLK_ARINC429R      PCLK_BIT(MDR_ARINC429R_BASE)
S	#define RST_CLK_PCLK_BKP            PCLK_BIT(MDR_BKP_BASE)
S	#define RST_CLK_PCLK_ARINC429T      PCLK_BIT(MDR_ARINC429T_BASE)
S	#define RST_CLK_PCLK_PORTF          PCLK_BIT(MDR_PORTF_BASE)
S	#define RST_CLK_PCLK_EBC            PCLK_BIT(MDR_EBC_BASE)
S	#define RST_CLK_PCLK_SSP3           PCLK_BIT(MDR_SSP3_BASE)
S
S#define IS_RST_CLK_PCLK(PCLK)			(1)
N#endif /* #if defined (USE_MDR1986VE1T) */
N
N#ifdef USE_MDR1986VE3 /* For Coxtex M1 */
S	#define RST_CLK_PCLK_CAN1           PCLK_BIT(MDR_CAN1_BASE)
S	#define RST_CLK_PCLK_CAN2           PCLK_BIT(MDR_CAN2_BASE)
S	#define RST_CLK_PCLK_USB            PCLK_BIT(MDR_USB_BASE)
S	#define RST_CLK_PCLK_EEPROM         PCLK_BIT(MDR_EEPROM_BASE)
S	#define RST_CLK_PCLK_RST_CLK        PCLK_BIT(MDR_RST_CLK_BASE)
S	#define RST_CLK_PCLK_DMA            PCLK_BIT(MDR_DMA_BASE)
S	#define RST_CLK_PCLK_UART1          PCLK_BIT(MDR_UART1_BASE)
S	#define RST_CLK_PCLK_UART2          PCLK_BIT(MDR_UART2_BASE)
S	#define RST_CLK_PCLK_SSP1           PCLK_BIT(MDR_SSP1_BASE)
S	#define RST_CLK_PCLK_MIL_STD_15531  PCLK_BIT(MDR_MIL_STD_15531_BASE)
S	#define RST_CLK_PCLK_MIL_STD_15532  PCLK_BIT(MDR_MIL_STD_15532_BASE)
S	#define RST_CLK_PCLK_POWER          PCLK_BIT(MDR_POWER_BASE)
S	#define RST_CLK_PCLK_WWDG           PCLK_BIT(MDR_WWDG_BASE)
S	#define RST_CLK_PCLK_IWDG           PCLK_BIT(MDR_IWDG_BASE)
S	#define RST_CLK_PCLK_TIMER1         PCLK_BIT(MDR_TIMER1_BASE)
S	#define RST_CLK_PCLK_TIMER2         PCLK_BIT(MDR_TIMER2_BASE)
S	#define RST_CLK_PCLK_TIMER3         PCLK_BIT(MDR_TIMER3_BASE)
S	#define RST_CLK_PCLK_ADC            PCLK_BIT(MDR_ADC_BASE)
S	#define RST_CLK_PCLK_DAC            PCLK_BIT(MDR_DAC_BASE)
S	#define RST_CLK_PCLK_TIMER4         PCLK_BIT(MDR_TIMER4_BASE)
S	#define RST_CLK_PCLK_SSP2           PCLK_BIT(MDR_SSP2_BASE)
S	#define RST_CLK_PCLK_PORTA          PCLK_BIT(MDR_PORTA_BASE)
S	#define RST_CLK_PCLK_PORTB          PCLK_BIT(MDR_PORTB_BASE)
S	#define RST_CLK_PCLK_PORTC          PCLK_BIT(MDR_PORTC_BASE)
S	#define RST_CLK_PCLK_PORTD          PCLK_BIT(MDR_PORTD_BASE)
S	#define RST_CLK_PCLK_PORTE          PCLK_BIT(MDR_PORTE_BASE)
S	#define RST_CLK_PCLK_ARINC429R      PCLK_BIT(MDR_ARINC429R_BASE)
S	#define RST_CLK_PCLK_BKP            PCLK_BIT(MDR_BKP_BASE)
S	#define RST_CLK_PCLK_ARINC429T      PCLK_BIT(MDR_ARINC429T_BASE)
S	#define RST_CLK_PCLK_PORTF          PCLK_BIT(MDR_PORTF_BASE)
S	#define RST_CLK_PCLK_EBC            PCLK_BIT(MDR_EBC_BASE)
S	#define RST_CLK_PCLK_SSP3           PCLK_BIT(MDR_SSP3_BASE)
S
S	#define RST_CLK_PCLK2_AUDIO_IP		PCLK_BIT2(MDR_AUDIO_IP_BASE)
S	#define RST_CLK_PCLK2_LED			PCLK_BIT2(MDR_LED_BASE)
S	#define RST_CLK_PCLK2_KEYBOARD		PCLK_BIT2(MDR_KEYPAD_BASE)
S	#define RST_CLK_PCLK2_PORTG			PCLK_BIT2(MDR_PORTG_BASE)
S	#define RST_CLK_PCLK2_UART3			PCLK_BIT2(MDR_UART3_BASE)
S	#define RST_CLK_PCLK2_UART4			PCLK_BIT2(MDR_UART4_BASE)
S	#define RST_CLK_PCLK2_SSP4			PCLK_BIT2(MDR_SSP4_BASE)
S	#define RST_CLK_PCLK2_PORTH			PCLK_BIT2(MDR_PORTH_BASE)
S	#define RST_CLK_PCLK2_PORTI			PCLK_BIT2(MDR_PORTI_BASE)
S
S	#define RST_CLK_PCLK2_MASK			(RST_CLK_PCLK2_AUDIO_IP | RST_CLK_PCLK2_KEYBOARD |\
S										 RST_CLK_PCLK2_LED 		| RST_CLK_PCLK2_UART3 	 |\
S										 RST_CLK_PCLK2_UART4	| RST_CLK_PCLK2_SSP4 	 |\
S										 RST_CLK_PCLK2_PORTH 	| RST_CLK_PCLK2_PORTI | RST_CLK_PCLK2_PORTG)
X	#define RST_CLK_PCLK2_MASK			(RST_CLK_PCLK2_AUDIO_IP | RST_CLK_PCLK2_KEYBOARD |										 RST_CLK_PCLK2_LED 		| RST_CLK_PCLK2_UART3 	 |										 RST_CLK_PCLK2_UART4	| RST_CLK_PCLK2_SSP4 	 |										 RST_CLK_PCLK2_PORTH 	| RST_CLK_PCLK2_PORTI | RST_CLK_PCLK2_PORTG)
S
S	#define IS_RST_CLK_PCLK(PCLK)       (1)
S	#define IS_RST_CLK_PCLK2(PCLK2)		(PLCK2 & (~RST_CLK_PCLK2_MASK) == 0)
S
S
N#endif // #ifdef USE_MDR1986VE3 /* For Coxtex M1 */
N
N/** @} */ /* End of group CLK_peripheral */
N
N/** @defgroup RST_CLK_Flag RST_CLK Flag
N  * @{
N  */
N
N/**
N  * @brief RST_CLK flag identifiers
N  */
N
N#define RST_CLK_FLAG_HSIRDY                   ((uint32_t)(0x00 | 23))
N#define RST_CLK_FLAG_LSIRDY                   ((uint32_t)(0x00 | 21))
N#define RST_CLK_FLAG_HSERDY                   ((uint32_t)(0x20 |  2))
N#define RST_CLK_FLAG_HSE2RDY	           	  ((uint32_t)(0x20 |  3))
N#define RST_CLK_FLAG_LSERDY                   ((uint32_t)(0x00 | 13))
N#define RST_CLK_FLAG_PLLCPURDY                ((uint32_t)(0x20 |  1))
N#define RST_CLK_FLAG_PLLUSBRDY                ((uint32_t)(0x20 |  0))
N
N#define IS_RST_CLK_FLAG(FLAG)                 (((FLAG) == RST_CLK_FLAG_HSIRDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_LSIRDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_HSERDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_HSE2RDY)	  || \
N                                               ((FLAG) == RST_CLK_FLAG_LSERDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_PLLCPURDY) || \
N                                               ((FLAG) == RST_CLK_FLAG_PLLUSBRDY))
X#define IS_RST_CLK_FLAG(FLAG)                 (((FLAG) == RST_CLK_FLAG_HSIRDY)    ||                                                ((FLAG) == RST_CLK_FLAG_LSIRDY)    ||                                                ((FLAG) == RST_CLK_FLAG_HSERDY)    ||                                                ((FLAG) == RST_CLK_FLAG_HSE2RDY)	  ||                                                ((FLAG) == RST_CLK_FLAG_LSERDY)    ||                                                ((FLAG) == RST_CLK_FLAG_PLLCPURDY) ||                                                ((FLAG) == RST_CLK_FLAG_PLLUSBRDY))
N
N/** @} */ /* End of group RST_CLK_Flag */
N
N#define IS_RCC_CLK_HSI_TRIM_VALUE(TRIM)       ((TRIM) <= 0x3F)
N#define IS_RCC_CLK_LSI_TRIM_VALUE(TRIM)       ((TRIM) <= 0x1F)
N
N/** @defgroup RST_CLK_HSI_C1_SEL HSI clock divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK HSI clock HSI_C1_SEL divider constants
N  */
N
N#define RST_CLK_HSIclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_HSIclkDIV2                    ((uint32_t)0x00000008)
N#define RST_CLK_HSIclkDIV4                    ((uint32_t)0x00000009)
N#define RST_CLK_HSIclkDIV8                    ((uint32_t)0x0000000A)
N#define RST_CLK_HSIclkDIV16                   ((uint32_t)0x0000000B)
N#define RST_CLK_HSIclkDIV32                   ((uint32_t)0x0000000C)
N#define RST_CLK_HSIclkDIV64                   ((uint32_t)0x0000000D)
N#define RST_CLK_HSIclkDIV128                  ((uint32_t)0x0000000E)
N#define RST_CLK_HSIclkDIV256                  ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_HSIclkDivValue(SRC)        (((SRC) == RST_CLK_HSIclkDIV1)    || \
N                                               ((SRC) == RST_CLK_HSIclkDIV2)    || \
N                                               ((SRC) == RST_CLK_HSIclkDIV4)    || \
N                                               ((SRC) == RST_CLK_HSIclkDIV8)    || \
N                                               ((SRC) == RST_CLK_HSIclkDIV16)   || \
N                                               ((SRC) == RST_CLK_HSIclkDIV32)   || \
N                                               ((SRC) == RST_CLK_HSIclkDIV64)   || \
N                                               ((SRC) == RST_CLK_HSIclkDIV128)  || \
N                                               ((SRC) == RST_CLK_HSIclkDIV256))
X#define IS_RST_CLK_HSIclkDivValue(SRC)        (((SRC) == RST_CLK_HSIclkDIV1)    ||                                                ((SRC) == RST_CLK_HSIclkDIV2)    ||                                                ((SRC) == RST_CLK_HSIclkDIV4)    ||                                                ((SRC) == RST_CLK_HSIclkDIV8)    ||                                                ((SRC) == RST_CLK_HSIclkDIV16)   ||                                                ((SRC) == RST_CLK_HSIclkDIV32)   ||                                                ((SRC) == RST_CLK_HSIclkDIV64)   ||                                                ((SRC) == RST_CLK_HSIclkDIV128)  ||                                                ((SRC) == RST_CLK_HSIclkDIV256))
N
N/** @} */ /* End of group RST_CLK_HSI_C1_SEL */
N
N/** @defgroup RST_CLK_HSE_C1_SEL HSE clock divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK HSE clock HSE_C1_SEL divider constants
N  */
N#define RST_CLK_HSEclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_HSEclkDIV2                    ((uint32_t)0x00000008)
N#define RST_CLK_HSEclkDIV4                    ((uint32_t)0x00000009)
N#define RST_CLK_HSEclkDIV8                    ((uint32_t)0x0000000A)
N#define RST_CLK_HSEclkDIV16                   ((uint32_t)0x0000000B)
N#define RST_CLK_HSEclkDIV32                   ((uint32_t)0x0000000C)
N#define RST_CLK_HSEclkDIV64                   ((uint32_t)0x0000000D)
N#define RST_CLK_HSEclkDIV128                  ((uint32_t)0x0000000E)
N#define RST_CLK_HSEclkDIV256                  ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_HSEclkDivValue(SRC)        (((SRC) == RST_CLK_HSEclkDIV1)    || \
N                                               ((SRC) == RST_CLK_HSEclkDIV2)    || \
N                                               ((SRC) == RST_CLK_HSEclkDIV4)    || \
N                                               ((SRC) == RST_CLK_HSEclkDIV8)    || \
N                                               ((SRC) == RST_CLK_HSEclkDIV16)   || \
N                                               ((SRC) == RST_CLK_HSEclkDIV32)   || \
N                                               ((SRC) == RST_CLK_HSEclkDIV64)   || \
N                                               ((SRC) == RST_CLK_HSEclkDIV128)  || \
N                                               ((SRC) == RST_CLK_HSEclkDIV256))
X#define IS_RST_CLK_HSEclkDivValue(SRC)        (((SRC) == RST_CLK_HSEclkDIV1)    ||                                                ((SRC) == RST_CLK_HSEclkDIV2)    ||                                                ((SRC) == RST_CLK_HSEclkDIV4)    ||                                                ((SRC) == RST_CLK_HSEclkDIV8)    ||                                                ((SRC) == RST_CLK_HSEclkDIV16)   ||                                                ((SRC) == RST_CLK_HSEclkDIV32)   ||                                                ((SRC) == RST_CLK_HSEclkDIV64)   ||                                                ((SRC) == RST_CLK_HSEclkDIV128)  ||                                                ((SRC) == RST_CLK_HSEclkDIV256))
N
N/** @} */ /* End of group RST_CLK_HSE_C1_SEL */
N
N/** @} */ /* End of group RST_CLK_Exported_Constants */
N
N/** @defgroup RST_CLK_Exported_Macros RST_CLK Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group RST_CLK_Exported_Macros */
N
N/** @defgroup RST_CLK_Exported_Functions RST_CLK Exported Functions
N  * @{
N  */
N
Nvoid RST_CLK_DeInit(void);
Nvoid RST_CLK_WarmDeInit(void);
N
N
Nvoid RST_CLK_HSEconfig(uint32_t RST_CLK_HSE);
NErrorStatus RST_CLK_HSEstatus(void);
N
Nvoid RST_CLK_LSEconfig(uint32_t RST_CLK_LSE);
NErrorStatus RST_CLK_LSEstatus(void);
N
Nvoid RST_CLK_HSIcmd(FunctionalState NewState);
Nvoid RST_CLK_HSIadjust(uint32_t HSItrimValue);
NErrorStatus RST_CLK_HSIstatus(void);
N
Nvoid RST_CLK_LSIcmd(FunctionalState NewState);
Nvoid RST_CLK_LSIadjust(uint32_t LSItrimValue);
NErrorStatus RST_CLK_LSIstatus(void);
N
Nvoid RST_CLK_CPU_PLLconfig(uint32_t RST_CLK_CPU_PLLsource, uint32_t RST_CLK_CPU_PLLmul);
Nvoid RST_CLK_CPU_PLLuse(FunctionalState UsePLL);
Nvoid RST_CLK_CPU_PLLcmd(FunctionalState NewState);
NErrorStatus RST_CLK_CPU_PLLstatus(void);
N
Nvoid RST_CLK_CPUclkPrescaler(uint32_t CPUclkDivValue);
Nvoid RST_CLK_CPUclkSelection(uint32_t CPU_CLK);
N
Nvoid RST_CLK_USB_PLLconfig(uint32_t RST_CLK_USB_PLLsource, uint32_t RST_CLK_USB_PLLmul);
Nvoid RST_CLK_USB_PLLuse(FunctionalState UsePLL);
Nvoid RST_CLK_USB_PLLcmd(FunctionalState NewState);
NErrorStatus RST_CLK_USB_PLLstatus(void);
N
Nvoid RST_CLK_USBclkPrescaler(FunctionalState NewState);
Nvoid RST_CLK_USBclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_ADCclkSelection(uint32_t ADC_CLK);
Nvoid RST_CLK_ADCclkPrescaler(uint32_t ADCclkDivValue);
Nvoid RST_CLK_ADCclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_HSIclkPrescaler(uint32_t HSIclkDivValue);
Nvoid RST_CLK_RTC_HSIclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_HSEclkPrescaler(uint32_t HSEclkDivValue);
Nvoid RST_CLK_RTC_HSEclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_PCLKcmd(uint32_t RST_CLK_PCLK, FunctionalState NewState);
N#if defined (USE_MDR1986VE3)
X#if 0L
S	void RST_CLK_PCLK2cmd ( uint32_t RST_CLK_PCLK2, FunctionalState NewState);
S	void RST_CLK_AUCclkDeInit(void);
S	void RST_CLK_AUCclkSelection(uint32_t AUC_CLK);
S	void RST_CLK_AUCclkPrescaler(uint32_t AUCclkDIVValue);
S	void RST_CLK_AUCclkCMD(FunctionalState NewState);
N#endif
Nvoid RST_CLK_GetClocksFreq(RST_CLK_FreqTypeDef* RST_CLK_Clocks);
N
NFlagStatus RST_CLK_GetFlagStatus(uint32_t RST_CLK_FLAG);
N
N#if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
X#if 0L || 0L
S	void RST_CLK_HSE2config(uint32_t RST_CLK_HSE2);
S	ErrorStatus RST_CLK_HSE2status(void);
N#endif
N
N/** @} */ /* End of group RST_CLK_Exported_Functions */
N
N/** @} */ /* End of group RST_CLK */
N
N/** @} */ /* End of group __MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_RST_CLK_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE MDR32F9Qx_rst_clk.h */
L 28 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\USB_Library\MDR32F9Qx_usb_device.c" 2
N#include "MDR32F9Qx_usb_handlers.h"
L 1 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library\MDR32F9Qx_usb_handlers.h" 1
N/**
N  ******************************************************************************
N  * @file    Examples/MDR32F9Q1_EVAL/USB/VCOM_Echo/inc/MDR32F9Qx_usb_handlers.h
N  * @author  Milandr Application Team
N  * @version V1.4.0
N  * @date    18/03/2011
N  * @brief   USB Library user-defined handlers definition file.
N  ******************************************************************************
N  * <br><br>
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, MILANDR SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Milandr</center></h2>
N  * FILE MDR32F9Qx_usb_handlers.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_USB_HANDLERS_H
N#define __MDR32F9Qx_USB_HANDLERS_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_usb_default_handlers.h"
L 1 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library\MDR32F9Qx_usb_default_handlers.h" 1
N/**
N  ******************************************************************************
N  * @file    USB_Library\MDR32F9Qx_usb_default_handlers.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    18/03/2011
N  * @brief   USB Library handlers definition file.
N  ******************************************************************************
N  * <br><br>
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  * FILE MDR32F9Qx_usb_default_handlers.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_USB_DEFAULT_HANDLERS_H
N#define __MDR32F9Qx_USB_DEFAULT_HANDLERS_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_usb_CDC.h"
L 1 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library\MDR32F9Qx_usb_CDC.h" 1
N/**
N  ******************************************************************************
N  * @file    USB_Library\MDR32F9Qx_usb_CDC.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    02/03/2011
N  * @brief   This file contains all the interface types and function prototypes
N  *          of the:
N  *          [1] Communication Device Class driver as of USB Class Definitions
N  *              for Communications Devices Rev.1.2 (Errata 1);
N  *          [2] USB Communication Class Subclass Specification for PSTN
N  *              Devices Rev.1.2.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32F9Qx_usb_device.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_USB_CDC_H
N#define __MDR32F9Qx_USB_CDC_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_config.h"
N#include "MDR32F9Qx_lib.h"
N#include "USB_Library/MDR32F9Qx_usb_device.h"
L 1 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library/MDR32F9Qx_usb_device.h" 1
N/**
N  ******************************************************************************
N  * @file    USB_Library\MDR32F9Qx_usb_device.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    21/02/2011
N  * @brief   This file contains all the interface types and function prototypes
N  *          of the EndPoint and Device drivers as of USB Specification Rev.2.0
N  *          Chapter 9
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32F9Qx_usb_device.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_USB_DEVICE_H
N#define __MDR32F9Qx_USB_DEVICE_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_config.h"
N
N#ifdef MDR1986VE9x
S/* Includes ------------------------------------------------------------------*/
S	#include "MDR32Fx.h"
N#endif
N
N#ifdef MDR1986VE3
S	#include "MDR1986VE3.h"
N#endif
N
N#include "MDR32F9Qx_lib.h"
N#include "MDR32F9Qx_usb.h"
L 1 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_usb.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32F9Qx_usb.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    01/02/2011
N  * @brief   This file contains all the functions prototypes for the USB
N  *          SFR access layer
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32F9Qx_usb.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_USB_H
N#define __MDR32F9Qx_USB_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_lib.h"
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup USB USB
N  * @{
N  */
N
N/** @defgroup USB_Exported_Types USB Exported Types
N  * @{
N  */
N
N/**
N  * @brief EndPoints enumeration
N  */
N
Ntypedef enum
N{
N  USB_EP0  = 0,
N  USB_EP1  = 1,
N  USB_EP2  = 2,
N  USB_EP3  = 3,
N  Num_USB_EndPoints
N}USB_EP_TypeDef;
N
N#define IS_USB_ENDPOINT(ENDPOINT)       (((ENDPOINT) >= 0) && ((ENDPOINT) < Num_USB_EndPoints))
N
N/**
N  * @brief USB Clock Init Structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t USB_USBC1_Source;       /*!< Specifies the source for USB_C1, if USB_C2 source is set to USB_C1.
N                                        This parameter is one of @ref USB_USBC1_Source values. */
N  uint32_t USB_PLLUSBMUL;          /*!< Specifies the source for USB_C1, if USB_C2 source is set to USB_PLL.
N                                        This parameter is one of @ref USB_PLLUSB_Source values. */
N}USB_Clock_TypeDef;
N
Ntypedef struct
N{
N  uint8_t USB_Version;             /*!< USB Version. */
N  uint8_t USB_Revision;            /*!< USB Revision. */
N}USB_Version_TypeDef;
N
N/** @} */ /* End of group USB_Exported_Types */
N
N/** @defgroup USB_USBC2_Source USB USBC2 Source
N  * @{
N  */
N
N#define USB_PLL                         ((uint32_t)0x00000004)
N
N/** @} */ /* End of group USB_USBC2_Source */
N
N/** @defgroup USB_USBC1_Source USB USBC1 Source
N  * @{
N  */
N
N#define USB_C1HSIdiv1                  ((uint32_t)0x00000000)
N#define USB_C1HSIdiv2                  ((uint32_t)0x00000001)
N#define USB_C1HSEdiv1                  ((uint32_t)0x00000002)
N#define USB_C1HSEdiv2                  ((uint32_t)0x00000003)
N
N#define IS_USBC1_CLOCK_BRG(CLOCK)      (((CLOCK) >= 0) && ((CLOCK) <= 3))
N
N/** @} */ /* End of group USB_USBC1_Source */
N
N/** @defgroup USB_PLLUSB_Source USB PLLUSB Source
N  * @{
N  */
N
N#define USB_PLLUSBMUL1                 ((uint32_t)0x00000000)
N#define USB_PLLUSBMUL2                 ((uint32_t)0x00000001)
N#define USB_PLLUSBMUL3                 ((uint32_t)0x00000002)
N#define USB_PLLUSBMUL4                 ((uint32_t)0x00000003)
N#define USB_PLLUSBMUL5                 ((uint32_t)0x00000004)
N#define USB_PLLUSBMUL6                 ((uint32_t)0x00000005)
N#define USB_PLLUSBMUL7                 ((uint32_t)0x00000006)
N#define USB_PLLUSBMUL8                 ((uint32_t)0x00000007)
N#define USB_PLLUSBMUL9                 ((uint32_t)0x00000008)
N#define USB_PLLUSBMUL10                ((uint32_t)0x00000009)
N#define USB_PLLUSBMUL11                ((uint32_t)0x0000000A)
N#define USB_PLLUSBMUL12                ((uint32_t)0x0000000B)
N#define USB_PLLUSBMUL13                ((uint32_t)0x0000000C)
N#define USB_PLLUSBMUL14                ((uint32_t)0x0000000D)
N#define USB_PLLUSBMUL15                ((uint32_t)0x0000000E)
N#define USB_PLLUSBMUL16                ((uint32_t)0x0000000F)
N
N#define IS_PLLUSBMUL(MUL)              (((MUL) >= 0) && ((MUL) < 16))
N
N#define USB_CLOCK_48MHz                ((uint32_t)48000000)
N#define IS_USB_CLOCK(MUL,USBC1)        (((USBC1 == USB_C1HSIdiv1) && (((MUL + 1)* HSI_Value) == USB_CLOCK_48MHz))       || \
N                                        ((USBC1 == USB_C1HSIdiv2) && (((MUL + 1)* (HSI_Value / 2)) == USB_CLOCK_48MHz)) || \
N                                        ((USBC1 == USB_C1HSEdiv1) && (((MUL + 1)* HSE_Value) == USB_CLOCK_48MHz))       || \
N                                        ((USBC1 == USB_C1HSEdiv2) && (((MUL + 1)* (HSE_Value / 2)) == USB_CLOCK_48MHz)))
X#define IS_USB_CLOCK(MUL,USBC1)        (((USBC1 == USB_C1HSIdiv1) && (((MUL + 1)* HSI_Value) == USB_CLOCK_48MHz))       ||                                         ((USBC1 == USB_C1HSIdiv2) && (((MUL + 1)* (HSI_Value / 2)) == USB_CLOCK_48MHz)) ||                                         ((USBC1 == USB_C1HSEdiv1) && (((MUL + 1)* HSE_Value) == USB_CLOCK_48MHz))       ||                                         ((USBC1 == USB_C1HSEdiv2) && (((MUL + 1)* (HSE_Value / 2)) == USB_CLOCK_48MHz)))
N
N/** @} */ /* End of group USB_PLLUSB_Source */
N
N/** @defgroup USB_HOST_REGS_Values USB_HOST Register Values
N  * @{
N  */
N
N/** @defgroup USB_HSCR_Values USB_HSCR Values
N  * @{
N  */
N
N#define USB_HSCR_HOST_MODE_Host              (uint32_t)(1 << USB_HSCR_HOST_MODE_Pos)
N#define USB_HSCR_HOST_MODE_Device            (uint32_t)(1 << (USB_HSCR_HOST_MODE_Pos + 16))
N
N#define USB_HSCR_RESET_CORE_Reset            (uint32_t)(1 << USB_HSCR_RESET_CORE_Pos)
N#define USB_HSCR_RESET_CORE_Work             (uint32_t)(1 << (USB_HSCR_RESET_CORE_Pos + 16))
N
N#define USB_HSCR_EN_TX_Set                   (uint32_t)(1 << USB_HSCR_EN_TX_Pos)
N#define USB_HSCR_EN_TX_Reset                 (uint32_t)(1 << (USB_HSCR_EN_TX_Pos + 16))
N
N#define USB_HSCR_EN_RX_Set                   (uint32_t)(1 << USB_HSCR_EN_RX_Pos)
N#define USB_HSCR_EN_RX_Reset                 (uint32_t)(1 << (USB_HSCR_EN_RX_Pos + 16))
N
N#define USB_HSCR_DP_PULLUP_Set               (uint32_t)(1 << USB_HSCR_DP_PULLUP_Pos)
N#define USB_HSCR_DP_PULLUP_Reset             (uint32_t)(1 << (USB_HSCR_DP_PULLUP_Pos + 16))
N
N#define USB_HSCR_DP_PULLDOWN_Set             (uint32_t)(1 << USB_HSCR_DP_PULLDOWN_Pos)
N#define USB_HSCR_DP_PULLDOWN_Reset           (uint32_t)(1 << (USB_HSCR_DP_PULLDOWN_Pos + 16))
N
N#define USB_HSCR_DM_PULLUP_Set               (uint32_t)(1 << USB_HSCR_DM_PULLUP_Pos)
N#define USB_HSCR_DM_PULLUP_Reset             (uint32_t)(1 << (USB_HSCR_DM_PULLUP_Pos + 16))
N
N#define USB_HSCR_DM_PULLDOWN_Set             (uint32_t)(1 << USB_HSCR_DM_PULLDOWN_Pos)
N#define USB_HSCR_DM_PULLDOWN_Reset           (uint32_t)(1 << (USB_HSCR_DM_PULLDOWN_Pos + 16))
N
N#define USB_HSCR_SET_MASK                    (USB_HSCR_HOST_MODE_Host   | \
N                                              USB_HSCR_RESET_CORE_Reset | \
N                                              USB_HSCR_EN_TX_Set        | \
N                                              USB_HSCR_EN_RX_Set        | \
N                                              USB_HSCR_DP_PULLUP_Set    | \
N                                              USB_HSCR_DP_PULLDOWN_Set  | \
N                                              USB_HSCR_DM_PULLUP_Set    | \
N                                              USB_HSCR_DM_PULLDOWN_Set)
X#define USB_HSCR_SET_MASK                    (USB_HSCR_HOST_MODE_Host   |                                               USB_HSCR_RESET_CORE_Reset |                                               USB_HSCR_EN_TX_Set        |                                               USB_HSCR_EN_RX_Set        |                                               USB_HSCR_DP_PULLUP_Set    |                                               USB_HSCR_DP_PULLDOWN_Set  |                                               USB_HSCR_DM_PULLUP_Set    |                                               USB_HSCR_DM_PULLDOWN_Set)
N
N#define USB_HSCR_RESET_MASK                  (USB_HSCR_SET_MASK << 16)
N
N#define IS_USB_HSCR_VALUE(VALUE)             ((((VALUE) & (~(USB_HSCR_SET_MASK | USB_HSCR_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_HSCR_VALUE(VALUE)             ((((VALUE) & (~(USB_HSCR_SET_MASK | USB_HSCR_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N/** @} */ /* End of group USB_HSCR_Values */
N
N/** @defgroup USB_HTXC_Values USB_HTXC Values
N  * @{
N  */
N
N#define USB_HTXC_TREQ_Set                    (uint32_t)(1 << USB_HTXC_TREQ_Pos)
N#define USB_HTXC_TREQ_Reset                  (uint32_t)(1 << (USB_HTXC_TREQ_Pos + 16))
N
N#define USB_HTXC_SOFS_Set                    (uint32_t)(1 << USB_HTXC_SOFS_Pos)
N#define USB_HTXC_SOFS_Reset                  (uint32_t)(1 << (USB_HTXC_SOFS_Pos + 16))
N
N#define USB_HTXC_PREEN_Set                   (uint32_t)(1 << USB_HTXC_PREEN_Pos)
N#define USB_HTXC_PREEN_Reset                 (uint32_t)(1 << (USB_HTXC_PREEN_Pos + 16))
N
N#define USB_HTXC_ISOEN_Set                   (uint32_t)(1 << USB_HTXC_ISOEN_Pos)
N#define USB_HTXC_ISOEN_Reset                 (uint32_t)(1 << (USB_HTXC_ISOEN_Pos + 16))
N
N#define USB_HTXC_SET_MASK                    (USB_HTXC_TREQ_Set  | \
N                                              USB_HTXC_SOFS_Set  | \
N                                              USB_HTXC_PREEN_Set | \
N                                              USB_HTXC_ISOEN_Set)
X#define USB_HTXC_SET_MASK                    (USB_HTXC_TREQ_Set  |                                               USB_HTXC_SOFS_Set  |                                               USB_HTXC_PREEN_Set |                                               USB_HTXC_ISOEN_Set)
N
N#define USB_HTXC_RESET_MASK                  (USB_HTXC_SET_MASK << 16)
N
N#define IS_USB_HTXC_VALUE(VALUE)             ((((VALUE) & (~(USB_HTXC_SET_MASK | USB_HTXC_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_HTXC_VALUE(VALUE)             ((((VALUE) & (~(USB_HTXC_SET_MASK | USB_HTXC_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_HTXC_Values */
N
N/** @defgroup USB_HTXT_Values USB_HTXT Values
N  * @{
N  */
N
N#define USB_HTXT_TTYPE_Setup                 (uint32_t)(0x00000000)
N#define USB_HTXT_TTYPE_In                    (uint32_t)(0x00000001)
N#define USB_HTXT_TTYPE_Outdata0              (uint32_t)(0x00000002)
N#define USB_HTXT_TTYPE_Outdata1              (uint32_t)(0x00000003)
N
N#define IS_USB_HTXT_VALUE(VALUE)             (((VALUE) == USB_HTXT_TTYPE_Setup)    || \
N                                              ((VALUE) == USB_HTXT_TTYPE_In)       || \
N                                              ((VALUE) == USB_HTXT_TTYPE_Outdata0) || \
N                                              ((VALUE) == USB_HTXT_TTYPE_Outdata1))
X#define IS_USB_HTXT_VALUE(VALUE)             (((VALUE) == USB_HTXT_TTYPE_Setup)    ||                                               ((VALUE) == USB_HTXT_TTYPE_In)       ||                                               ((VALUE) == USB_HTXT_TTYPE_Outdata0) ||                                               ((VALUE) == USB_HTXT_TTYPE_Outdata1))
N
N/** @} */ /* End of group USB_HTXT_Values */
N
N/** @defgroup USB_HTXLC_Values USB_HTXLC Values
N  * @{
N  */
N
N#define USB_HTXLC_TXLC_DM_Set                (uint32_t)(1 << USB_HTXLC_Pos)
N#define USB_HTXLC_TXLC_DM_Reset              (uint32_t)(1 << (USB_HTXLC_Pos + 16))
N
N#define USB_HTXLC_TXLC_DP_Set                (uint32_t)(1 << (USB_HTXLC_Pos + 1))
N#define USB_HTXLC_TXLC_DP_Reset              (uint32_t)(1 << (USB_HTXLC_Pos + 16 + 1))
N
N#define USB_HTXLC_DC_Direct                  (uint32_t)(1 << USB_HTXLC_DC_Pos)
N#define USB_HTXLC_DC_Normal                  (uint32_t)(1 << (USB_HTXLC_DC_Pos + 16))
N
N#define USB_HTXLC_FSPL_Full                  (uint32_t)(1 << USB_HTXLC_FSPL_Pos)
N#define USB_HTXLC_FSPL_Low                   (uint32_t)(1 << (USB_HTXLC_FSPL_Pos + 16))
N
N#define USB_HTXLC_FSLR_12Mb                  (uint32_t)(1 << USB_HTXLC_FSLR_Pos)
N#define USB_HTXLC_FSPL_1_5Mb                 (uint32_t)(1 << (USB_HTXLC_FSLR_Pos + 16))
N
N#define USB_HTXLC_SET_MASK                   (USB_HTXLC_TXLC_DM_Set  | \
N                                              USB_HTXLC_TXLC_DP_Set  | \
N                                              USB_HTXLC_DC_Direct | \
N                                              USB_HTXLC_FSPL_Full | \
N                                              USB_HTXLC_FSLR_12Mb)
X#define USB_HTXLC_SET_MASK                   (USB_HTXLC_TXLC_DM_Set  |                                               USB_HTXLC_TXLC_DP_Set  |                                               USB_HTXLC_DC_Direct |                                               USB_HTXLC_FSPL_Full |                                               USB_HTXLC_FSLR_12Mb)
N
N#define USB_HTXLC_RESET_MASK                 (USB_HTXLC_SET_MASK << 16)
N
N#define IS_USB_HTXLC_VALUE(VALUE)            ((((VALUE) & (~(USB_HTXLC_SET_MASK | USB_HTXLC_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_HTXLC_VALUE(VALUE)            ((((VALUE) & (~(USB_HTXLC_SET_MASK | USB_HTXLC_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_HTXLC_Values */
N
N/** @defgroup USB_HTXSE_Values USB_HTXSE Values
N  * @{
N  */
N
N#define USB_HTXSE_SOFEN_Auto                 (uint32_t)(0x00000001)
N#define USB_HTXSE_SOFEN_NonAuto              (uint32_t)(0x00000001 << 16)
N
N#define IS_USB_HTXSE_VALUE(VALUE)            ((((VALUE) & (~(USB_HTXSE_SOFEN_Auto | USB_HTXSE_SOFEN_NonAuto))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_HTXSE_VALUE(VALUE)            ((((VALUE) & (~(USB_HTXSE_SOFEN_Auto | USB_HTXSE_SOFEN_NonAuto))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_HTXSE_Values */
N
N/** @defgroup USB_HIS_Values USB_HIS Values
N  * @{
N  */
N
N#define USB_HIS_TDONE_Set                    USB_HIS_TDONE
N
N#define USB_HIS_RESUME_Set                   USB_HIS_RESUME
N
N#define USB_HIS_CONEV_Set                    USB_HIS_CONEV
N
N#define USB_HIS_SOFS_Set                     USB_HIS_SOFS
N
N#define IS_USB_HIS_VALUE(VALUE)              (((VALUE) == USB_HIS_TDONE_Set)  || \
N                                              ((VALUE) == USB_HIS_RESUME_Set) || \
N                                              ((VALUE) == USB_HIS_CONEV_Set)  || \
N                                              ((VALUE) == USB_HIS_SOFS_Set))
X#define IS_USB_HIS_VALUE(VALUE)              (((VALUE) == USB_HIS_TDONE_Set)  ||                                               ((VALUE) == USB_HIS_RESUME_Set) ||                                               ((VALUE) == USB_HIS_CONEV_Set)  ||                                               ((VALUE) == USB_HIS_SOFS_Set))
N
N/** @} */ /* End of group USB_HIS_Values */
N
N/** @defgroup USB_HIM_Values USB_HIM Values
N  * @{
N  */
N
N#define USB_HIM_TDONEIE_Set                  (uint32_t)(1 << USB_HIM_TDONEIE_Pos)
N#define USB_HIM_TDONEIE_Reset                (uint32_t)(1 << (USB_HIM_TDONEIE_Pos + 16))
N
N#define USB_HIM_RESUMEIE_Set                 (uint32_t)(1 << USB_HIM_RESUMEIE_Pos)
N#define USB_HIM_RESUMEIE_Reset               (uint32_t)(1 << (USB_HIM_RESUMEIE_Pos + 16))
N
N#define USB_HIM_CONEVIE_Set                  (uint32_t)(1 << USB_HIM_CONEVIE_Pos)
N#define USB_HIM_CONEVIE_Reset                (uint32_t)(1 << (USB_HIM_CONEVIE_Pos + 16))
N
N#define USB_HIM_SOFIE_Set                    (uint32_t)(1 << USB_HIM_SOFIE_Pos)
N#define USB_HIM_SOFIE_Reset                  (uint32_t)(1 << (USB_HIM_SOFIE_Pos + 16))
N
N#define USB_HIM_SET_MASK                     (USB_HIM_TDONEIE_Set  | \
N                                              USB_HIM_RESUMEIE_Set | \
N                                              USB_HIM_CONEVIE_Set  | \
N                                              USB_HIM_SOFIE_Set)
X#define USB_HIM_SET_MASK                     (USB_HIM_TDONEIE_Set  |                                               USB_HIM_RESUMEIE_Set |                                               USB_HIM_CONEVIE_Set  |                                               USB_HIM_SOFIE_Set)
N
N#define USB_HIM_RESET_MASK                   (USB_HIM_SET_MASK << 16)
N
N#define IS_USB_HIM_VALUE(VALUE)              ((((VALUE) & (~(USB_HIM_SET_MASK | USB_HIM_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_HIM_VALUE(VALUE)              ((((VALUE) & (~(USB_HIM_SET_MASK | USB_HIM_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_HIM_Values */
N
N/** @defgroup USB_HRXS_Values USB_HRXS Values
N  * @{
N  */
N
N#define USB_HRXS_CRCERR_Set                  (uint32_t)(1 << USB_HRXS_CRCERR_Pos)
N#define USB_HRXS_CRCERR_Reset                (uint32_t)(1 << (USB_HRXS_CRCERR_Pos + 16))
N
N#define USB_HRXS_BSERR_Set                   (uint32_t)(1 << USB_HRXS_BSERR_Pos)
N#define USB_HRXS_BSERR_Reset                 (uint32_t)(1 << (USB_HRXS_BSERR_Pos + 16))
N
N#define USB_HRXS_RXOF_Set                    (uint32_t)(1 << USB_HRXS_RXOF_Pos)
N#define USB_HRXS_RXOF_Reset                  (uint32_t)(1 << (USB_HRXS_RXOF_Pos + 16))
N
N#define USB_HRXS_RXTO_Set                    (uint32_t)(1 << USB_HRXS_RXTO_Pos)
N#define USB_HRXS_RXTO_Reset                  (uint32_t)(1 << (USB_HRXS_RXTO_Pos + 16))
N
N#define USB_HRXS_NAKRXED_Set                 (uint32_t)(1 << USB_HRXS_NAKRXED_Pos)
N#define USB_HRXS_NAKRXED_Reset               (uint32_t)(1 << (USB_HRXS_NAKRXED_Pos + 16))
N
N#define USB_HRXS_STALLRXED_Set               (uint32_t)(1 << USB_HRXS_STALLRXED_Pos)
N#define USB_HRXS_STALLRXED_Reset             (uint32_t)(1 << (USB_HRXS_STALLRXED_Pos + 16))
N
N#define USB_HRXS_ACKRXED_Set                 (uint32_t)(1 << USB_HRXS_ACKRXED_Pos)
N#define USB_HRXS_ACKRXED_Reset               (uint32_t)(1 << (USB_HRXS_ACKRXED_Pos + 16))
N
N#define USB_HRXS_DATASEQ_Data1               (uint32_t)(1 << USB_HRXS_DATASEQ_Pos)
N#define USB_HRXS_DATASEQ_Data0               (uint32_t)(1 << (USB_HRXS_DATASEQ_Pos + 16))
N
N#define USB_HRXS_SET_MASK                    (USB_HRXS_CRCERR_Set    | \
N                                              USB_HRXS_BSERR_Set     | \
N                                              USB_HRXS_RXOF_Set      | \
N                                              USB_HRXS_RXTO_Set      | \
N                                              USB_HRXS_NAKRXED_Set   | \
N                                              USB_HRXS_STALLRXED_Set | \
N                                              USB_HRXS_ACKRXED_Set   | \
N                                              USB_HRXS_DATASEQ_Data1)
X#define USB_HRXS_SET_MASK                    (USB_HRXS_CRCERR_Set    |                                               USB_HRXS_BSERR_Set     |                                               USB_HRXS_RXOF_Set      |                                               USB_HRXS_RXTO_Set      |                                               USB_HRXS_NAKRXED_Set   |                                               USB_HRXS_STALLRXED_Set |                                               USB_HRXS_ACKRXED_Set   |                                               USB_HRXS_DATASEQ_Data1)
N
N#define USB_HRXS_RESET_MASK                  (USB_HRXS_SET_MASK << 16)
N
N#define IS_USB_HRXS_VALUE(VALUE)             ((((VALUE) & (~(USB_HRXS_SET_MASK | USB_HRXS_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_HRXS_VALUE(VALUE)             ((((VALUE) & (~(USB_HRXS_SET_MASK | USB_HRXS_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_HRXS_Values */
N
N/** @defgroup USB_HRXCS_Values USB_HRXCS Values
N  * @{
N  */
N
N#define USB_HRXCS_RXLS_Disconnect            (uint32_t)(0x00000000)
N#define USB_HRXCS_RXLS_LowSpeed              (uint32_t)(0x00000001)
N#define USB_HRXCS_RXLS_FullSpeed             (uint32_t)(0x00000002)
N
N#define IS_USB_HRXCS_VALUE(VALUE)            (((VALUE) == USB_HRXCS_RXLS_Disconnect) || \
N                                              ((VALUE) == USB_HRXCS_RXLS_LowSpeed)   || \
N                                              ((VALUE) == USB_HRXCS_RXLS_FullSpeed))
X#define IS_USB_HRXCS_VALUE(VALUE)            (((VALUE) == USB_HRXCS_RXLS_Disconnect) ||                                               ((VALUE) == USB_HRXCS_RXLS_LowSpeed)   ||                                               ((VALUE) == USB_HRXCS_RXLS_FullSpeed))
N
N/** @} */ /* End of group USB_HRXCS_Values */
N
N#define IS_USB_HTXA_VALUE(VALUE)             ((VALUE)  < 0x00000080)
N#define IS_USB_HTXE_VALUE(VALUE)             ((VALUE)  < 0x00000010)
N#define IS_USB_HFN_VALUE(VALUE)              ((VALUE)  < 0x00000800)
N#define IS_USB_HRXP_VALUE(VALUE)             ((VALUE)  < 0x00000010)
N#define IS_USB_HRXA_VALUE(VALUE)             ((VALUE)  < 0x00000080)
N#define IS_USB_HRXE_VALUE(VALUE)             ((VALUE)  < 0x00000010)
N#define IS_USB_HSTM_VALUE(VALUE)             ((VALUE)  < 0x00000100)
N#define IS_USB_HRXFD_VALUE(VALUE)            ((VALUE)  < 0x00000100)
N#define IS_USB_HRXFDC_VALUE(VALUE)           ((VALUE)  < 0x00010000)
N#define IS_USB_HRXFC_VALUE(VALUE)            ((VALUE) == 0x00000001)
N#define IS_USB_HTXFD_VALUE(VALUE)            ((VALUE)  < 0x00000100)
N#define IS_USB_HTXFC_VALUE(VALUE)            ((VALUE) == 0x00000001)
N
N/** @} */ /* End of group USB_HOST_REGS_Values */
N
N/** @defgroup USB_DEVICE_REGS_Values USB_DEVICE Register Values
N  * @{
N  */
N
N/** @defgroup USB_SEPx_CTRL_Values USB_SEPx_CTRL Values
N  * @{
N  */
N
N#define USB_SEPx_CTRL_EPEN_Enable            (uint32_t)(1 << USB_SEP_CTRL_EPEN_Pos)
N#define USB_SEPx_CTRL_EPEN_Disable           (uint32_t)(1 << (USB_SEP_CTRL_EPEN_Pos + 16))
N
N#define USB_SEPx_CTRL_EPRDY_Ready            (uint32_t)(1 << USB_SEP_CTRL_EPRDY_Pos)
N#define USB_SEPx_CTRL_EPRDY_NotReady         (uint32_t)(1 << (USB_SEP_CTRL_EPRDY_Pos + 16))
N
N#define USB_SEPx_CTRL_EPDATASEQ_Data1        (uint32_t)(1 << USB_SEP_CTRL_EPDATASEQ_Pos)
N#define USB_SEPx_CTRL_EPDATASEQ_Data0        (uint32_t)(1 << (USB_SEP_CTRL_EPDATASEQ_Pos + 16))
N
N#define USB_SEPx_CTRL_EPSSTALL_Reply         (uint32_t)(1 << USB_SEP_CTRL_EPSSTALL_Pos)
N#define USB_SEPx_CTRL_EPSSTALL_NotReply      (uint32_t)(1 << (USB_SEP_CTRL_EPSSTALL_Pos + 16))
N
N#define USB_SEPx_CTRL_EPISOEN_Set            (uint32_t)(1 << USB_SEP_CTRL_EPISOEN_Pos)
N#define USB_SEPx_CTRL_EPISOEN_Reset          (uint32_t)(1 << (USB_SEP_CTRL_EPISOEN_Pos + 16))
N
N#define USB_SEPx_CTRL_SET_MASK               (USB_SEPx_CTRL_EPEN_Enable     | \
N                                              USB_SEPx_CTRL_EPRDY_Ready     | \
N                                              USB_SEPx_CTRL_EPDATASEQ_Data1 | \
N                                              USB_SEPx_CTRL_EPSSTALL_Reply  | \
N                                              USB_SEPx_CTRL_EPISOEN_Set)
X#define USB_SEPx_CTRL_SET_MASK               (USB_SEPx_CTRL_EPEN_Enable     |                                               USB_SEPx_CTRL_EPRDY_Ready     |                                               USB_SEPx_CTRL_EPDATASEQ_Data1 |                                               USB_SEPx_CTRL_EPSSTALL_Reply  |                                               USB_SEPx_CTRL_EPISOEN_Set)
N
N#define USB_SEPx_CTRL_RESET_MASK             (USB_SEPx_CTRL_SET_MASK << 16)
N
N#define IS_USB_SEPx_CTRL_VALUE(VALUE)        ((((VALUE) & (~(USB_SEPx_CTRL_SET_MASK | USB_SEPx_CTRL_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_SEPx_CTRL_VALUE(VALUE)        ((((VALUE) & (~(USB_SEPx_CTRL_SET_MASK | USB_SEPx_CTRL_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_SEPx_CTRL_Values */
N
N/** @defgroup USB_SEPx_STS_Values USB_SEPx_STS Values
N  * @{
N  */
N
N#define USB_SEPx_STS_SCCRCERR_Set            (uint32_t)(1 << USB_SEP_STS_SCCRCERR_Pos)
N#define USB_SEPx_STS_SCCRCERR_Reset          (uint32_t)(1 << (USB_SEP_STS_SCCRCERR_Pos + 16))
N
N#define USB_SEPx_STS_SCBSERR_Set             (uint32_t)(1 << USB_SEP_STS_SCBSERR_Pos)
N#define USB_SEPx_STS_SCBSERR_Reset           (uint32_t)(1 << (USB_SEP_STS_SCBSERR_Pos + 16))
N
N#define USB_SEPx_STS_SCRXOF_Set              (uint32_t)(1 << USB_SEP_STS_SCRXOF_Pos)
N#define USB_SEPx_STS_SCRXOF_Reset            (uint32_t)(1 << (USB_SEP_STS_SCRXOF_Pos + 16))
N
N#define USB_SEPx_STS_SCRXTO_Set              (uint32_t)(1 << USB_SEP_STS_SCRXTO_Pos)
N#define USB_SEPx_STS_SCRXTO_Reset            (uint32_t)(1 << (USB_SEP_STS_SCRXTO_Pos + 16))
N
N#define USB_SEPx_STS_SCNAKSENT_Set            (uint32_t)(1 << USB_SEP_STS_SCNAKSENT_Pos)
N#define USB_SEPx_STS_SCNAKSENT_Reset         (uint32_t)(1 << (USB_SEP_STS_SCNAKSENT_Pos + 16))
N
N#define USB_SEPx_STS_SCSTALLSENT_Set         (uint32_t)(1 << USB_SEP_STS_SCSTALLSENT_Pos)
N#define USB_SEPx_STS_SCSTALLSENT_Reset       (uint32_t)(1 << (USB_SEP_STS_SCSTALLSENT_Pos + 16))
N
N#define USB_SEPx_STS_SCACKRXED_Set           (uint32_t)(1 << USB_SEP_STS_SCACKRXED_Pos)
N#define USB_SEPx_STS_SCACKRXED_Reset         (uint32_t)(1 << (USB_SEP_STS_SCACKRXED_Pos + 16))
N
N#define USB_SEPx_STS_SCDATASEQ_Data1         (uint32_t)(1 << USB_SEP_STS_SCDATASEQ_Pos)
N#define USB_SEPx_STS_SCDATASEQ_Data0         (uint32_t)(1 << (USB_SEP_STS_SCDATASEQ_Pos + 16))
N
N#define USB_SEPx_STS_SET_MASK                (USB_SEPx_STS_SCCRCERR_Set    | \
N                                              USB_SEPx_STS_SCBSERR_Set     | \
N                                              USB_SEPx_STS_SCRXOF_Set      | \
N                                              USB_SEPx_STS_SCRXTO_Set      | \
N                                              USB_SEPx_STS_SCSTALLSENT_Set | \
N                                              USB_SEPx_STS_SCNAKSENT_Set   | \
N                                              USB_SEPx_STS_SCACKRXED_Set   | \
N                                              USB_SEPx_STS_SCDATASEQ_Data1)
X#define USB_SEPx_STS_SET_MASK                (USB_SEPx_STS_SCCRCERR_Set    |                                               USB_SEPx_STS_SCBSERR_Set     |                                               USB_SEPx_STS_SCRXOF_Set      |                                               USB_SEPx_STS_SCRXTO_Set      |                                               USB_SEPx_STS_SCSTALLSENT_Set |                                               USB_SEPx_STS_SCNAKSENT_Set   |                                               USB_SEPx_STS_SCACKRXED_Set   |                                               USB_SEPx_STS_SCDATASEQ_Data1)
N
N#define USB_SEPx_STS_RESET_MASK              (USB_SEPx_STS_SET_MASK << 16)
N
N#define IS_USB_SEPx_STS_VALUE(VALUE)         ((((VALUE) & (~(USB_SEPx_STS_SET_MASK | USB_SEPx_STS_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_SEPx_STS_VALUE(VALUE)         ((((VALUE) & (~(USB_SEPx_STS_SET_MASK | USB_SEPx_STS_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_SEPx_STS_Values */
N
N/** @defgroup USB_SEPx_TS_Values USB_SEPx_TS Values
N  * @{
N  */
N
N#define USB_SEPx_TS_SCTTYPE_Setup            (uint32_t)(0x00000000)
N#define USB_SEPx_TS_SCTTYPE_In               (uint32_t)(0x00000001)
N#define USB_SEPx_TS_SCTTYPE_Outdata          (uint32_t)(0x00000002)
N
N#define USB_SEPx_TS_SCTTYPE_Msk              (uint32_t)(0x00000003)
N
N#define IS_USB_SEPx_TS_VALUE(VALUE)          (((VALUE) == USB_SEPx_TS_SCTTYPE_Setup)   || \
N                                              ((VALUE) == USB_SEPx_TS_SCTTYPE_In)      || \
N                                              ((VALUE) == USB_SEPx_TS_SCTTYPE_Outdata))
X#define IS_USB_SEPx_TS_VALUE(VALUE)          (((VALUE) == USB_SEPx_TS_SCTTYPE_Setup)   ||                                               ((VALUE) == USB_SEPx_TS_SCTTYPE_In)      ||                                               ((VALUE) == USB_SEPx_TS_SCTTYPE_Outdata))
N
N/** @} */ /* End of group USB_SEPx_TS_Values */
N
N/** @defgroup USB_SEPx_NTS_Values USB_SEPx_NTS Values
N  * @{
N  */
N
N#define USB_SEPx_NTS_NTTTYPE_Setup           (uint32_t)(0x00000000)
N#define USB_SEPx_NTS_NTTTYPE_In              (uint32_t)(0x00000001)
N#define USB_SEPx_NTS_NTTTYPE_Outdata         (uint32_t)(0x00000002)
N
N#define USB_SEPx_NTS_NTTTYPE_Msk             (uint32_t)(0x00000003)
N
N#define IS_USB_SEPx_NTS_VALUE(VALUE)         (((VALUE) == USB_SEPx_NTS_NTTTYPE_Setup)   || \
N                                              ((VALUE) == USB_SEPx_NTS_NTTTYPE_In)      || \
N                                              ((VALUE) == USB_SEPx_NTS_NTTTYPE_Outdata))
X#define IS_USB_SEPx_NTS_VALUE(VALUE)         (((VALUE) == USB_SEPx_NTS_NTTTYPE_Setup)   ||                                               ((VALUE) == USB_SEPx_NTS_NTTTYPE_In)      ||                                               ((VALUE) == USB_SEPx_NTS_NTTTYPE_Outdata))
N
N/** @} */ /* End of group USB_SEPx_NTS_Values */
N
N/** @defgroup USB_SC_Values USB_SC Values
N  * @{
N  */
N
N#define USB_SC_SCGEN_Set                     (uint32_t)(1 << USB_SCGEN_Pos)
N#define USB_SC_SCGEN_Reset                   (uint32_t)(1 << (USB_SCGEN_Pos + 16))
N
N#define USB_SC_SCTXLS_DM_Set                 (uint32_t)(1 << USB_SCTXLS_Pos)
N#define USB_SC_SCTXLS_DM_Reset               (uint32_t)(1 << (USB_SCTXLS_Pos + 16))
N
N#define USB_SC_SCTXLS_DP_Set                 (uint32_t)(1 << (USB_SCTXLS_Pos + 1))
N#define USB_SC_SCTXLS_DP_Reset               (uint32_t)(1 << (USB_SCTXLS_Pos + 16 + 1))
N
N#define USB_SC_SCDC_Direct                   (uint32_t)(1 << USB_SCDC_Pos)
N#define USB_SC_SCDC_Normal                   (uint32_t)(1 << (USB_SCDC_Pos + 16))
N
N#define USB_SC_SCFSP_Full                    (uint32_t)(1 << USB_SCFSP_Pos)
N#define USB_SC_SCFSP_Low                     (uint32_t)(1 << (USB_SCFSP_Pos + 16))
N
N#define USB_SC_SCFSR_12Mb                    (uint32_t)(1 << USB_SCFSR_Pos)
N#define USB_SC_SCFSR_1_5Mb                   (uint32_t)(1 << (USB_SCFSR_Pos + 16))
N
N#define USB_SC_SET_MASK                      (USB_SC_SCGEN_Set     | \
N                                              USB_SC_SCTXLS_DM_Set | \
N                                              USB_SC_SCTXLS_DP_Set | \
N                                              USB_SC_SCDC_Direct   | \
N                                              USB_SC_SCFSP_Full    | \
N                                              USB_SC_SCFSR_12Mb)
X#define USB_SC_SET_MASK                      (USB_SC_SCGEN_Set     |                                               USB_SC_SCTXLS_DM_Set |                                               USB_SC_SCTXLS_DP_Set |                                               USB_SC_SCDC_Direct   |                                               USB_SC_SCFSP_Full    |                                               USB_SC_SCFSR_12Mb)
N
N#define USB_SC_RESET_MASK                    (USB_SC_SET_MASK << 16)
N
N#define IS_USB_SC_VALUE(VALUE)               ((((VALUE) & (~(USB_SC_SET_MASK | USB_SC_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_SC_VALUE(VALUE)               ((((VALUE) & (~(USB_SC_SET_MASK | USB_SC_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_SC_Values */
N
N/** @defgroup USB_SLS_Values USB_SLS Values
N  * @{
N  */
N
N#define USB_SLS_SCRXLS_Reset                 (uint32_t)(0x00000000)
N#define USB_SLS_SCRXLS_LowSpeed              (uint32_t)(0x00000001)
N#define USB_SLS_SCRXLS_FullSpeed             (uint32_t)(0x00000002)
N
N#define IS_USB_SLS_VALUE(VALUE)              (((VALUE) == USB_SLS_SCRXLS_Reset)     || \
N                                              ((VALUE) == USB_SLS_SCRXLS_LowSpeed)  || \
N                                              ((VALUE) == USB_SLS_SCRXLS_FullSpeed))
X#define IS_USB_SLS_VALUE(VALUE)              (((VALUE) == USB_SLS_SCRXLS_Reset)     ||                                               ((VALUE) == USB_SLS_SCRXLS_LowSpeed)  ||                                               ((VALUE) == USB_SLS_SCRXLS_FullSpeed))
N
N/** @} */ /* End of group USB_SLS_Values */
N
N/** @defgroup USB_SIS_Values USB_SIS Values
N  * @{
N  */
N
N#define USB_SIS_SCTDONE_Set                  USB_SIS_SCTDONE
N#define USB_SIS_SCRESUME_Set                 USB_SIS_SCRESUME
N#define USB_SIS_SCRESETEV_Set                USB_SIS_SCRESETEV
N#define USB_SIS_SCSOFREC_Set                 USB_SIS_SCSOFREC
N#define USB_SIS_SCNAKSENT_Set                USB_SIS_SCNAKSENT
N
N#define USB_SIS_Msk                          USB_SIS_SCTDONE_Set   | \
N                                             USB_SIS_SCRESUME_Set  | \
N                                             USB_SIS_SCRESETEV_Set | \
N                                             USB_SIS_SCSOFREC_Set  | \
N                                             USB_SIS_SCNAKSENT_Set
X#define USB_SIS_Msk                          USB_SIS_SCTDONE_Set   |                                              USB_SIS_SCRESUME_Set  |                                              USB_SIS_SCRESETEV_Set |                                              USB_SIS_SCSOFREC_Set  |                                              USB_SIS_SCNAKSENT_Set
N
N#define IS_USB_SIS_VALUE(VALUE)              (((VALUE) == USB_SIS_SCTDONE_Set)   || \
N                                              ((VALUE) == USB_SIS_SCRESUME_Set)  || \
N                                              ((VALUE) == USB_SIS_SCRESETEV_Set) || \
N                                              ((VALUE) == USB_SIS_SCSOFREC_Set)  || \
N                                              ((VALUE) == USB_SIS_SCNAKSENT_Set))
X#define IS_USB_SIS_VALUE(VALUE)              (((VALUE) == USB_SIS_SCTDONE_Set)   ||                                               ((VALUE) == USB_SIS_SCRESUME_Set)  ||                                               ((VALUE) == USB_SIS_SCRESETEV_Set) ||                                               ((VALUE) == USB_SIS_SCSOFREC_Set)  ||                                               ((VALUE) == USB_SIS_SCNAKSENT_Set))
N
N/** @} */ /* End of group USB_SIS_Values */
N
N/** @defgroup USB_SIM_Values USB_SIM Values
N  * @{
N  */
N
N#define USB_SIM_SCTDONEIE_Set                (uint32_t)(1 << USB_SIM_SCTDONEIE_Pos)
N#define USB_SIM_SCTDONEIE_Reset              (uint32_t)(1 << (USB_SIM_SCTDONEIE_Pos + 16))
N
N#define USB_SIM_SCRESUMEIE_Set               (uint32_t)(1 << USB_SIM_SCRESUMEIE_Pos)
N#define USB_SIM_SCRESUMEIE_Reset             (uint32_t)(1 << (USB_SIM_SCRESUMEIE_Pos + 16))
N
N#define USB_SIM_SCRESETEVIE_Set              (uint32_t)(1 << USB_SIM_SCRESETEVIE_Pos)
N#define USB_SIM_SCRESETEVIE_Reset            (uint32_t)(1 << (USB_SIM_SCRESETEVIE_Pos + 16))
N
N#define USB_SIM_SCSOFRECIE_Set               (uint32_t)(1 << USB_SIM_SCSOFRECIE_Pos)
N#define USB_SIM_SCSOFRECIE_Reset             (uint32_t)(1 << (USB_SIM_SCSOFRECIE_Pos + 16))
N
N#define USB_SIM_SCNAKSENTIE_Set              (uint32_t)(1 << USB_SIM_SCNAKSENTIE_Pos)
N#define USB_SIM_SCNAKSENTIE_Reset            (uint32_t)(1 << (USB_SIM_SCNAKSENTIE_Pos + 16))
N
N#define USB_SIM_SET_MASK                     (USB_SIM_SCTDONEIE_Set   | \
N                                              USB_SIM_SCRESUMEIE_Set  | \
N                                              USB_SIM_SCRESETEVIE_Set | \
N                                              USB_SIM_SCSOFRECIE_Set  | \
N                                              USB_SIM_SCNAKSENTIE_Set)
X#define USB_SIM_SET_MASK                     (USB_SIM_SCTDONEIE_Set   |                                               USB_SIM_SCRESUMEIE_Set  |                                               USB_SIM_SCRESETEVIE_Set |                                               USB_SIM_SCSOFRECIE_Set  |                                               USB_SIM_SCNAKSENTIE_Set)
N
N#define USB_SIM_RESET_MASK                   (USB_SIM_SET_MASK << 16)
N
N#define IS_USB_SIM_VALUE(VALUE)              ((((VALUE) & (~(USB_SIM_SET_MASK | USB_SIM_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_SIM_VALUE(VALUE)              ((((VALUE) & (~(USB_SIM_SET_MASK | USB_SIM_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_SIM_Values */
N
N#define IS_USB_SA_VALUE(VALUE)               ((VALUE)  < 0x00000080)
N#define IS_USB_SFN_VALUE(VALUE)              ((VALUE)  < 0x00000800)
N#define IS_USB_SEPx_RXFD_VALUE(VALUE)        ((VALUE)  < 0x00000100)
N#define IS_USB_SEPx_RXFDC_VALUE(VALUE)       ((VALUE)  < 0x00010000)
N#define IS_USB_SEPx_RXFC_VALUE(VALUE)        ((VALUE) == 0x00000001)
N#define IS_USB_SEPx_TXFD_VALUE(VALUE)        ((VALUE)  < 0x00000100)
N#define IS_USB_SEPx_TXFDC_VALUE(VALUE)       ((VALUE) == 0x00000001)
N
N/** @} */ /* End of group USB_DEVICE_REGS_Values */
N
N
N/** @defgroup USB_Exported_Functions USB Exported Functions
N  * @{
N  */
N
Nvoid USB_BRGInit(const USB_Clock_TypeDef* USB_Clock_InitStruct);
Nvoid USB_Reset(void);
N
N/**
N  * @brief  Common register functions
N  */
N
Nuint32_t USB_GetHSCR(void);
Nvoid     USB_SetHSCR(uint32_t RegValue);
N
NUSB_Version_TypeDef USB_GetHSVR(void);
N
N/**
N  * @brief  Host register functions
N  */
N
Nuint32_t USB_GetHTXC(void);
Nvoid     USB_SetHTXC(uint32_t RegValue);
Nuint32_t USB_GetHTXT(void);
Nvoid     USB_SetHTXT(uint32_t RegValue);
Nuint32_t USB_GetHTXLC(void);
Nvoid     USB_SetHTXLC(uint32_t RegValue);
Nuint32_t USB_GetHTXSE(void);
Nvoid     USB_SetHTXSE(uint32_t RegValue);
Nuint32_t USB_GetHTXA(void);
Nvoid     USB_SetHTXA(uint32_t RegValue);
Nuint32_t USB_GetHTXE(void);
Nvoid     USB_SetHTXE(uint32_t RegValue);
Nuint32_t USB_GetHFN(void);
Nuint32_t USB_GetHIS(void);
Nvoid     USB_SetHIS(uint32_t RegValue);
Nuint32_t USB_GetHIM(void);
Nvoid     USB_SetHIM(uint32_t RegValue);
Nuint32_t USB_GetHRXS(void);
Nuint32_t USB_GetHRXP(void);
Nuint32_t USB_GetHRXA(void);
Nuint32_t USB_GetHRXE(void);
Nuint32_t USB_GetHRXCS(void);
Nuint32_t USB_GetHSTM(void);
Nuint32_t USB_GetHRXFD(void);
Nuint32_t USB_GetHRXFDC(void);
Nuint32_t USB_GetHRXFC(void);
Nvoid     USB_SetHRXFC(uint32_t RegValue);
Nuint32_t USB_GetHTXFD(void);
Nvoid     USB_SetHTXFD(uint32_t RegValue);
Nuint32_t USB_GetHTXFC(void);
Nvoid     USB_SetHTXFC(uint32_t RegValue);
N
N/**
N  * @brief  Slave register functions
N  */
N
Nuint32_t USB_GetSEPxCTRL(USB_EP_TypeDef EndPointNumber);
Nvoid     USB_SetSEPxCTRL(USB_EP_TypeDef EndPointNumber, uint32_t RegValue);
Nuint32_t USB_GetSEPxSTS(USB_EP_TypeDef EndPointNumber);
Nuint32_t USB_GetSEPxTS(USB_EP_TypeDef EndPointNumber);
Nuint32_t USB_GetSEPxNTS(USB_EP_TypeDef EndPointNumber);
Nuint32_t USB_GetSC(void);
Nvoid     USB_SetSC(uint32_t RegValue);
Nuint32_t USB_GetSLS(void);
Nuint32_t USB_GetSIS(void);
Nvoid     USB_SetSIS(uint32_t RegValue);
Nuint32_t USB_GetSIM(void);
Nvoid     USB_SetSIM(uint32_t RegValue);
Nuint32_t USB_GetSA(void);
Nvoid     USB_SetSA(uint32_t RegValue);
Nuint32_t USB_GetSFN(void);
Nuint32_t USB_GetSEPxRXFD(USB_EP_TypeDef EndPointNumber);
Nuint32_t USB_GetSEPxRXFDC(USB_EP_TypeDef EndPointNumber);
Nuint32_t USB_GetSEPxRXFC(USB_EP_TypeDef EndPointNumber);
Nvoid     USB_SetSEPxRXFC(USB_EP_TypeDef EndPointNumber, uint32_t RegValue);
Nuint32_t USB_GetSEPxTXFD(USB_EP_TypeDef EndPointNumber);
Nvoid     USB_SetSEPxTXFD(USB_EP_TypeDef EndPointNumber, uint32_t RegValue);
Nuint32_t USB_GetSEPxTXFDC(USB_EP_TypeDef EndPointNumber);
Nvoid     USB_SetSEPxTXFDC(USB_EP_TypeDef EndPointNumber, uint32_t RegValue);
Nvoid     USB_SEPxToggleEPDATASEQ(USB_EP_TypeDef EndPointNumber);
N
N/** @} */ /* End of group USB_Exported_Functions */
N
N/** @} */ /* End of group USB */
N
N/** @} */ /* End of group MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_USB_H */
N
N/******************* (C) COPYRIGHT 2011 Phyton *********
N*
N* END OF FILE MDR32F9Qx_usb.h */
L 47 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library/MDR32F9Qx_usb_device.h" 2
N#include "MDR32F9Qx_config.h"
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup USB_DEVICE_AND_CDC USB DEVICE AND CDC
N  * @{
N  */
N
N/** @defgroup USB_Device_Framework_Exported_Types USB Device Framework Exported Types
N  * @{
N  */
N
N/**
N  * @brief Request Type Data Transfer Direction enumeration
N  */
N
Ntypedef enum
N{
N  USB_HOST_TO_DEVICE  = 0x0,
N  USB_DEVICE_TO_HOST  = 0x80
N}USB_RequestTypeDT_TypeDef;
N
N/**
N  * @brief Request Type enumeration
N  */
N
Ntypedef enum
N{
N  USB_TYPE_STANDARD  = 0x0,
N  USB_TYPE_CLASS     = 0x20,
N  USB_TYPE_VENDOR    = 0x40
N}USB_RequestType_TypeDef;
N
N#define USB_REQUEST_DT_Msk                    0x80
N#define USB_REQUEST_TYPE_Msk                  0x60
N
N/**
N  * @brief Standard Setup Request Type enumeration
N  */
N
Ntypedef enum
N{
N  USB_GET_STATUS = 0,
N  USB_CLEAR_FEATURE,
N  USB_Reserved0,
N  USB_SET_FEATURE,
N  USB_Reserved1,
N  USB_SET_ADDRESS,
N  USB_GET_DESCRIPTOR,
N  USB_SET_DESCRIPTOR,
N  USB_GET_CONFIGURATION,
N  USB_SET_CONFIGURATION,
N  USB_GET_INTERFACE,
N  USB_SET_INTERFACE,
N  USB_SYNCH_FRAME
N} USB_Standard_Setup_TypeDef;
N
N/**
N  * @brief Standard Descriptor Type enumeration
N  */
N
Ntypedef enum
N{
N  USB_DEVICE = 1,
N  USB_CONFIGURATION,
N  USB_STRING,
N  USB_INTERFACE,
N  USB_ENDPOINT,
N  USB_DEVICE_QUALIFIER,
N  USB_OTHER_SPEED_CONFIGURATION,
N  USB_INTERFACE_POWER
N} USB_Standard_Descriptor_TypeDef;
N
N/**
N  * @brief Standard Feature Selector Type enumeration
N  */
N
Ntypedef enum
N{
N  USB_ENDPOINT_HALT = 0,
N  USB_DEVICE_REMOTE_WAKEUP,
N  USB_TEST_MODE
N} USB_Standard_Festure_Selector_TypeDef;
N
N/**
N  * @brief Request Recipient enumeration
N  */
N
Ntypedef enum
N{
N  USB_RECIPIENT_DEVICE    = 0x0,
N  USB_RECIPIENT_INTERFACE = 0x1,
N  USB_RECIPIENT_ENDPOINT  = 0x2,
N  USB_RECIPIENT_OTHER     = 0x3
N}USB_RequestRecipient_TypeDef;
N
N#define USB_RECIPIENT_TYPE_Msk                0x1F
N#define IS_VALID_USB_RECIPIENT(RECIPIENT)     ((RECIPIENT) <= USB_RECIPIENT_OTHER)
N
N/**
N  * @brief Setup Packet Structure (9.3) definition
N  */
N
Ntypedef struct
N{
N  uint8_t  mRequestTypeData;             /*!< Characteristics of request:
N                                              D7:    Data transfer direction (USB_RequestTypeDT_TypeDef),
N                                              D6..5: Type (USB_RequestType_TypeDef),
N                                              D4..0: Recipient (USB_RequestRecipient_TypeDef). */
N  uint8_t  bRequest;                     /*!< Specific request. */
N  uint16_t wValue;                       /*!< Request value 1st word (wValue). */
N  uint16_t wIndex;                       /*!< Request value 2nd word (wIndex). */
N  uint16_t wLength;                      /*!< Data stage bytes number. */
N}USB_SetupPacket_TypeDef;
N
N/** @} */ /* End of group USB_Device_Framework_Exported_Types */
N
N/** @defgroup USB_EndPoint USB EndPoint
N  * @{
N  */
N
N/** @defgroup USB_EndPoint_Exported_Types USB EndPoint Exported Types
N  * @{
N  */
N
N/**
N  * @brief Function Return Code enumeration
N  */
N
Ntypedef enum
N{
N  USB_SUCCESS     = 0x0,             /*!< Success. */
N  USB_ERROR       = 0x1,             /*!< General USB driver failure. */
N  USB_ERR_INV_REQ = 0x2,             /*!< Incorrect data in USB device request. */
N  USB_ERR_BUSY    = 0x200,           /*!< Action cannot be proceeded at this time. */
N}USB_Result;
N
N/**
N  * @brief Stall Type enumeration
N  */
N
Ntypedef enum {USB_STALL_PROTO = 0x0, USB_STALL_HALT = 0x1} USB_StallType;
N
N/** @defgroup USB_EndPoint_Transaction_Handlers USB EndPoint End of Transaction Handlers
N  * @{
N  */
N
Ntypedef USB_Result (*USB_EP_IO_Handler)(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length);
Ntypedef USB_Result (*USB_EP_Setup_Handler)(USB_EP_TypeDef EPx, const USB_SetupPacket_TypeDef* USB_SetupPacket);
Ntypedef USB_Result (*USB_EP_Error_Handler)(USB_EP_TypeDef EPx, uint32_t STS, uint32_t TS, uint32_t CTRL);
N
N/** @} */ /* End of group USB_EndPoint_Transaction_Handlers */
N
N/** @} */ /* End of group USB_EndPoint_Exported_Types */
N
N/** @defgroup USB_EndPoint_Exported_Constants USB EndPoint Exported Constants
N  * @{
N  */
N
N#define MAX_PACKET_SIZE                      32
N
N/** @} */ /* End of group USB_EndPoint_Exported_Constants */
N
N/** @defgroup USB_EndPoint_Exported_Macros USB EndPoint Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group USB_EndPoint_Exported_Macros */
N
N/** @defgroup USB_EndPoint_Exported_Functions USB EndPoint Exported Functions
N  * @{
N  */
N
NUSB_Result USB_EP_Init(USB_EP_TypeDef EPx, uint32_t USB_EP_Ctrl, USB_EP_Error_Handler onError);
NUSB_Result USB_EP_Reset(USB_EP_TypeDef EPx);
NUSB_Result USB_EP_Idle(USB_EP_TypeDef EPx);
NUSB_Result USB_EP_Stall(USB_EP_TypeDef EPx, USB_StallType bHalt);
N
NUSB_Result USB_EP_doDataIn(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onInDone);
NUSB_Result USB_EP_doDataOut(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onOutDone);
N
NUSB_Result USB_EP_setSetupHandler(USB_EP_TypeDef EPx, USB_SetupPacket_TypeDef* USB_SetupPacket, USB_EP_Setup_Handler onSetupPacket);
N
NUSB_Result USB_EP_dispatchEvent(USB_EP_TypeDef EPx, uint32_t USB_IT);
N
N/** @} */ /* End of group USB_EndPoint_Exported_Functions */
N
N/** @} */ /* End of group USB_EndPoint */
N
N/** @defgroup USB_Device USB Device
N  * @{
N  */
N
N/** @defgroup USB_Device_Exported_Types USB Device Exported Types
N  * @{
N  */
N
N/**
N  * @brief Device State (9.1) enumeration
N  */
N
Ntypedef enum
N{
N  USB_DEV_STATE_UNKNOWN = 0,
N  USB_DEV_STATE_ATTACHED,
N  USB_DEV_STATE_POWERED,
N  USB_DEV_STATE_DEFAULT,
N  USB_DEV_STATE_ADDRESS,
N  USB_DEV_STATE_CONFIGURED,
N  Num_USB_DEV_STATE
N}USB_DeviceState_TypeDef;
N
N/**
N  * @brief Device Self Powered State enumeration
N  */
N
Ntypedef enum
N{
N  USB_DEV_SELF_POWERED_OFF = 0,
N  USB_DEV_SELF_POWERED_ON  = 1
N} USB_DeviceSelfPoweredState_TypeDef;
N
N/**
N  * @brief Device Remote Wakeup Ability enumeration
N  */
N
Ntypedef enum
N{
N  USB_DEV_REMOTE_WAKEUP_DISABLED = 0,
N  USB_DEV_REMOTE_WAKEUP_ENABLED = 1
N}USB_DeviceRemoteWakeup_TypeDef;
N
N/**
N  * @brief Device Status Structure definition
N  */
N
Ntypedef struct
N{
N#ifdef USB_SELF_POWERED_SUPPORTED
S  USB_DeviceSelfPoweredState_TypeDef SelfPowered;
N#endif /* USB_SELF_POWERED_SUPPORTED */
N#ifdef USB_REMOTE_WAKEUP_SUPPORTED
S  USB_DeviceRemoteWakeup_TypeDef     RemoteWakeupEnabled;
N#endif /* USB_REMOTE_WAKEUP_SUPPORTED */
N#if !defined (USB_SELF_POWERED_SUPPORTED) && !defined (USB_REMOTE_WAKEUP_SUPPORTED)
X#if !0L && !0L
N  uint32_t                           Reserved;
N#endif
N}Usb_DeviceStatus_TypeDef;
N
N/**
N  * @brief Device State Machine Context Structure definition
N  */
N
Ntypedef struct {
N  USB_DeviceState_TypeDef  USB_DeviceState;
N  Usb_DeviceStatus_TypeDef USB_DeviceStatus;
N  uint32_t Address;
N}USB_DeviceContext_TypeDef;
N
N/**
N  * @brief USB BUS parameters Structure definition
N  */
N
Ntypedef struct {
N  uint32_t PULL;                           /*!< This member configures the D+  D- line pulling
N                                                This member can be combination of the following values:
N                                                USB_HSCR_DM_PULLDOWN_Set: D- line pull down
N                                                USB_HSCR_DM_PULLUP_Set:   D- line pull up
N                                                USB_HSCR_DP_PULLDOWN_Set: D+ line pull down
N                                                USB_HSCR_DP_PULLUP_Set:   D+ line pull up */
N  uint32_t SPEED;                          /*!< This member configures the USB speed
N                                                This member can be one of the following values:
N                                                USB_SC_SCFSR_12Mb:  12 Mbit/sec
N                                                USB_SC_SCFSR_1_5Mb: 1.5 Mbit/sec */
N  uint32_t MODE;                           /*!< This member configures the USB polarity
N                                                This member can be one of the following values:
N                                                USB_SC_SCFSP_Full: FULL_SPEED
N                                                USB_SC_SCFSP_Low:  LOW_SPEED */
N}USB_DeviceBUSParam_TypeDef;
N
N#define IS_USB_PULL(PULL)                    (((PULL) == USB_HSCR_DM_PULLDOWN_Set) || \
N                                              ((PULL) == USB_HSCR_DM_PULLUP_Set)   || \
N                                              ((PULL) == USB_HSCR_DP_PULLDOWN_Set) || \
N                                              ((PULL) == USB_HSCR_DP_PULLUP_Set))
X#define IS_USB_PULL(PULL)                    (((PULL) == USB_HSCR_DM_PULLDOWN_Set) ||                                               ((PULL) == USB_HSCR_DM_PULLUP_Set)   ||                                               ((PULL) == USB_HSCR_DP_PULLDOWN_Set) ||                                               ((PULL) == USB_HSCR_DP_PULLUP_Set))
N
N#define IS_USB_SPEED(SPEED)                  (((SPEED) == USB_SC_SCFSR_12Mb) || \
N                                              ((SPEED) == USB_SC_SCFSR_1_5Mb))
X#define IS_USB_SPEED(SPEED)                  (((SPEED) == USB_SC_SCFSR_12Mb) ||                                               ((SPEED) == USB_SC_SCFSR_1_5Mb))
N
N#define IS_USB_MODE(MODE)                    (((MODE) == USB_SC_SCFSP_Full) || \
N                                              ((MODE) == USB_SC_SCFSP_Low))
X#define IS_USB_MODE(MODE)                    (((MODE) == USB_SC_SCFSP_Full) ||                                               ((MODE) == USB_SC_SCFSP_Low))
N
N/** @} */ /* End of group USB_Device_Exported_Types */
N
N/** @defgroup USB_Device_Exported_Constants USB Device Exported Constants
N  * @{
N  */
N
N/** @} */ /* End of group USB_Device_Exported_Constants */
N
N/** @defgroup USB_Device_Exported_Variables USB Device Exported Variables
N  * @{
N  */
N
N/**
N  * @brief Last processed Controlling Setup Packet (or currently in processing)
N  */
N
Nextern USB_SetupPacket_TypeDef USB_CurrentSetupPacket;
N
N/**
N  * @brief Device State Machine Context
N  */
N
Nextern USB_DeviceContext_TypeDef USB_DeviceContext;
N
N/** @} */ /* End of group USB_Device_Exported_Variables */
N
N/** @defgroup USB_Device_Exported_Macros USB Device Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group USB_Device_Exported_Macros */
N
N/** @defgroup USB_Device_Exported_Functions USB Device Exported Functions
N  * @{
N  */
N
NUSB_Result USB_DeviceInit(const USB_Clock_TypeDef* USB_Clock_InitStruct, USB_DeviceBUSParam_TypeDef* USB_DeviceBUSParam);
NUSB_Result USB_DevicePowerOn(void);
NUSB_Result USB_DevicePowerOff(void);
N#ifdef USB_REMOTE_WAKEUP_SUPPORTED
SUSB_Result USB_DeviceRemoteWakeUp(void);
N#endif /* USB_REMOTE_WAKEUP_SUPPORTED */
N
NUSB_Result USB_DeviceReset(void);
NUSB_Result USB_DeviceSuspend(void);
NUSB_Result USB_DeviceResume(void);
N
NUSB_Result USB_DeviceSetupPacket(USB_EP_TypeDef EPx, const USB_SetupPacket_TypeDef* USB_SetupPacket);
N
NUSB_Result USB_DeviceClearFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX);
NUSB_Result USB_DeviceSetFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX);
N
NUSB_Result USB_DeviceDoStatusInAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length);
NUSB_Result USB_DeviceDoStatusOutAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length);
N
NUSB_Result USB_DeviceDispatchEvent(void);
N
N#ifdef USB_INT_HANDLE_REQUIRED
Nvoid USB_IRQHandler(void);
N#endif /* USB_INT_HANDLE_REQUIRED */
N
N/** @defgroup USB_Device_Exported_Dummy_Functions USB Device Handler Samples
N  * @{
N  */
N
NUSB_Result USB_DeviceDummyGetStatus(USB_RequestRecipient_TypeDef Recipient, uint16_t wINDEX);
NUSB_Result USB_DeviceDummySetAddress(uint16_t wVALUE);
NUSB_Result USB_DeviceDummyGetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH);
NUSB_Result USB_DeviceDummySetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH);
Nuint8_t    USB_DeviceDummyGetConfiguration(void);
NUSB_Result USB_DeviceDummySetConfiguration(uint16_t wVALUE);
Nuint8_t    USB_DeviceDummyGetInterface(uint16_t wINDEX);
NUSB_Result USB_DeviceDummySetInterface(uint16_t wVALUE, uint16_t wINDEX);
NUSB_Result USB_DeviceDummySyncFrame(uint16_t wINDEX, uint8_t* DATA);
NUSB_Result USB_DeviceDummyClassRequest(void);
NUSB_Result USB_DeviceDummyVendorRequest(void);
NUSB_Result USB_DeviceDummyDataError(USB_EP_TypeDef EPx, uint32_t STS, uint32_t TS, uint32_t CTRL);
N
N/** @} */ /* End of group USB_Device_Exported_Dummy_Functions */
N
N/** @} */ /* End of group USB_Device_Exported_Functions */
N
N/** @} */ /* End of group USB_Device */
N
N/** @} */ /* End of group USB_DEVICE_AND_CDC */
N
N/** @} */ /* End of group MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_USB_DEVICE_H */
N
N/******************* (C) COPYRIGHT 2011 Phyton *********
N*
N* END OF FILE MDR32F9Qx_usb_device.h */
L 40 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library\MDR32F9Qx_usb_CDC.h" 2
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup USB_DEVICE_AND_CDC USB DEVICE AND CDC
N  * @{
N  */
N
N/** @defgroup USB_CDC USB Communication Device Class
N  * @{
N  */
N
N/** @defgroup USB_CDC_Exported_Types USB CDC Exported Types
N  * @{
N  */
N
N/**
N  * @brief CDC Class-Specific Setup Request Type enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_SEND_ENCAPSULATED_COMMAND = 0x00,
N  USB_CDC_GET_ENCAPSULATED_RESPONSE,
N  USB_CDC_SET_COMM_FEATURE,
N  USB_CDC_GET_COMM_FEATURE,
N  USB_CDC_CLEAR_COMM_FEATURE,
N  USB_CDC_SET_AUX_LINE_STATE        = 0x10,
N  USB_CDC_SET_HOOK_STATE,
N  USB_CDC_PULSE_SETUP,
N  USB_CDC_SEND_PULSE,
N  USB_CDC_SET_PULSE_TIME,
N  USB_CDC_RING_AUX_JACK,
N  USB_CDC_SET_LINE_CODING           = 0x20,
N  USB_CDC_GET_LINE_CODING,
N  USB_CDC_SET_CONTROL_LINE_STATE,
N  USB_CDC_SEND_BREAK,
N  USB_CDC_SET_RINGER_PARAMS         = 0x30,
N  USB_CDC_GET_RINGER_PARAMS,
N  USB_CDC_SET_OPERATION_PARAMS,
N  USB_CDC_GET_OPERATION_PARAMS,
N  USB_CDC_SET_LINE_PARAMS,
N  USB_CDC_GET_LINE_PARAMS,
N  USB_CDC_DIAL_DIGITS
N} USB_CDC_Class_Setup_TypeDef;
N
N
N/**
N  * @brief USB_CDC Serial State enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_bRxCarrier  = 0x01,
N  USB_CDC_bTxCarrier  = 0x02,
N  USB_CDC_bBreak      = 0x04,
N  USB_CDC_bRingSignal = 0x08,
N  USB_CDC_bFraming    = 0x10,
N  USB_CDC_bParity     = 0x20,
N  USB_CDC_bOverRun    = 0x40
N}USB_CDCSerialState_TypeDef;
N
N/**
N  * @brief USB_CDC Char Format enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_STOP_BITS1   = 0x0,
N  USB_CDC_STOP_BITS1_5 = 0x1,
N  USB_CDC_STOP_BITS2   = 0x2,
N}USB_CDC_CharFormat_TypeDef;
N
N/**
N  * @brief USB_CDC Parity Type enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_PARITY_NONE  = 0x0,
N  USB_CDC_PARITY_ODD   = 0x1,
N  USB_CDC_PARITY_EVEN  = 0x2,
N  USB_CDC_PARITY_MARK  = 0x3,
N  USB_CDC_PARITY_SPACE = 0x4
N}USB_CDC_ParityType_TypeDef;
N
N/**
N  * @brief USB_CDC Data Bits enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_DATA_BITS5  = 0x5,
N  USB_CDC_DATA_BITS6  = 0x6,
N  USB_CDC_DATA_BITS7  = 0x7,
N  USB_CDC_DATA_BITS8  = 0x8,
N  USB_CDC_DATA_BITS16 = 0xA
N}USB_CDC_DataBits_TypeDef;
N
N/**
N  * @brief USB_CDC Line Coding Structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t dwDTERate;
N  uint8_t  bCharFormat;
N  uint8_t  bParityType;
N  uint8_t  bDataBits;
N}USB_CDC_LineCoding_TypeDef;
N
N/**
N  * @brief USB_CDC Control Line State enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_DTR_PRESENT          = 0x1,
N  USB_CDC_RTS_ACTIVATE_CARRIER = 0x2
N}USB_CDC_ControlLineState_TypeDef;
N
N
N/**
N  * @brief USB_CDC Line State Report Notifications enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_RING_DETECT             = 0x09,
N  USB_CDC_SERIAL_STATE            = 0x20,
N  USB_CDC_CALL_STATE_CHANGE       = 0x28,
N  USB_CDC_LINE_STATE_CHANGE       = 0x29,
N  USB_CDC_CONNECTION_SPEED_CHANGE = 0x2A
N}USB_CDC_LineStateReport_TypeDef;
N
N/** @} */ /* End of group USB_CDC_Exported_Types */
N
N/** @defgroup USB_CDC_Exported_Constants USB CDC Exported Constants
N  * @{
N  */
N
N/** @} */ /* End of group USB_CDC_Exported_Constants */
N
N/** @defgroup USB_CDC_Exported_Variables USB CDC Exported Variables
N  * @{
N  */
N
N
N/** @} */ /* End of group USB_CDC_Exported_Variables */
N
N/** @defgroup USB_CDC_Exported_Macros USB CDC Exported Macros
N  * @{
N  */
N
N/** @defgroup USB_CDC_End_Point_Aliases USB CDC End Point Aliases
N  * @{
N  */
N
N#define USB_CDC_EP_SEND             USB_EP1
N#define USB_CDC_EP_RECEIVE          USB_EP3
N#define USB_CDC_EP_STATE            USB_EP2
N
N/** @} */ /* End of group USB_CDC_End_Point_Aliases */
N
N/** @} */ /* End of group USB_CDC_Exported_Macros */
N
N/** @defgroup USB_CDC_Exported_Functions USB CDC Exported Functions
N  * @{
N  */
N
NUSB_Result USB_CDC_Init(uint8_t* ReceiveBuffer, uint32_t DataPortionLength, FlagStatus StartReceiving);
N
NUSB_Result USB_CDC_SetReceiveBuffer(uint8_t* ReceiveBuffer, uint32_t DataPortionLength);
NUSB_Result USB_CDC_ReceiveStart(void);
NUSB_Result USB_CDC_ReceiveStop(void);
N
NUSB_Result USB_CDC_SendData(uint8_t* Buffer, uint32_t Length);
N
N#ifdef USB_CDC_STATE_REPORTING_SUPPORTED
SUSB_Result USB_CDC_ReportState(uint16_t LineState);
N#endif
N
N/** @defgroup USB_CDC_Exported_Overwritten_Device_Handlers USB CDC Overwritten Device Handlers
N  * @{
N  */
N
NUSB_Result USB_CDC_Reset(void);
NUSB_Result USB_CDC_GetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH);
NUSB_Result USB_CDC_ClassRequest(void);
N
N/** @} */ /* End of group USB_CDC_Exported_Overwritten_Device_Handlers */
N
N/** @defgroup USB_CDC_Exported_Dummy_Functions USB CDC Handler Samples
N  * @{
N  */
N
NUSB_Result USB_CDC_DummyDataReceive(uint8_t* Buffer, uint32_t Length);
NUSB_Result USB_CDC_DummyDataSent(void);
N
N#ifdef USB_CDC_ENCAPSULATION_SUPPORTED
SUSB_Result USB_CDC_DummySendEncapsulatedCMD(uint16_t wINDEX, uint16_t wLENGTH);
SUSB_Result USB_CDC_DummyGetEncapsulatedResp(uint16_t wINDEX, uint16_t wLENGTH);
N#endif
N
N#ifdef USB_CDC_COMM_FEATURE_SUPPORTED
SUSB_Result USB_CDC_DummyGetCommFeature(uint16_t wVALUE, uint16_t wINDEX, uint16_t* DATA);
SUSB_Result USB_CDC_DummySetCommFeature(uint16_t wVALUE, uint16_t wINDEX, uint16_t DATA);
SUSB_Result USB_CDC_DummyClearCommFeature(uint16_t wVALUE, uint16_t wINDEX);
N#endif
N
N#ifdef USB_CDC_LINE_CODING_SUPPORTED
NUSB_Result USB_CDC_DummyGetLineCoding(uint16_t wINDEX, USB_CDC_LineCoding_TypeDef* DATA);
NUSB_Result USB_CDC_DummySetLineCoding(uint16_t wINDEX, const USB_CDC_LineCoding_TypeDef* DATA);
N#endif
N
N#ifdef USB_CDC_CONTROL_LINE_STATE_SUPPORTED
SUSB_Result USB_CDC_DummyControlLineState(uint16_t wVALUE, uint16_t wINDEX);
N#endif
N
N#ifdef USB_CDC_LINE_BREAK_SUPPORTED
SUSB_Result USB_CDC_DummySendBreak(uint16_t wVALUE, uint16_t wINDEX);
N#endif
N
N/** @} */ /* End of group USB_CDC_Exported_Dummy_Functions */
N
N/** @} */ /* End of group USB_CDC_Exported_Functions */
N
N/** @} */ /* End of group USB_CDC */
N
N/** @} */ /* End of group USB_DEVICE_AND_CDC */
N
N/** @} */ /* End of group MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_USB_CDC_H */
N
N/******************* (C) COPYRIGHT 2011 Phyton *********
N*
N* END OF FILE MDR32F9Qx_usb_CDC.h */
L 31 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library\MDR32F9Qx_usb_default_handlers.h" 2
N
N/* Configuration file MDR32F9Qx_config.h should be included before */
N#ifndef __MDR32F9Qx_CONFIG_H
S#error "Configuration file MDR32F9Qx_config.h should be included before"
N#endif
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup USB_DEVICE_AND_CDC USB DEVICE AND CDC
N  * @{
N  */
N
N/** @defgroup USB_Configuring USB Configuring
N  * @{
N  */
N
N/** @defgroup USB_Device_Configuring USB Device Configuring
N  * @{
N  */
N
N/**
N  * @brief Bus reset handler
N  */
N
N#define USB_DEVICE_HANDLE_RESET  USB_DeviceReset()
N
N/**
N  * @brief Device enter suspended mode handler
N  */
N
N#define USB_DEVICE_HANDLE_SUSPEND  USB_DeviceSuspend()
N
N/**
N  * @brief Device exit from suspended mode handler
N  */
N
N#define USB_DEVICE_HANDLE_RESUME  USB_DeviceResume()
N
N/**
N  * @brief Control Setup Packet general processing handle
N  */
N
N#define USB_DEVICE_HANDLE_SETUP   USB_DeviceSetupPacket
N
N/**
N  * @brief GET_STATUS standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_GET_STATUS(Recipient, wINDEX)    USB_SUCCESS
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyGetStatus as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_GET_STATUS(Recipient, wINDEX)    USB_DeviceDummyGetStatus(Recipient, wINDEX)
N */
N
N/**
N  * @brief CLEAR_FEATURE standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_CLEAR_FEATURE(Recipient, wVALUE, wINDEX) \
N        USB_DeviceClearFeature(Recipient, wVALUE, wINDEX)
X#define USB_DEVICE_HANDLE_CLEAR_FEATURE(Recipient, wVALUE, wINDEX)         USB_DeviceClearFeature(Recipient, wVALUE, wINDEX)
N
N/**
N  * @brief SET_FEATURE standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_SET_FEATURE(Recipient, wVALUE, wINDEX)  \
N        USB_DeviceSetFeature(Recipient, wVALUE, wINDEX)
X#define USB_DEVICE_HANDLE_SET_FEATURE(Recipient, wVALUE, wINDEX)          USB_DeviceSetFeature(Recipient, wVALUE, wINDEX)
N
N/**
N  * @brief SET_ADDRESS standard request handler (preparation phase)
N  */
N
N#define USB_DEVICE_HANDLE_SET_ADDRESS(wVALUE)  USB_SUCCESS
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummySetAddress as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_SET_ADDRESS(wVALUE)  USB_DeviceDummySetAddress(wVALUE)
N */
N
N/**
N  * @brief GET_DESCRIPTOR standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_GET_DESCRIPTOR(wVALUE, wINDEX, wLENGTH)  USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyGetDescriptor as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_GET_DESCRIPTOR(wVALUE, wINDEX, wLENGTH)  USB_DeviceDummyGetDescriptor(wVALUE, wINDEX, wLENGTH)
N */
N
N/**
N  * @brief SET_DESCRIPTOR standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_SET_DESCRIPTOR(wVALUE, wINDEX, wLENGTH)  USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummySetDescriptor as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_SET_DESCRIPTOR(wVALUE, wINDEX, wLENGTH)  USB_DeviceDummySetDescriptor(wVALUE, wINDEX, wLENGTH)
N */
N
N/**
N  * @brief GET_CONFIGURATION standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_GET_CONFIGURATION  1
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyGetConfiguration as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_GET_CONFIGURATION  USB_DeviceDummyGetConfiguration()
N */
N
N/**
N  * @brief SET_CONFIGURATION standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_SET_CONFIGURATION(wVALUE)  \
N        ((wVALUE) == 1 ? USB_SUCCESS : USB_ERROR)
X#define USB_DEVICE_HANDLE_SET_CONFIGURATION(wVALUE)          ((wVALUE) == 1 ? USB_SUCCESS : USB_ERROR)
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummySetConfiguration as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_SET_CONFIGURATION(wVALUE)  USB_DeviceDummySetConfiguration(wVALUE)
N */
N
N/**
N  * @brief GET_INTERFACE standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_GET_INTERFACE(wINDEX)  0
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyGetInterface as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_GET_INTERFACE(wINDEX)  USB_DeviceDummyGetInterface(wINDEX)
N */
N
N/**
N  * @brief SET_INTERFACE standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_SET_INTERFACE(wVALUE, wINDEX) \
N        ((wINDEX) == 0 && (wVALUE) == 0 ? USB_SUCCESS : USB_ERROR)
X#define USB_DEVICE_HANDLE_SET_INTERFACE(wVALUE, wINDEX)         ((wINDEX) == 0 && (wVALUE) == 0 ? USB_SUCCESS : USB_ERROR)
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummySetInterface as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_SET_INTERFACE(wVALUE, wINDEX)  USB_DeviceDummySetInterface(wVALUE, wINDEX)
N */
N
N/**
N  * @brief SYNC_FRAME standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_SYNC_FRAME(wINDEX, DATA)  USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummySyncFrame as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_SYNC_FRAME(wINDEX, DATA)  USB_DeviceDummySyncFrame(wINDEX, DATA)
N */
N
N/**
N  * @brief Class-type request handler
N  */
N
N#define USB_DEVICE_HANDLE_CLASS_REQUEST  USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyClassRequest as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_CLASS_REQUEST  USB_DeviceDummyClassRequest()
N */
N
N/**
N  * @brief Vendor-type request handler
N  */
N
N#define USB_DEVICE_HANDLE_VENDOR_REQUEST  USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyVendorRequest as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_VENDOR_REQUEST  USB_DeviceDummyVendorRequest()
N */
N
N/** @} */ /* End of group USB_Device_Configuring */
N
N/** @defgroup USB_CDC_Configuring USB CDC Configuring
N  * @{
N  */
N
N#if (USB_DEVICE_CLASS == USB_DEVICE_CLASS_CDC)
X#if (2 == 2)
N/** @defgroup USB_CDC_Handlers USB CDC Handlers
N  * @{
N  */
N
N/** @defgroup USB_CDC_Exported_Handlers USB CDC Handler Definitions and defaults
N  * @{
N  */
N
N/**
N  * @brief Data receive request handler
N  */
N
N#define USB_CDC_HANDLE_DATA_RECEIVE(BUFFER, LENGTH)             USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_CDC_DummyDataReceive as an example and replacing it with your own function
N#define USB_CDC_HANDLE_DATA_RECEIVE(BUFFER, LENGTH)    USB_CDC_DummyDataReceive(BUFFER, LENGTH)
N */
N
N/**
N  * @brief Data sent completion handler
N  */
N
N#define USB_CDC_HANDLE_DATA_SENT                                USB_SUCCESS
N/* To redefine handler for your own function choose the variant below using
N * USB_CDC_DummyDataSent as an example and replacing it with your own function
N#define USB_CDC_HANDLE_DATA_SENT                  USB_CDC_DummyDataSent()
N */
N
N/**
N  * @brief Data send error handler
N  */
N
N#define USB_CDC_HANDLE_SEND_ERROR                               0
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyDataError as an example and replacing it with your own function
N#define USB_CDC_HANDLE_SEND_ERROR                 USB_DeviceDummyDataError
N */
N
N
N#ifdef USB_CDC_ENCAPSULATION_SUPPORTED
S/**
S  * @brief SEND_ENCAPSULATED_COMMAND Class-specific request handler
S  */
S
S#define USB_CDC_HANDLE_SEND_ENCAPSULATED_CMD(wINDEX, wLENGTH)   USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummySendEncapsulatedCMD as an example and replacing it with your own function
S#define USB_CDC_HANDLE_SEND_ENCAPSULATED_CMD(wINDEX, wLENGTH)    USB_CDC_DummySendEncapsulatedCMD(wINDEX, wLENGTH)
S */
S
S/**
S  * @brief GET_ENCAPSULATED_RESPONSE Class-specific request handler
S  */
S
S#define USB_CDC_HANDLE_GET_ENCAPSULATED_RESP(wINDEX, wLENGTH)   USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummyGetEncapsulatedResp as an example and replacing it with your own function
S#define USB_CDC_HANDLE_GET_ENCAPSULATED_RESP(wINDEX, wLENGTH)    USB_CDC_DummyGetEncapsulatedResp(wINDEX, wLENGTH)
S */
S
N#endif /* USB_CDC_ENCAPSULATION_SUPPORTED */
N
N#ifdef USB_CDC_COMM_FEATURE_SUPPORTED
S
S/**
S  * @brief GET_COMM_FEATURE Class-specific request handle
S  */
S
S#define USB_CDC_HANDLE_GET_COMM_FEATURE(wVALUE, wINDEX, DATA)   USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummyGetCommFeature as an example and replacing it with your own function
S#define USB_CDC_HANDLE_GET_COMM_FEATURE(wVALUE, wINDEX, DATA)    USB_CDC_DummyGetCommFeature(wVALUE, wINDEX, DATA)
S */
S
S/**
S  * @brief  SET_COMM_FEATURE Class-specific request handle
S  */
S
S#define USB_CDC_HANDLE_SET_COMM_FEATURE(wVALUE, wINDEX, DATA)   USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummySetCommFeature as an example and replacing it with your own function
S#define USB_CDC_HANDLE_SET_COMM_FEATURE(wVALUE, wINDEX, DATA)    USB_CDC_DummySetCommFeature(wVALUE, wINDEX, DATA)
S */
S
S/**
S  * @brief  CLEAR_COMM_FEATURE Class-specific request handle
S  */
S
S#define USB_CDC_HANDLE_CLEAR_COMM_FEATURE(wVALUE, wINDEX)       USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummyClearCommFeature as an example and replacing it with your own function
S#define USB_CDC_HANDLE_CLEAR_COMM_FEATURE(wVALUE, wINDEX)    USB_CDC_DummyClearCommFeature(wVALUE, wINDEX)
S */
S
N#endif /* USB_CDC_COMM_FEATURE_SUPPORTED */
N
N#ifdef USB_CDC_LINE_CODING_SUPPORTED
N/**
N  * @brief  GET_LINE_CODING Class-specific request handle
N  */
N
N#define USB_CDC_HANDLE_GET_LINE_CODING(wINDEX, DATA)            USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_CDC_DummyGetLineCoding as an example and replacing it with your own function
N#define USB_CDC_HANDLE_GET_LINE_CODING(wINDEX, DATA)    USB_CDC_DummyGetLineCoding(wINDEX, DATA)
N */
N
N/**
N  * @brief  SET_LINE_CODING Class-specific request handle
N  */
N
N#define USB_CDC_HANDLE_SET_LINE_CODING(wINDEX, DATA)            USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_CDC_DummySetLineCoding as an example and replacing it with your own function
N#define USB_CDC_HANDLE_SET_LINE_CODING(wINDEX, DATA)    USB_CDC_DummySetLineCoding(wINDEX, DATA)
N */
N
N#endif /* USB_CDC_LINE_CODING_SUPPORTED */
N
N#ifdef USB_CDC_CONTROL_LINE_STATE_SUPPORTED
S/**
S  * @brief SET_CONTROL_LINE_STATE Class-specific request handle
S  */
S
S#define USB_CDC_HANDLE_CONTROL_LINE_STATE(wVALUE, wINDEX)       USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummyControlLineState as an example and replacing it with your own function
S#define USB_CDC_HANDLE_SET_CONTROL_LINE_STATE(wVALUE, wINDEX)    USB_CDC_DummyControlLineState(wVALUE, wINDEX)
S */
S
N#endif /* USB_CDC_CONTROL_LINE_STATE_SUPPORTED */
N
N#ifdef USB_CDC_LINE_BREAK_SUPPORTED
S/**
S  * @brief  SEND_BREAK Class-specific request handle
S  */
S
S#define USB_CDC_HANDLE_BREAK(wVALUE, wINDEX)                    USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummySendBreak as an example and replacing it with your own function
S#define USB_CDC_HANDLE_BREAK(wVALUE, wINDEX)    USB_CDC_DummySendBreak(wVALUE, wINDEX)
S */
S
N#endif /* USB_CDC_LINE_BREAK_SUPPORTED */
N
N/**
N  * @brief Line state report send error handler
N  */
N
N#define USB_CDC_HANDLE_LINE_STATE_REPORT_SEND_ERROR             0
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyDataError as an example and replacing it with your own function
N#define USB_CDC_HANDLE_LINE_STATE_REPORT_SEND_ERROR   USB_DeviceDummyDataError
N */
N
N/** @} */ /* End of group USB_CDC_Exported_Handlers */
N
N/** @} */ /* End of group USB_CDC_Handlers */
N
N/** @defgroup USB_CDC_Used_Device_Handlers USB CDC Used Device Handlers
N  * @{
N  */
N
N#undef  USB_DEVICE_HANDLE_RESET
N#define USB_DEVICE_HANDLE_RESET                                   USB_CDC_Reset()
N
N#undef  USB_DEVICE_HANDLE_CLASS_REQUEST
N#define USB_DEVICE_HANDLE_CLASS_REQUEST                           USB_CDC_ClassRequest()
N
N#undef  USB_DEVICE_HANDLE_GET_DESCRIPTOR
N#define USB_DEVICE_HANDLE_GET_DESCRIPTOR(wVALUE, wINDEX, wLENGTH) \
N                   USB_CDC_GetDescriptor(wVALUE, wINDEX, wLENGTH)
X#define USB_DEVICE_HANDLE_GET_DESCRIPTOR(wVALUE, wINDEX, wLENGTH)                    USB_CDC_GetDescriptor(wVALUE, wINDEX, wLENGTH)
N
N/** @} */ /* End of group USB_CDC_Used_Device_Handlers */
N
N#endif /* USB_DEVICE_CLASS == USB_DEVICE_CLASS_CDC */
N
N/** @} */ /* End of group USB_CDC_Configuring */
N
N/** @} */ /* End of group USB_Configuring */
N
N/** @} */ /* End of group USB_DEVICE_AND_CDC */
N
N/** @} */ /* End of group MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_USB_DEFAULT_HANDLERS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE MDR32F9Qx_usb_default_handlers.h */
L 31 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library\MDR32F9Qx_usb_handlers.h" 2
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Examples MDR32F9Qx StdPeriph Examples
N  * @{
N  */
N
N/** @addtogroup __MDR32F9Q1_EVAL MDR32F9Q1 Evaluation Board
N  * @{
N  */
N
N/** @addtogroup  USB_Virtual_COM_Port_Echo_91 USB Virtual COM Port Echo
N  * @{
N  */
N
N/* Configuration file MDR32F9Qx_config.h should be included before */
N#ifndef __MDR32F9Qx_CONFIG_H
S#error "Configuration file MDR32F9Qx_config.h should be included before"
N#endif
N
N
N
N/** @defgroup USB_Virtual_COM_Port_Echo_Handlers USB Virtual COM Port Echo Handlers
N  * @{
N  */
N
N#undef USB_CDC_HANDLE_DATA_RECEIVE
N#define USB_CDC_HANDLE_DATA_RECEIVE(BUFFER, LENGTH)   USB_CDC_RecieveData(BUFFER, LENGTH)
N
N#ifdef USB_VCOM_SYNC
S#undef USB_CDC_HANDLE_DATA_SENT
S#define USB_CDC_HANDLE_DATA_SENT                                USB_CDC_DataSent();
N#endif /* USB_VCOM_SYNC */
N
N#ifdef USB_CDC_LINE_CODING_SUPPORTED
N#undef USB_CDC_HANDLE_GET_LINE_CODING
N#define USB_CDC_HANDLE_GET_LINE_CODING(wINDEX, DATA)  USB_CDC_GetLineCoding(wINDEX, DATA)
N#undef USB_CDC_HANDLE_SET_LINE_CODING
N#define USB_CDC_HANDLE_SET_LINE_CODING(wINDEX, DATA)  USB_CDC_SetLineCoding(wINDEX, DATA)
N#endif /* USB_CDC_LINE_CODING_SUPPORTED */
N
N#ifdef USB_CDC_CONTROL_LINE_STATE_SUPPORTED
S#undef USB_CDC_HANDLE_CONTROL_LINE_STATE
S#define USB_CDC_HANDLE_CONTROL_LINE_STATE(wVALUE, wINDEX)       USB_SUCCESS
N#endif /* USB_CDC_CONTROL_LINE_STATE_SUPPORTED */
N
N
N#ifdef USB_DEBUG_PROTO
S#undef USB_DEVICE_HANDLE_SETUP
S#define USB_DEVICE_HANDLE_SETUP   USB_DeviceSetupPacket_Debug
N#endif /* USB_DEBUG_PROTO */
N
N/** @} */ /* End of group USB_Virtual_COM_Port_Echo_Handlers */
N
N
N/** @defgroup USB_Virtual_COM_Port_Echo_Handler_Functions USB Virtual COM Port Echo Handler Functions
N  * @{
N  */
N
NUSB_Result USB_CDC_RecieveData(uint8_t* Buffer, uint32_t Length);
N
N#ifdef USB_CDC_LINE_CODING_SUPPORTED
NUSB_Result USB_CDC_GetLineCoding(uint16_t wINDEX, USB_CDC_LineCoding_TypeDef* DATA);
NUSB_Result USB_CDC_SetLineCoding(uint16_t wINDEX, const USB_CDC_LineCoding_TypeDef* DATA);
N#endif /* USB_CDC_LINE_CODING_SUPPORTED */
N
N#ifdef USB_VCOM_SYNC
SUSB_Result USB_CDC_DataSent(void);
N#endif /* USB_VCOM_SYNC */
N
N#ifdef USB_DEBUG_PROTO
SUSB_Result USB_DeviceSetupPacket_Debug(USB_EP_TypeDef EPx, const USB_SetupPacket_TypeDef* USB_SetupPacket);
N#endif /* USB_DEBUG_PROTO */
N
N/** @} */ /* End of group USB_Virtual_COM_Port_Echo_Handler_Functions */
N
N/** @} */ /* End of group USB_Virtual_COM_Port_Echo_91 */
N
N/** @} */ /* End of group __MDR32F9Q1_EVAL */
N
N/** @} */ /* End of group __MDR32F9Qx_StdPeriph_Examples */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_USB_HANDLERS_H */
N
N/******************* (C) COPYRIGHT 2011 Milandr *********************************
N*
N* END OF FILE MDR32F9Qx_usb_handlers.h */
L 29 "..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\USB_Library\MDR32F9Qx_usb_device.c" 2
N
N#define ASSERT_INFO_FILE_ID FILEID__MDR32F9X_USB_DEVICE_C
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup USB_DEVICE_AND_CDC USB DEVICE AND CDC
N  * @{
N  */
N
N/** @defgroup USB_Device_Framework_Private_Types USB Device Framework Private Types
N  * @{
N  */
N
N/** @} */ /* End of group USB_Device_Framework_Private_Types */
N
N/** @defgroup USB_EndPoint USB EndPoint
N  * @{
N  */
N
N/** @defgroup USB_EndPoint_Private_Types USB EndPoint Private Types
N  * @{
N  */
N
N/**
N  * @brief EndPoint States
N  */
N
Ntypedef enum
N{
N  USB_EP_NAK,
N  USB_EP_IDLE,
N  USB_EP_IN,
N  USB_EP_OUT,
N  USB_EP_SETUP,
N  USB_EP_STALL
N}USB_EPState_TypeDef;
N
N/**
N  * @brief EndPoint State Machine Context type
N  */
N
Ntypedef struct
N{
N  USB_EPState_TypeDef EP_State;
N  USB_StallType EP_Halt;
N  struct
N  {
N    struct
N    {
N      /* IN-OUT transactions buffer */
N      uint8_t *pBuffer;
N      uint32_t length, offset;
N      uint32_t bytesToAck;        /* number of bytes sent to host in
N                                     IN transaction but not acknowledged yet */
N    }IO_Buffer;
N    /* SETUP-transaction */
N    USB_SetupPacket_TypeDef *pSetupPacket;
N  }Buffer;
N  FlagStatus EP_WasScdone;
N  FlagStatus EP_WaitOut, EP_WaitSetup;
N  USB_EP_IO_Handler InHandler;
N  USB_EP_IO_Handler OutHandler;
N  USB_EP_Setup_Handler SetupHandler;
N  USB_EP_Error_Handler ErrorHandler;
N}USB_EPContext_TypeDef;
N
N/**
N  * @brief DATA bit change control
N  */
N
Ntypedef enum
N{
N  USB_DATA_BIT_KEEP,
N  USB_DATA_BIT_TOGGLE,
N  USB_DATA_BIT_DATA1,
N}USB_EPData_Bit_TypeDef;
N
N/** @} */ /* End of group USB_EndPoint_Private_Types */
N
N/** @defgroup USB_EndPoint_Private_Values USB EndPoint Private Values
N  * @{
N  */
N
N/**
N  * @brief EndPoint State Machine Context
N  */
N
NUSB_EPContext_TypeDef USB_EPContext[Num_USB_EndPoints];
N
N/** @} */ /* End of group USB_EndPoint_Private_Values */
N
N/** @defgroup USB_EndPoint_Private_Constants USB EndPoint Private Constants
N  * @{
N  */
N
N/** @} */ /* End of group USB_EndPoint_Private_Constants */
N
N/** @defgroup USB_EndPoint_Private_Macros USB EndPoint Private Macros
N  * @{
N  */
N
N#define TX_FIFO_FORCE_EMPTY(EndPoint)        USB_SetSEPxTXFDC(EndPoint, 1)
N#define RX_FIFO_FORCE_EMPTY(EndPoint)        USB_SetSEPxRXFC(EndPoint, 1)
N#define EPx_RX_FIFO_DATA(EndPoint)           USB_GetSEPxRXFD(EndPoint)
N
N/** @} */ /* End of group USB_EndPoint_Private_Macros */
N
N/** @defgroup USB_EndPoint_Private_FunctionPrototypes USB EndPoint Private Function Prototypes
N  * @{
N  */
N
Nstatic void USB_EP_sendInDataPortion(USB_EP_TypeDef EPx, USB_EPData_Bit_TypeDef DataBitChange);
Nstatic void USB_EP_SetReady(USB_EP_TypeDef EPx, uint32_t val);
N
N/** @} */ /* End of group USB_EndPoint_Private_FunctionPrototypes */
N
N/** @defgroup USB_EndPoint_Private_Functions USB EndPoint Private Functions
N  * @{
N  */
N
N/**
N  * @brief  Initial EndPoint setup
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  * @param  USB_EP_Ctrl: Value, controlling EPISOEN, EPDATASEQ bits
N  *         of corresponding USB_SEPx.CTRL register.
N  * @param  onError: User's handler to be called on any error with data transmitting
N  *                   via this End Point (may be 0).
N  *
N  * @retval USB_Result status (USB_SUCCESS or USB_ERROR).
N  */
N
NUSB_Result USB_EP_Init(USB_EP_TypeDef EPx, uint32_t USB_EP_Ctrl, USB_EP_Error_Handler onError)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N
N  /* EndPoint context preparation */
N  ep->Buffer.IO_Buffer.pBuffer    = 0;
N  ep->Buffer.IO_Buffer.length     = 0;
N  ep->Buffer.IO_Buffer.bytesToAck = 0;
N  ep->Buffer.IO_Buffer.offset     = 0;
N  ep->Buffer.pSetupPacket         = 0;
N  ep->InHandler                   = 0;
N  ep->OutHandler                  = 0;
N  ep->SetupHandler                = 0;
N  ep->ErrorHandler                = onError;
N  ep->EP_Halt                     = USB_STALL_PROTO;
N  ep->EP_State                    = USB_EP_NAK;
N  ep->EP_WasScdone                = RESET;
N
N  USB_SetSEPxCTRL(EPx, USB_EP_Ctrl);
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Resets the EndPoint to NAK state
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_EP_Reset(USB_EP_TypeDef EPx)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N
N  ep->EP_State = USB_EP_NAK;
N  ep->EP_WasScdone = RESET;
N
N  USB_SetSEPxCTRL(EPx, USB_SEPx_CTRL_EPISOEN_Reset  |                           /* Reset Isohronic */
X  USB_SetSEPxCTRL(EPx, (uint32_t)(1 << (4 + 16))  |                            
N                       USB_SEPx_CTRL_EPRDY_NotReady |                           /* Reset READY */
X                       (uint32_t)(1 << (1 + 16)) |                            
N                       USB_SEPx_CTRL_EPEN_Enable);                              /* Set ENABLE */
X                       (uint32_t)(1 << 0));                               
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Switches the EndPoint to IDLE (wait for transaction) or NAK state
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @retval USB_Result.
N  *
N  * @note   IDLE state and EPRDY bit are set if OUT/SETUP transaction is expected.
N  *         Otherwise, this function switches to NAK state.
N  */
N
NUSB_Result USB_EP_Idle(USB_EP_TypeDef EPx)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N  uint32_t val = USB_SEPx_CTRL_EPSSTALL_NotReply;                               /* Reset STALL reply */
X  uint32_t val = (uint32_t)(1 << (3 + 16));                                
N
N  if (ep->EP_WaitOut || ep->EP_WaitSetup)
N  {
N    ep->EP_State = USB_EP_IDLE;
N    val |= USB_SEPx_CTRL_EPRDY_Ready;                                           /* Set READY */
X    val |= (uint32_t)(1 << 1);                                            
N  }
N  else
N  {
N    ep->EP_State = USB_EP_NAK;
N  }
N  ep->EP_Halt = USB_STALL_PROTO;
N
N  USB_EP_SetReady(EPx, val);
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Switches the EndPoint to STALL state (protocol stall
N  *         or halt) or NAK state, if STALL is prohibited.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  bHalt: Specifies whether the STALL state is a HALT
N  *         This parameter can be: USB_STALL_PROTO or USB_STALL_HALT.
N  *
N  * @retval USB_Result.
N  *
N  * @note   If protocol stall is ordered, but the EndPoint doesn't accept
N  *         SETUP transactions, EndPoint is switched to NAK state.
N  */
N
NUSB_Result USB_EP_Stall(USB_EP_TypeDef EPx, USB_StallType bHalt)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N  uint32_t val = 0;
N
N  if (bHalt == USB_STALL_HALT && EPx == USB_EP0)
N  {
N    /* No functional stall for Default Control Pipe */
N    return USB_ERROR;
N  }
N
N  if (bHalt == USB_STALL_HALT || ep->EP_WaitSetup)
N  {
N    ep->EP_Halt  = bHalt;
N    ep->EP_State = USB_EP_STALL;
N    val = USB_SEPx_CTRL_EPSSTALL_Reply |                                          /* Set STALL reply */
X    val = (uint32_t)(1 << 3) |                                           
N          USB_SEPx_CTRL_EPRDY_Ready;                                              /* Set READY */
X          (uint32_t)(1 << 1);                                               
N  }
N
N  USB_EP_SetReady(EPx, val);
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Indicates that there is data to be sent to the host by this
N  *         EndPoint with one or several IN-transactions.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  Buffer: Pointer to the user's buffer with data to be sent.
N  *
N  * @param  Length: Length of data.
N  *
N  * @param  onInDone: User's handler to be called when data transfer is
N  *                   successfully complete (may be 0).
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_EP_doDataIn(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onInDone)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N  /* Setup IN Data stage starts with DATA1 */
N  USB_EPData_Bit_TypeDef StartInStage = (ep->EP_WaitSetup ? USB_DATA_BIT_DATA1 : USB_DATA_BIT_TOGGLE);
N
N  /* Set EndPoint context */
N  ep->Buffer.IO_Buffer.pBuffer    = Buffer;
N  ep->Buffer.IO_Buffer.length     = Length;
N  ep->Buffer.IO_Buffer.bytesToAck = MAX_PACKET_SIZE;
X  ep->Buffer.IO_Buffer.bytesToAck = 32;
N  ep->Buffer.IO_Buffer.offset     = 0;
N  ep->InHandler                   = onInDone;
N  ep->EP_State                    = USB_EP_IN;
N
N  /* Send first data portion */
N  USB_EP_sendInDataPortion(EPx, StartInStage);
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Indicates that we are willing to receive Length or more bytes of data
N  *         from the host to this EndPoint with OUT transaction(s).
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  Buffer: Pointer to the user's buffer to place received data to.
N  *                 The total buffer size should be equal or greater then
N  *                 ((Length / MAX_PACKET_LENGTH) + 1) * MAX_PACKET_LENGTH)
N  *
N  * @param  Length: The minimal data length to receive before the transfer is
N  *                 treated as complete.
N  *
N  * @param  onOutDone: User's handler to be called after Length or more bytes of
N  *                    data is successfully received (may be 0).
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_EP_doDataOut(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onOutDone)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N
N  /* Set EndPoint context */
N  ep->Buffer.IO_Buffer.pBuffer    = Buffer;
N  ep->Buffer.IO_Buffer.length     = Length;
N  ep->Buffer.IO_Buffer.bytesToAck = 0;
N  ep->Buffer.IO_Buffer.offset     = 0;
N  ep->OutHandler                  = onOutDone;
N  ep->EP_WaitOut                  = SET;
N
N  /* Start awaiting for OUT transaction */
N  USB_EP_Idle(EPx);
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Indicates that we are willing to receive (repeatedly) Setup Control
N  *         Transactions with this EndPoint.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  USB_SetupPacket: Pointer to the user's buffer to place
N  *         received setup packet.
N  *
N  * @param  onSetupPacket: User's handler to be called when setup packet
N  *         is received.
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_EP_setSetupHandler(USB_EP_TypeDef EPx, USB_SetupPacket_TypeDef* USB_SetupPacket, USB_EP_Setup_Handler onSetupPacket)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N
N  /* Set EndPoint context */
N  ep->Buffer.pSetupPacket         = USB_SetupPacket;
N  ep->Buffer.IO_Buffer.length     = 0;
N  ep->Buffer.IO_Buffer.bytesToAck = 0;
N  ep->Buffer.IO_Buffer.offset     = 0;
N  ep->SetupHandler                = onSetupPacket;
N  ep->EP_WaitSetup                = onSetupPacket ? SET : RESET;
N
N  /* Start awaiting for SETUP transaction */
N  USB_EP_Idle(EPx);
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  EndPoint state machine implementation.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  USB_IT: SLAVE controller interrupt flags (USB_SIS register value).
N  *
N  * @retval USB_Result.
N  *
N  * @note   This function should be called at appropriate rate to handle possible
N  *         EndPoint events.
N  */
N
NUSB_Result USB_EP_dispatchEvent(USB_EP_TypeDef EPx, uint32_t USB_IT)
N{
N  FlagStatus nextIteration = RESET;
N  USB_Result result = USB_SUCCESS;
N  uint32_t tmpSTS, tmpTS, tmpCTRL;
N  uint32_t i, count;
N  USB_EPContext_TypeDef *ep;
N
N  tmpSTS = USB_GetSEPxSTS(EPx);
N  tmpTS  = (USB_GetSEPxTS(EPx) & USB_SEPx_TS_SCTTYPE_Msk);
X  tmpTS  = (USB_GetSEPxTS(EPx) & (uint32_t)(0x00000003));
N  tmpCTRL = USB_GetSEPxCTRL(EPx);
N
N  ep = USB_EPContext + EPx;
N
N  /* Remember SCDONE event in the EndPoint context */
N  if (USB_IT & USB_SIS_SCTDONE)
X  if (USB_IT & ((uint32_t)0x00000001))
N  {
N    ep->EP_WasScdone = SET;
N  }
N
N  do
N  {
N    switch (ep->EP_State)
N    {
N      /* USB_EP_NAK */
N      case USB_EP_NAK:
N      {
N        /* Fast return if EndPoint in the NAK state */
N        return USB_SUCCESS;
N      }
N
N      /* USB_EP_IDLE */
N      case USB_EP_IDLE:
N      {
N        if (!(tmpCTRL & USB_SEP_CTRL_EPRDY) && ep->EP_WasScdone)
X        if (!(tmpCTRL & ((uint32_t)0x00000002)) && ep->EP_WasScdone)
N        {
N          /* EPRDY dropped - event for this End Point */
N          if ((tmpTS == USB_SEPx_TS_SCTTYPE_Outdata) && ep->EP_WaitOut)
X          if ((tmpTS == (uint32_t)(0x00000002)) && ep->EP_WaitOut)
N          {
N            /* OUT transaction started: switch into the OUT state and continue processing there */
N            ep->EP_State = USB_EP_OUT;
N            ep->EP_WaitOut = RESET;
N            nextIteration = SET;
N          }
N          else if ((tmpTS == USB_SEPx_TS_SCTTYPE_Setup) && ep->EP_WaitSetup)
X          else if ((tmpTS == (uint32_t)(0x00000000)) && ep->EP_WaitSetup)
N          {
N            /* SETUP transaction started: switch into the SETUP state and continue processing there */
N            ep->EP_State = USB_EP_SETUP;
N            nextIteration = SET;
N          }
N          else
N          {
N            /* Unexpected transaction: switch into STALL/NAK state and return error */
N            result = USB_ERROR;
N            USB_EP_Stall(EPx, USB_STALL_PROTO);
N          }
N        }
N        break;
N      }
N
N      /* USB_EP_IN */
N      case USB_EP_IN:
N      {
N        /* Analyze event type */
N        if ((!(tmpCTRL & USB_SEP_CTRL_EPRDY)) && ep->EP_WasScdone &&
X        if ((!(tmpCTRL & ((uint32_t)0x00000002))) && ep->EP_WasScdone &&
N            (tmpTS == USB_SEPx_TS_SCTTYPE_In) && (tmpSTS & USB_SEP_STS_SCACKRXED))
X            (tmpTS == (uint32_t)(0x00000001)) && (tmpSTS & ((uint32_t)0x00000040)))
N        {
N          /* 1. ACK event */
N          ep->Buffer.IO_Buffer.offset += ep->Buffer.IO_Buffer.bytesToAck;
N          if (ep->Buffer.IO_Buffer.offset >= ep->Buffer.IO_Buffer.length)
N          {
N            /* If offset >= length (transfer is over), indicate it with NAK state
N             * and call handler (if present) */
N            ep->EP_State = USB_EP_NAK;
N            if (ep->InHandler != 0)
N            {
N              result = ep->InHandler(EPx, ep->Buffer.IO_Buffer.pBuffer, ep->Buffer.IO_Buffer.length);
N            }
N
N            if (result == USB_SUCCESS)
N            {
N              /* If no other transaction is ordered by user or no data stage of SETUP
N               * packet (state isn't changed), go to NAK/IDLE state */
N              if (ep->EP_State == USB_EP_NAK)
N              {
N                USB_EP_Idle(EPx);
N              }
N            }
N            else
N            {
N              /* If user's handler indicated error, go to STALL/NAK state */
N              USB_EP_Stall(EPx, USB_STALL_PROTO);
N            }
N          }
N          else
N          {
N            /* If there is any data to send remaining, send next portion */
N            USB_EP_sendInDataPortion(EPx, USB_DATA_BIT_TOGGLE);
N          }
N        }
N        else if (tmpSTS & (USB_SEP_STS_SCRXOF
X        else if (tmpSTS & (((uint32_t)0x00000004)
N                         | USB_SEP_STS_SCCRCERR
X                         | ((uint32_t)0x00000001)
N                         | USB_SEP_STS_SCBSERR
X                         | ((uint32_t)0x00000002)
N                         | USB_SEP_STS_SCRXTO))
X                         | ((uint32_t)0x00000008)))
N        {
N          /* 2. Error events - call error handler (if present). Switch temporarily to NAK
N           * to check if user orders another transaction */
N          ep->EP_State = USB_EP_NAK;
N          if (ep->ErrorHandler != 0)
N          {
N            result = ep->ErrorHandler(EPx, tmpSTS, tmpTS, tmpCTRL);
N          }
N          if (result == USB_SUCCESS)
N          {
N            if (ep->EP_State == USB_EP_NAK)
N            {
N              /* If there is no user's handler or USB_SUCCESS returned and no other transaction
N               * is started, retry with current data portion */
N              ep->EP_State = USB_EP_IN;
N              USB_EP_sendInDataPortion(EPx, USB_DATA_BIT_KEEP);
N            }
N          }
N          else
N          {
N            /* If user's handler indicated error, go to STALL/NAK state */
N            USB_EP_Stall(EPx, USB_STALL_PROTO);
N          }
N        }
N        break;
N      }
N
N      /* USB_EP_OUT */
N      case USB_EP_OUT:
N      {
N        /* Check for event */
N        if (!(tmpCTRL & USB_SEP_CTRL_EPRDY) && ep->EP_WasScdone)
X        if (!(tmpCTRL & ((uint32_t)0x00000002)) && ep->EP_WasScdone)
N        {
N          nextIteration = RESET;
N
N          /* Read data packet */
N          count = USB_GetSEPxRXFDC(EPx);
N          for (i = 0; i < count; i++)
N          {
N            ep->Buffer.IO_Buffer.pBuffer[ep->Buffer.IO_Buffer.offset + i] = EPx_RX_FIFO_DATA(EPx);
X            ep->Buffer.IO_Buffer.pBuffer[ep->Buffer.IO_Buffer.offset + i] = USB_GetSEPxRXFD(EPx);
N          }
N          RX_FIFO_FORCE_EMPTY(EPx);
X          USB_SetSEPxRXFC(EPx, 1);
N          ep->Buffer.IO_Buffer.offset += count;
N
N          /* If offset >= length (transfer is over), indicate it with NAK state
N           * and call handler (if present) */
N          if (ep->Buffer.IO_Buffer.offset >= ep->Buffer.IO_Buffer.length)
N          {
N            ep->EP_State = USB_EP_NAK;
N            if (ep->OutHandler != 0)
N            {
N              result = ep->OutHandler(EPx, ep->Buffer.IO_Buffer.pBuffer, ep->Buffer.IO_Buffer.offset);
N            }
N
N            if (result == USB_SUCCESS)
N            {
N              /* If no other transaction is ordered by user or no data stage of SETUP
N               * packet (state isn't changed), go to NAK/IDLE state */
N              if (ep->EP_State == USB_EP_NAK)
N              {
N                USB_EP_Idle(EPx);
N              }
N            }
N            else
N            {
N              /* If user's handler indicated error, go to STALL/NAK state */
N              USB_EP_Stall(EPx, USB_STALL_PROTO);
N            }
N          }
N          else
N          {
N            /* If offset < length, wait for another portion */
N            USB_EP_SetReady(EPx, USB_SEPx_CTRL_EPRDY_Ready);
X            USB_EP_SetReady(EPx, (uint32_t)(1 << 1));
N          }
N        }
N        break;
N      }
N
N      /* USB_EP_SETUP */
N      case USB_EP_SETUP:
N      {
N        /* Check for event */
N        if (ep->EP_WasScdone)
N        {
N          assert_param(ep->SetupHandler);
X          ((void)0);
N
N          /* Read setup packet and check for correct size (8 bytes) */
N          count = USB_GetSEPxRXFDC(EPx);
N          if (count == 8)
N          {
N            for (i = 0; i < count; i++)
N            {
N              ((uint8_t*)ep->Buffer.pSetupPacket)[i] = EPx_RX_FIFO_DATA(EPx);
X              ((uint8_t*)ep->Buffer.pSetupPacket)[i] = USB_GetSEPxRXFD(EPx);
N            }
N            RX_FIFO_FORCE_EMPTY(EPx);
X            USB_SetSEPxRXFC(EPx, 1);
N
N            /* Call the handler */
N            result = ep->SetupHandler(EPx, ep->Buffer.pSetupPacket);
N
N            if (result == USB_SUCCESS)
N            {
N              /* If no other transaction is ordered by user or no data stage of SETUP
N               * packet (state isn't changed), go to NAK/IDLE state */
N              if (ep->EP_State == USB_EP_SETUP)
N              {
N                USB_EP_Idle(EPx);
N              }
N            }
N            else
N            {
N              /* If user's handler indicated error, go to STALL/NAK state */
N              USB_EP_Stall(EPx, USB_STALL_PROTO);
N            }
N          }
N          else /* Incorrect packet size */
N          {
N            RX_FIFO_FORCE_EMPTY(EPx);
X            USB_SetSEPxRXFC(EPx, 1);
N            result = USB_ERROR;
N            /* Switch into STALL state */
N            USB_EP_Stall(EPx, USB_STALL_PROTO);
N          }
N        }
N        nextIteration = RESET;
N        break;
N      }
N
N      /* USB_EP_STALL */
N      case USB_EP_STALL:
N      {
N        if (!(tmpCTRL & USB_SEP_CTRL_EPRDY))
X        if (!(tmpCTRL & ((uint32_t)0x00000002)))
N        {
N          /* EPRDY dropped - event for this End Point */
N          if (ep->EP_Halt == USB_STALL_HALT)
N          {
N            USB_EP_Stall(EPx, USB_STALL_HALT);
N          }
N          else
N          {
N            USB_EP_Idle(EPx);
N          }
N        }
N        break;
N      }
N    }
N  } while (nextIteration);
N
N  return result;
N}
N
N/**
N  * @brief  Prepares EndPoint for IN transaction accepting (service function).
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  DataBitChange: DATA bit handling.
N  *         This parameter can be one of the following values:
N  *           @arg USB_DATA_BIT_KEEP: Don't change DATA bit.
N  *           @arg USB_DATA_BIT_TOGGLE: Toggle DATA0/DATA1.
N  *           @arg USB_DATA_BIT_DATA1: Set DATA1.
N  *
N  * @retval USB_Result.
N  */
N
Nstatic void USB_EP_sendInDataPortion(USB_EP_TypeDef EPx, USB_EPData_Bit_TypeDef DataBitChange)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N  uint32_t i, total;
N
N  assert_param(ep->EP_State == USB_EP_IN);
X  ((void)0);
N
N  /* Clean TX FIFO buffer */
N  TX_FIFO_FORCE_EMPTY(EPx);
X  USB_SetSEPxTXFDC(EPx, 1);
N
N  /* Adjust DATA bit */
N  switch (DataBitChange)
N  {
N    case USB_DATA_BIT_KEEP:
N      break;
N    case USB_DATA_BIT_TOGGLE:
N      USB_SEPxToggleEPDATASEQ(EPx);
N      break;
N    case USB_DATA_BIT_DATA1:
N      USB_SetSEPxCTRL(EPx, USB_SEPx_CTRL_EPDATASEQ_Data1);
X      USB_SetSEPxCTRL(EPx, (uint32_t)(1 << 2));
N      break;
N  }
N
N  /* Copy data portion into TX FIFO buffer */
N  total = (ep->Buffer.IO_Buffer.offset + ep->Buffer.IO_Buffer.bytesToAck < ep->Buffer.IO_Buffer.length ?
N            ep->Buffer.IO_Buffer.offset + ep->Buffer.IO_Buffer.bytesToAck : ep->Buffer.IO_Buffer.length);
N  for (i = ep->Buffer.IO_Buffer.offset; i < total; i++)
N  {
N    USB_SetSEPxTXFD(EPx, ep->Buffer.IO_Buffer.pBuffer[i]);
N  };
N
N  /* Set EPRDY bit */
N  USB_EP_SetReady(EPx, USB_SEPx_CTRL_EPRDY_Ready);
X  USB_EP_SetReady(EPx, (uint32_t)(1 << 1));
N}
N
N
N/**
N  * @brief  Sets EPRDY and STALL bits (service function).
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  val: Value for SEPxCTRL register.
N  *
N  * @retval USB_Result.
N  *
N  * @note   Before setting EPRDY, the function clears pending
N  *         bits (especially SCTDONE), to indicate that previous
N  *         transaction is complete.
N  */
N
Nstatic void USB_EP_SetReady(USB_EP_TypeDef EPx, uint32_t val)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N
N  /* Clear pending bits */
N  USB_SetSIS(USB_SIS_Msk);
X  USB_SetSIS(((uint32_t)0x00000001) | ((uint32_t)0x00000002) | ((uint32_t)0x00000004) | ((uint32_t)0x00000008) | ((uint32_t)0x00000010));
N
N  ep->EP_WasScdone = RESET;
N
N  /* Set CTRL bits */
N  USB_SetSEPxCTRL(EPx, val);
N}
N
N/** @} */ /* End of group USB_EndPoint_Private_Functions */
N
N/** @} */ /* End of group USB_EndPoint */
N
N/** @defgroup USB_Device USB Device
N  * @{
N  */
N
N/** @defgroup USB_Device_Private_Types USB Device Private Types
N  * @{
N  */
N
N/** @} */ /* End of group USB_Device_Private_Types */
N
N/** @defgroup USB_Device_Private_Constants USB Device Private Constants
N  * @{
N  */
N
N/** @} */ /* End of group USB_Device_Private_Constants */
N
N/** @defgroup USB_Device_Private_Variables USB Device Private Variables
N  * @{
N  */
N
NUSB_SetupPacket_TypeDef USB_CurrentSetupPacket;
NUSB_DeviceContext_TypeDef USB_DeviceContext;
Nstatic uint8_t SetupPacketData[2];
N
N/** @} */ /* End of group USB_Device_Private_Variables */
N
N/** @defgroup USB_Device_Private_Macros USB Device Private Macros
N  * @{
N  */
N
N/** @} */ /* End of group USB_Device_Private_Macros */
N
N/** @defgroup USB_Device_Private_FunctionPrototypes USB Device Private Function Prototypes
N  * @{
N  */
N
Nstatic USB_Result USB_Device_setAddressWork(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length);
N
N/** @} */ /* End of group USB_Device_Private_FunctionPrototypes */
N
N/** @defgroup USB_Device_Private_Functions USB Device Private Functions
N  * @{
N  */
N
N/**
N  * @brief  Initializes the USB peripheral according to the specified
N  *         parameters in the USB_Clock_InitStruct.
N  * @param  USB_Clock_InitStruct: pointer to a USB_Clock_TypeDef structure
N  *         that contains the configuration information for the USB Clock.
N  *
N  * @param  USB_DeviceBUSParam: pointer to a USB_DeviceBUSParam_TypeDef structure
N  *         that contains the configuration information for the USB BUS
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_DeviceInit(const USB_Clock_TypeDef* USB_Clock_InitStruct, USB_DeviceBUSParam_TypeDef* USB_DeviceBUSParam)
N{
N  /* Check the parameters */
N  assert_param(IS_USB_PULL(USB_DeviceBUSParam->PULL));
X  ((void)0);
N  assert_param(IS_USB_SPEED(USB_DeviceBUSParam->SPEED));
X  ((void)0);
N  assert_param(IS_USB_MODE(USB_DeviceBUSParam->MODE));
X  ((void)0);
N
N  /* Set USB clocks perform controller reset */
N  USB_BRGInit(USB_Clock_InitStruct);
N  USB_Reset();
N  /* Set pulls and Device mode */
N  USB_SetHSCR(USB_HSCR_HOST_MODE_Device);
X  USB_SetHSCR((uint32_t)(1 << (0 + 16)));
N  USB_SetHSCR(USB_DeviceBUSParam->PULL);
N  /* Set speed, polarity and enable end points */
N  USB_SetSC(USB_DeviceBUSParam->SPEED | USB_DeviceBUSParam->MODE | USB_SC_SCGEN_Set);
X  USB_SetSC(USB_DeviceBUSParam->SPEED | USB_DeviceBUSParam->MODE | (uint32_t)(1 << 0));
N  /* Setup EP0 */
N  USB_EP_Init(USB_EP0, USB_SEPx_CTRL_EPEN_Enable | USB_SEPx_CTRL_EPDATASEQ_Data1, 0);
X  USB_EP_Init(USB_EP0, (uint32_t)(1 << 0) | (uint32_t)(1 << 2), 0);
N  USB_EP_setSetupHandler(USB_EP0, &USB_CurrentSetupPacket, USB_DEVICE_HANDLE_SETUP);
X  USB_EP_setSetupHandler(USB_EP0, &USB_CurrentSetupPacket, USB_DeviceSetupPacket);
N
N  USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_UNKNOWN;
N  USB_DeviceContext.Address = 0;
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Enables the USB peripheral.
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_DevicePowerOn(void)
N{
N  USB_SetHSCR(USB_HSCR_EN_RX_Set | USB_HSCR_EN_TX_Set);
X  USB_SetHSCR((uint32_t)(1 << 3) | (uint32_t)(1 << 2));
N  USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_POWERED;
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Disables the USB peripheral.
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_DevicePowerOff(void)
N{
N  USB_SetHSCR(USB_HSCR_EN_RX_Reset);
X  USB_SetHSCR((uint32_t)(1 << (3 + 16)));
N  USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_UNKNOWN;
N
N  return USB_SUCCESS;
N}
N
N#ifdef USB_REMOTE_WAKEUP_SUPPORTED
S/**
S  * @brief  Initiates host remote wakeup
S  *
S  * @param  None
S  *
S  * @retval USB_Result.
S  */
S
SUSB_Result USB_DeviceRemoteWakeUp(void)
S{
S  return USB_SUCCESS;
S}
N#endif /* USB_REMOTE_WAKEUP_SUPPORTED */
N
N/** @defgroup USB_Device_Private_Handlers USB Device Handlers implementation
N  * @{
N  */
N
N/**
N  * @brief  Reset bus handler
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_DeviceReset(void)
N{
N  USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_DEFAULT;
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Performs all necessary actions on entering to SUSPENDED state
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_DeviceSuspend(void)
N{
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Performs all necessary actions on exit from SUSPENDED state
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_DeviceResume(void)
N{
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Control Setup Packet processing dispatcher (set as EP0 setup
N  *         packet handler).
N  *
N  * @param  EPx: USB Control EndPoint (EP0) number.
N  *
N  * @param  USB_SetupPacket: Pointer to a USB_SetupPacket_TypeDef structure
N  *         that contains received setup packet contents (on success)
N  *
N  * @retval USB_Result.
N  *
N  * @note   This function interface reflects EndPoint setup packet handler
N  *         requirements. Request setup packet data is placed into
N  *         USB_CurrentSetupPacket variable to be accessible from the
N  *         specific request type handlers.
N  */
N
NUSB_Result USB_DeviceSetupPacket(USB_EP_TypeDef EPx, const USB_SetupPacket_TypeDef* USB_SetupPacket)
N{
N  USB_RequestType_TypeDef requestType;
N  USB_RequestTypeDT_TypeDef requestDirection;
N
N  USB_Result result = USB_SUCCESS;
N  uint16_t wValue, wIndex, wLength;
N
N  /* Check the parameters */
N  assert_param(IS_USB_ENDPOINT(EPx));
X  ((void)0);
N
N  /* Determine request type */
N  requestType = (USB_RequestType_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_REQUEST_TYPE_Msk);
X  requestType = (USB_RequestType_TypeDef)(USB_SetupPacket->mRequestTypeData & 0x60);
N  requestDirection = (USB_RequestTypeDT_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_REQUEST_DT_Msk);
X  requestDirection = (USB_RequestTypeDT_TypeDef)(USB_SetupPacket->mRequestTypeData & 0x80);
N
N  /* Process request */
N  switch (requestType)
N  {
N    /* Standard request */
N    case USB_TYPE_STANDARD: {
N      USB_RequestRecipient_TypeDef recipient;
N      USB_EP_IO_Handler statusAckHandler = 0;
N
N      wValue = USB_SetupPacket->wValue;
N      wIndex = USB_SetupPacket->wIndex;
N      wLength = USB_SetupPacket->wLength;
N
N      /* Recipient check */
N      recipient = (USB_RequestRecipient_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_RECIPIENT_TYPE_Msk);
X      recipient = (USB_RequestRecipient_TypeDef)(USB_SetupPacket->mRequestTypeData & 0x1F);
N      if (!IS_VALID_USB_RECIPIENT(recipient)) {
X      if (!((recipient) <= USB_RECIPIENT_OTHER)) {
N        result = USB_ERR_INV_REQ;
N        break;
N      }
N      /* Specific requests */
N      switch (USB_SetupPacket->bRequest)
N      {
N        /* GET_STATUS */
N        case USB_GET_STATUS:
N          if (requestDirection != USB_DEVICE_TO_HOST ||
N             (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
N              recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
N          {
N            result = USB_ERROR;
N          }
N          else
N          {
N            /* Give user a chance to set flags in the device context */
N            result = USB_DEVICE_HANDLE_GET_STATUS(recipient, wIndex);
X            result = USB_SUCCESS;
N            if (result == USB_SUCCESS)
N            {
N              switch (recipient)
N              {
N                /* Device - return Self Powered and Remote Wakeup status */
N                case USB_RECIPIENT_DEVICE:
N                  SetupPacketData[0] = 0
N#ifdef USB_SELF_POWERED_SUPPORTED
S                    | USB_DeviceContext.USB_DeviceStatus.SelfPowered
N#endif /* USB_SELF_POWERED_SUPPORTED */
N#ifdef USB_REMOTE_WAKEUP_SUPPORTED
S                    | (USB_DeviceContext.USB_DeviceStatus.RemoteWakeupEnabled << 1)
N#endif /* USB_REMOTE_WAKEUP_SUPPORTED */
N                    ;
N                  break;
N                /* Interface - return 0 */
N                case USB_RECIPIENT_INTERFACE:
N                  SetupPacketData[0] = 0;
N                  break;
N                /* Endpoint - return Halt status */
N                case USB_RECIPIENT_ENDPOINT:
N                  SetupPacketData[0] = USB_EPContext[wIndex].EP_Halt;
N                  break;
N              }
N              SetupPacketData[1] = 0;
N              result = USB_EP_doDataIn(EPx, SetupPacketData, 2, 0);
N            }
N          }
N          break;
N        /* CLEAR_FEATURE */
N        case USB_CLEAR_FEATURE:
N          if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
N              (recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
N          {
N            result = USB_ERROR;
N          }
N          else
N          {
N            result = USB_DEVICE_HANDLE_CLEAR_FEATURE(recipient, wValue, wIndex);
X            result = USB_DeviceClearFeature(recipient, wValue, wIndex);
N          }
N          break;
N        /* SET_FEATURE */
N        case USB_SET_FEATURE:
N          if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
N              (recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
N          {
N            result = USB_ERROR;
N          }
N          else
N          {
N            result = USB_DEVICE_HANDLE_SET_FEATURE(recipient, wValue, wIndex);
X            result = USB_DeviceSetFeature(recipient, wValue, wIndex);
N          }
N          break;
N        /* SET_ADDRESS */
N        case USB_SET_ADDRESS:
N          result = USB_DEVICE_HANDLE_SET_ADDRESS(wValue);
X          result = USB_SUCCESS;
N          /* Set special Status Stage handler that will actually change the address */
N          USB_DeviceContext.Address = wValue;
N          statusAckHandler = USB_Device_setAddressWork;
N          break;
N        /* GET_DESCRIPTOR */
N        case USB_GET_DESCRIPTOR:
N          result = USB_DEVICE_HANDLE_GET_DESCRIPTOR(wValue, wIndex, wLength);
X          result = USB_CDC_GetDescriptor(wValue, wIndex, wLength);
N          break;
N        /* SET_DESCRIPTOR */
N        case USB_SET_DESCRIPTOR:
N          result = USB_DEVICE_HANDLE_SET_DESCRIPTOR(wValue, wIndex, wLength);
X          result = USB_ERROR;
N          break;
N        /* GET_CONFIGURATION */
N        case USB_GET_CONFIGURATION:
N          if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
N          {
N            SetupPacketData[0] = 0;
N          }
N          else
N          {
N            SetupPacketData[0] = (uint8_t)USB_DEVICE_HANDLE_GET_CONFIGURATION;
X            SetupPacketData[0] = (uint8_t)1;
N          }
N          result = USB_EP_doDataIn(EPx, SetupPacketData, 1, 0);
N          break;
N        /* SET_CONFIGURATION */
N        case USB_SET_CONFIGURATION:
N          if (wValue == 0)
N          {
N            USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_ADDRESS;
N          }
N          else
N          {
N            result = USB_DEVICE_HANDLE_SET_CONFIGURATION(wValue);
X            result = ((wValue) == 1 ? USB_SUCCESS : USB_ERROR);
N            if (result == USB_SUCCESS)
N            {
N              USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_CONFIGURED;
N            }
N          }
N          break;
N        /* GET_INTERFACE */
N        case USB_GET_INTERFACE:
N          if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
N          {
N            result = USB_ERROR;
N          }
N          else
N          {
N            SetupPacketData[0] = (uint8_t)USB_DEVICE_HANDLE_GET_INTERFACE(wIndex);
X            SetupPacketData[0] = (uint8_t)0;
N            result = USB_EP_doDataIn(EPx, SetupPacketData, 1, 0);
N          }
N          break;
N        /* SET_INTERFACE */
N        case USB_SET_INTERFACE:
N          if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
N          {
N            result = USB_ERROR;
N          }
N          else
N          {
N            result = USB_DEVICE_HANDLE_SET_INTERFACE(wValue, wIndex);
X            result = ((wIndex) == 0 && (wValue) == 0 ? USB_SUCCESS : USB_ERROR);
N          }
N          break;
N        /* SYNCH_FRAME */
N        case USB_SYNCH_FRAME:
N          if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
N          {
N            result = USB_ERROR;
N          }
N          else
N          {
N            result = USB_DEVICE_HANDLE_SYNC_FRAME(wIndex, SetupPacketData);
X            result = USB_ERROR;
N            if (result == USB_SUCCESS)
N            {
N              result = USB_EP_doDataIn(EPx, SetupPacketData, 2, 0);
N            }
N          }
N          break;
N        default:
N          result = USB_ERR_INV_REQ;
N      }
N      /* If there were no DATA stage, initiate Status Stage (IN ACK) */
N      if (result == USB_SUCCESS && wLength == 0)
N      {
N        result = (USB_SetupPacket->mRequestTypeData & 0x80) == USB_DEVICE_TO_HOST ?
N                        USB_EP_doDataOut(EPx, 0, 0, statusAckHandler) :
N                        USB_EP_doDataIn(EPx, 0, 0, statusAckHandler);
N      }
N      break;
N    }
N    /* Class-specific request */
N    case USB_TYPE_CLASS:
N      result = USB_DEVICE_HANDLE_CLASS_REQUEST;
X      result = USB_CDC_ClassRequest();
N      break;
N    /* Vendor-specific request */
N    case USB_TYPE_VENDOR:
N      result = USB_DEVICE_HANDLE_VENDOR_REQUEST;
X      result = USB_ERROR;
N      break;
N    default:
N      result = USB_ERR_INV_REQ;
N  }
N  return result;
N}
N
N/** @} */ /* End of group USB_Device_Private_Handlers */
N
N/** @defgroup USB_Device_deviceSetupPacket_Handlers USB Device Standard Request specific handlers
N  * @{
N  */
N
N/**
N  * @brief  Called on CLEAR_FEATURE request (9.4.1).
N  *
N  * @param  Recipient: Recipient type (from setup packet header).
N  *         This parameter can be one of the following values:
N  *         USB_RECIPIENT_DEVICE, USB_RECIPIENT_INTERFACE,
N  *         USB_RECIPIENT_ENDPOINT, USB_RECIPIENT_OTHER.
N  *
N  * @param  wVALUE: Feature selector.
N  *
N  * @param  wINDEX: Interface or EndPoint number, if Recipient has
N  *         appropriate value.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. This implementation
N  *         process ENDPOINT_HALT (calling USB_EP_Ready) and DEVICE_REMOTE_WAKEUP
N  *         (clearing RemoteWakeupEnabled context flag) standard features only.
N  */
N
NUSB_Result USB_DeviceClearFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX)
N{
N  if ((Recipient == USB_RECIPIENT_ENDPOINT) && (wVALUE == USB_ENDPOINT_HALT))
N  {
N    return USB_EP_Idle((USB_EP_TypeDef)wINDEX);
N  }
N  else
N  {
N    return USB_ERROR;
N  }
N}
N
N/**
N  * @brief  Called on SET_FEATURE request (9.4.9).
N  *
N  * @param  Recipient: Recipient type (from setup packet header).
N  *         This parameter can be one of the following values:
N  *         USB_RECIPIENT_DEVICE, USB_RECIPIENT_INTERFACE,
N  *         USB_RECIPIENT_ENDPOINT, USB_RECIPIENT_OTHER.
N  *
N  * @param  wVALUE: Feature selector.
N  *
N  * @param  wINDEX: Interface or EndPoint number, if Recipient has
N  *         appropriate value.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. This implementation
N  *         process ENDPOINT_HALT (calling USB_EP_Stall) and DEVICE_REMOTE_WAKEUP
N  *         (setting RemoteWakeupEnabled context flag) standard features only.
N  */
N
NUSB_Result USB_DeviceSetFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX)
N{
N  if ((Recipient == USB_RECIPIENT_ENDPOINT) && (wVALUE == USB_ENDPOINT_HALT))
N  {
N    return USB_EP_Stall((USB_EP_TypeDef)wINDEX, USB_STALL_HALT);
N  }
N  else
N  {
N    return USB_ERROR;
N  }
N}
N
N/** @} */ /* End of group USB_Device_deviceSetupPacket_Handlers */
N
N/** @defgroup USB_Device_Status_Stage_Handlers USB Device Service Functions
N  * @{
N  */
N
N/**
N  * @brief Implements Status stage of Setup transaction with OUT data stage
N  *        or without data stage. To be used as EndPoint transaction handler.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  Buffer: Pointer to the user's buffer with portion of data
N  *                 to be sent
N  *
N  * @param  Length: Length of data portion
N  *
N  * @retval USB_Result.
N  *
N  * @note   This function interface reflects EndPoint data transmitting handler
N  *         requirements.
N  */
N
NUSB_Result USB_DeviceDoStatusInAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
N{
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief Implements Status stage of Setup transaction with IN data stage.
N  *        To be used as EndPoint transaction handler.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  Buffer: Pointer to the user's buffer for next portion of data
N  *
N  * @param  Length: Length of data portion
N  *
N  * @retval USB_Result.
N  *
N  * @note   This function interface reflects EndPoint data transmitting handler
N  *         requirements.
N  */
N
NUSB_Result USB_DeviceDoStatusOutAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
N{
N  return USB_EP_doDataOut(EPx, 0, 0, 0);
N}
N
N/**
N  * @brief Implements Status stage of Setup SET_ADDRESS transaction.
N  *        Actually changes the device address. To be used as EndPoint
N  *        transaction handler.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  Buffer: Pointer to the user's buffer with portion of data
N  *                 to be sent
N  *
N  * @param  Length: Length of data portion
N  *
N  * @retval USB_Result.
N  *
N  * @note   This function interface reflects EndPoint data transmitting handler
N  *         requirements.
N  */
N
Nstatic USB_Result USB_Device_setAddressWork(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
N{
N  /* Set address */
N  USB_SetSA(USB_DeviceContext.Address);
N  /* Adjust device state */
N  USB_DeviceContext.USB_DeviceState = (USB_DeviceContext.Address ? USB_DEV_STATE_ADDRESS : USB_DEV_STATE_DEFAULT);
N
N  return USB_SUCCESS;
N}
N
N/** @} */ /* End of group USB_Device_Status stage _Handlers */
N
N/**
N  * @brief  USB interrupt dispatcher, called from interrupt handler
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  *
N  * @note   Handles common events (such as Reset) and calls USB_EP_setSetupHandler
N  *         for each EndPoint in use.
N  */
N
NUSB_Result USB_DeviceDispatchEvent(void)
N{
N  uint32_t i;
N  uint32_t USB_IT;
N  USB_Result result = USB_SUCCESS;
N  static volatile uint32_t bHandling = RESET;
N
N  /* Disable USB interrupts */
N#ifdef USB_INT_HANDLE_REQUIRED
N  NVIC_DisableIRQ(USB_IRQn);
N#endif /* USB_INT_HANDLE_REQUIRED */
N
N  if (!bHandling) {
N    bHandling = SET;
N
N    /* Get masked interrupt flags */
N    USB_IT = USB_GetSIS();
N    /* Handle reset */
N    if (USB_IT & USB_SIS_SCRESETEV)
X    if (USB_IT & ((uint32_t)0x00000004))
N    {
N      result = USB_DeviceReset();
N    }
N
N    /* Invoke End Point dispatchers */
N    for (i = USB_EP0; i < Num_USB_EndPoints; i++)
N    {
N      USB_EP_dispatchEvent((USB_EP_TypeDef)i, USB_IT);
N    }
N
N    /* Clear pending bits, except for SCTDONE */
N    USB_SetSIS(USB_IT & (~USB_SIS_SCTDONE_Set));
X    USB_SetSIS(USB_IT & (~((uint32_t)0x00000001)));
N
N    bHandling = RESET;
N
N    /* Enable USB interrupts (only after the actual work is done) */
N#ifdef USB_INT_HANDLE_REQUIRED
N    NVIC_EnableIRQ(USB_IRQn);
N#endif /* USB_INT_HANDLE_REQUIRED */
N  }
N  return result;
N}
N
N#ifdef USB_INT_HANDLE_REQUIRED
N/**
N  * @brief  Default implementation of USB interrupt handler
N  *
N  * @param  None
N  *
N  * @retval None
N  *
N  * @note   To be overwritten, USB_INT_HANDLE_REQUIRED definition should be
N  *         undefined.
N  *
N  */
N
Nvoid USB_IRQHandler(void)
N{
N  USB_DeviceDispatchEvent();
N}
N#endif /* USB_INT_HANDLE_REQUIRED */
N
N
N/** @defgroup USB_Device_Private_Dummy_Functions USB Device Private Handler Samples
N  * @{
N  */
N
N/**
N  * @brief  GET_STATUS standard request handler sample (9.4.5).
N  *
N  * @param  Recipient: Recipient type (from setup packet header).
N  *         This parameter can be one of the following values:
N  *         USB_RECIPIENT_DEVICE, USB_RECIPIENT_INTERFACE,
N  *         USB_RECIPIENT_ENDPOINT, USB_RECIPIENT_OTHER.
N  *
N  * @param  wINDEX: Interface or EndPoint number, if Recipient has
N  *         appropriate value.
N  *
N  * @retval USB_Result.
N  *
N  * @note   Intended to update USB_DeviceStatus field of the device context
N  *         before the status to be sent to host. Data stage begins if USB_SUCCESS
N  *         is returned.
N  */
N
NUSB_Result USB_DeviceDummyGetStatus(USB_RequestRecipient_TypeDef Recipient, uint16_t wINDEX)
N{
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  SET_ADDRESS standard request handler (preparation) sample (9.4.6).
N  *
N  * @param  wVALUE: New device address
N  *
N  * @retval USB_Result.
N  *
N  * @note   Intended to do perform actions while still in setup transaction
N  *         (actual address change to be performed after status stage completes).
N  *         If value returned is not USB_SUCCESS, transaction is aborted.
N  */
N
NUSB_Result USB_DeviceDummySetAddress(uint16_t wVALUE)
N{
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  GET_DESCRIPTOR standard request handler sample (9.4.3).
N  *
N  * @param  wVALUE: Descriptor Type and Descriptor Index
N  *
N  * @param  wINDEX: Zero or Language ID (see 9.6.7)
N  *
N  * @param  wLENGTH: Amount of data host is willing to receive.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         in any device class. It is expected to either perform data transfer
N  *         and status stages on its own (calling USB_EP_doDataIn), or return
N  *         value that is not USB_SUCCESS.
N  */
N
NUSB_Result USB_DeviceDummyGetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH)
N{
N  return USB_ERROR;
N}
N
N/**
N  * @brief  SET_DESCRIPTOR standard request handler sample (9.4.8).
N  *
N  * @param  wVALUE: Descriptor Type and Descriptor Index
N  *
N  * @param  wINDEX: Zero or Language ID (see 9.6.7)
N  *
N  * @param  wLENGTH: Amount of data to be sent by host.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         only if the device supports descriptor update by host. It is expected
N  *         to either perform data transfer and status stages on its own (calling
N  *         USB_EP_doDataOut), or return value that is not USB_SUCCESS.
N  */
N
NUSB_Result USB_DeviceDummySetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH)
N{
N  return USB_ERROR;
N}
N
N/**
N  * @brief  GET_CONFIGURATION standard request handler sample (9.4.2).
N  *
N  * @param  None
N  *
N  * @retval Currently selected configuration number or 0 on error.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         if the device supports more than one configuration.
N  */
N
Nuint8_t USB_DeviceDummyGetConfiguration(void)
N{
N  return 1;
N}
N
N/**
N  * @brief  SET_CONFIGURATION standard request handler sample (9.4.7).
N  *
N  * @param  wVALUE: Configuration number
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         if the device supports more than one configuration.
N  */
N
NUSB_Result USB_DeviceDummySetConfiguration(uint16_t wVALUE)
N{
N  return USB_ERROR;
N}
N
N/**
N  * @brief  GET_INTERFACE standard request handler sample (9.4.4).
N  *
N  * @param  wINDEX: Interface number.
N  *
N  * @retval Currently selected alternate setting for the specified interface
N  *         or 0 in case of error.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         if the device supports interfaces with alternate settings.
N  */
N
Nuint8_t USB_DeviceDummyGetInterface(uint16_t wINDEX)
N{
N  return 0;
N}
N
N/**
N  * @brief  SET_INTERFACE standard request handler sample (9.4.10).
N  *
N  * @param  wVALUE: Alternate setting to be set.
N  *
N  * @param  wINDEX: Interface number.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         if the device supports interfaces with alternate settings.
N  */
N
NUSB_Result USB_DeviceDummySetInterface(uint16_t wVALUE, uint16_t wINDEX)
N{
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  SYNC_FRAME standard request handler sample (9.4.11).
N  *
N  * @param  wINDEX: EndPoint number.
N  *
N  * @param  DATA: Pointer for frame number.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         if some of the device EndPoints support isochronous transfers. It is
N  *         expected to place EndPoint synchronization frame number into DATA pointed
N  *         location or return value that is not USB_SUCCESS.
N  */
N
NUSB_Result USB_DeviceDummySyncFrame(uint16_t wINDEX, uint8_t* DATA)
N{
N  return USB_ERROR;
N}
N
N/**
N  * @brief  Class-type setup request handler sample.
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         the device supports any class-type requests. Request setup packet data
N  *         is accessible by USB_CurrentSetupPacket variable. The overwritten method
N  *         should implement both data (if present) and status transfer stages.
N  */
N
NUSB_Result USB_DeviceDummyClassRequest(void)
N{
N  return USB_ERROR;
N}
N
N/**
N  * @brief  Vendor-type setup request handler sample.
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         the device supports any vendor-type requests. Request setup packet data
N  *         is accessible by USB_CurrentSetupPacket variable. The overwritten method
N  *         should implement both data (if present) and status transfer stages.
N  */
N
N
NUSB_Result USB_DeviceDummyVendorRequest(void)
N{
N  return USB_ERROR;
N}
N
N
N/**
N  * @brief  EndPoint error handler sample.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  STS: USB_SEPx.STS register value.
N  *
N  * @param  TS: USB_SEPx.TS register value.
N  *
N  * @param  CTRL: USB_SEPx.CTRL register value.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This function interface reflects EndPoint error handler
N  *         requirements. When called on IN transaction error:
N  *          - if it hasn't start another transaction and returns USB_SUCCESS,
N  *            then retry of data transmission would occur;
N  *          - if it returns error code, EndPoint would be switched to
N  *            NAK/STALL state.
N  */
N
NUSB_Result USB_DeviceDummyDataError(USB_EP_TypeDef EPx, uint32_t STS, uint32_t TS, uint32_t CTRL)
N{
N  return USB_ERROR;
N}
N
N/** @} */ /* End of group USB_Device_Private_Dummy_Functions */
N
N
N/** @} */ /* End of group USB_Device_Private_Functions */
N
N/** @} */ /* End of group USB_Device */
N
N/** @} */ /* End of group USB_DEVICE_AND_CDC */
N
N/** @} */ /* End of group MDR32F9Qx_StdPeriph_Driver */
N
N/******************* (C) COPYRIGHT 2011 Phyton *********
N*
N* END OF FILE MDR32F9Qx_usb_device.c */
N
